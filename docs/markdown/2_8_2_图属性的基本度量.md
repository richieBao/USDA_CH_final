> Created on Sat Jan 14 22:11:50 2023 @author: Richie Bao-caDesign设计(cadesign.cn)

## 2.8.2  图属性的基本度量


### 2.8.2.1 构建土地利用类型的样方式复杂网络

土地利用或土地覆盖类型数据通常为栅格（raster）或者SHP格式数据，表征土地使用（利用）方式和覆盖对象。在“不平等性和空间隔离”章节，基于样方采样使用`PySAL`库分析样方单元间的空间分布关系。本次实验依旧使用芝加哥区的土地利用数据（在“不平等性和空间隔离”章节已转换为栅格数据），采用样方采样的方式提取对应单元的土地利用类型（样方内栅格单元最多的类别）作为复杂网络顶点属性值，通过空间权重`Queen`的方式构建复杂网络。

参数管理使用AttrDict()方法（具体查看“Cityscapes数据集——参数管理”一节）。


```python
import warnings
warnings.filterwarnings('ignore')

from database import postSQL2gpd,gpd2postSQL
from util_misc import AttrDict
from pyproj import CRS
__C=AttrDict() 
args=__C

__C.gi=AttrDict()
__C.gi.epsg_wgs84=CRS('epsg:4326')

__C.data=AttrDict()
__C.data.landuse_tif='E:\data\Chicago_landuse\landuse.tif' # 土地利用栅格数据文件路径
```

#### 1) 构建样方

使用`rasterio`库读取土地利用栅格数据，打印地图，查看数据是否正确，及范围和投影等信息。土地利用分类的颜色使用了默认配置。


```python
import rasterio as rio
with rio.open(args.data.landuse_tif) as src:    
    landuse_array=src.read()
    transform=src.transform
    epsg_Chicago=src.crs
    
print(epsg_Chicago)
```

    EPSG:32616
    


```python
import matplotlib.pyplot as plt
import copy
landuse_array_copy=copy.deepcopy(landuse_array,)
landuse_array_copy[landuse_array_copy==-9999]=-1
plt.imshow(landuse_array_copy[0]);
```


<img src="./imgs/2_8_2/output_5_0.png" height='auto' width='auto' title="caDesign">    



比对实验可以有效观察度量值变化关系，因此建立2个样方组。为了使得构建的样方组区域大小相同，定义`pt_on_quadrat()`函数，可以根据已知样方组对角点和未知样方组已知一点，求其对角点，用于后续样方的构建。


```python
def pt_on_quadrat(old_lb,old_rt,new_pt,position):  
    '''
    已知一个样方左下方法点坐标和右上方点坐标，及另一个样方一点坐标，求另一样方的对角点坐标

    Parameters
    ----------
    old_lb : list[float,float]
        已知样方左下角坐标.
    old_rt : list[float,float]
        已知样方右上角坐标.
    new_pt : list[float,float]
        待求样方点已知一点坐标.
    position : string
        待求样方点已知一点的位置，包括lb（左下角）,lt（左上角）,rb（右下角）,rt（右上角）.

    Returns
    -------
    list
        返回待求样方已知点的对角点.

    '''    
    lb_x,lb_y=old_lb
    rt_x,rt_y=old_rt
    
    width=rt_x-lb_x
    height=rt_y-lb_y
    
    pt_x,py_y=new_pt
    if position=='lb':
        return [pt_x+width,py_y+height]
    if position=='lt':
        return [pt_x+width,py_y-height]
    if position=='rb':
        return [pt_x-width,py_y+height]    
    if position=='rt':
        return [pt_x-width,py_y-height]    

pt_leftBottom_a=[-87.686081,41.859394]
pt_rightTop_a=[-87.636496,41.910544] 

pt_leftBottom_b=[-88.125199,41.751791]
pt_rightTop_b=pt_on_quadrat(pt_leftBottom_a,pt_rightTop_a,pt_leftBottom_b,position='lb')
print(pt_rightTop_b)
```

    [-88.07561399999999, 41.802941]
    

WGS84:World Geodetic System 1984，是为GPS全球定位系统使用而建立的坐标系统，也通常用于不同投影系统的中间转换坐标系统；诸如Googel Earth或者QGis等地理信息系统平台都支持WGS84坐标的查询，因此在确定样方组的位置时，通常在Googel Earth或者QGis等平台下确定坐标，但是需要将其转换为相应的投影坐标后进行后续相关计算，例如土地利用数据的投影为`EPSG:32616`。为了正确对位构建样方组并采样栅格值，需要将查询的WGS84坐标转换为`EPSG:32616`，定义`pt_coordi_transform()`函数实现坐标转换功能，主要使用[pyproj](https://pyproj4.github.io/pyproj/stable/)<sup>①</sup>实现，该库通常在安装处理地理空间数据相关库时，例如`GeoPanda`、`rasterio`、`PyLab`等，会作为依赖库安装。


```python
def pt_coordi_transform(old_epsg,new_epsg,pt_coordinate):
    '''
    转换点坐标投影

    Parameters
    ----------
    old_epsg : pyproj.crs.crs.CRS
        点坐标投影.
    new_epsg : pyproj.crs.crs.CRS
        转换为的投影.
    pt_coordinate : list[float,float]
        点坐标.

    Returns
    -------
    list[float,float]
        转换投影后的点坐标.

    '''    
    from pyproj import Transformer,transform

    transformer=Transformer.from_crs(old_epsg,new_epsg,always_xy=True)    
    return  transformer.transform(pt_coordinate[0], pt_coordinate[1])

    
a_lb_pj=pt_coordi_transform(args.gi.epsg_wgs84,epsg_Chicago,pt_leftBottom_a)
a_rt_pj=pt_coordi_transform(args.gi.epsg_wgs84,epsg_Chicago,pt_rightTop_a)
b_lb_pj=pt_coordi_transform(args.gi.epsg_wgs84,epsg_Chicago,pt_leftBottom_b)
b_rt_pj=pt_coordi_transform(args.gi.epsg_wgs84,epsg_Chicago,pt_rightTop_b)
print(a_lb_pj,a_rt_pj)
```

    (443055.3395470082, 4634392.60912833) (447213.0314665211, 4640039.960841755)
    

将“不平等性和空间隔离”一章中定义的`rec_quadrats_gdf()`网格式样方构建工具置于`util_misc`模块中调用，定义两个样方组`quadrats_a_gdf`和`quadrats_b_gdf`。为了减小计算量，配置样方大小为100×100，实际上需要根据不同实验精度要求和分析对象的尺寸尺度确定样方单元大小。


```python
import util_misc
cell_size=100
quadrats_a_gdf=util_misc.rec_quadrats_gdf(a_lb_pj,a_rt_pj,cell_size,cell_size,crs=epsg_Chicago)
quadrats_b_gdf=util_misc.rec_quadrats_gdf(b_lb_pj,b_rt_pj,cell_size,cell_size,crs=epsg_Chicago)
print(quadrats_a_gdf.shape,quadrats_b_gdf.shape)
```

    (2296, 1) (2296, 1)
    

叠加打印土地利用地图和两个样方组，确定构建的样方组位置正确。


```python
from rasterio.plot import show
f, ax=plt.subplots()
show(landuse_array_copy,ax=ax,transform=transform)
quadrats_a_gdf.plot(color='none',edgecolor='k',linewidth=1,ax=ax,linestyle='--')
quadrats_b_gdf.plot(color='none',edgecolor='k',linewidth=1,ax=ax,linestyle='--')
plt.show()
```

<img src="./imgs/2_8_2/output_13_0.png" height='auto' width='auto' title="caDesign">
    


上述叠加打印的地图存在两个问题，一是，土地利用栅格数据打印的色彩为随机配置，不容易通过颜色区分土地利用类型的分布情况。二是，样方组比较小，而地图比较大，可以粗略观察样方组位置是否正确，但是无法看清样方组和土地利用类别分布之间的关系。因此对应上述两个问题，分别处理。

* 解决分类色彩问题

芝加哥的土地利用分类包括一级分类和二级分类，读取的栅格数据为二级分类数据，为了方便查看分类，仅显示一级分类，因此需要将读取的二级分类栅格数据数组转换为一级分类，不同分类级别之间的映射关系可以查看“不平等性和空间隔离”一章，本次实验直接复制已有映射关系字典，进行相关操作完成分类等级转换。


```python
landuse_mapping={'LANDUSE': {'1111': 0, '1112': 1, '1130': 2, '1140': 3, '1151': 4, '1211': 5, '1212': 6, '1214': 7, '1215': 8, '1216': 9, '1220': 10, '1240': 11, '1250': 12, '1310': 13, '1321': 14, '1322': 15, '1330': 16, '1340': 17, '1350': 18, '1360': 19, '1370': 20, '1380': 21, '1410': 22, '1420': 23, '1431': 24, '1432': 25, '1433': 26, '1450': 27, '1511': 28, '1512': 29, '1520': 30, '1530': 31, '1540': 32, '1550': 33, '1561': 34, '1562': 35, '1563': 36, '1564': 37, '1565': 38, '1570': 39, '2000': 40, '3100': 41, '3200': 42, '3300': 43, '3400': 44, '3500': 45, '4110': 46, '4120': 47, '4130': 48, '4140': 49, '4210': 50, '4220': 51, '4230': 52, '4240': 53, '5000': 54, '6000': 55, '9999': 56}, 
                 'CHname': {'独栋单户住宅': 0, '连排单户住宅': 1, '多户住宅': 2, '托车移动住宅': 3, '住宅开发区内公共开放空间': 4, '购物广场': 5, '区域社区零售中心': 6, '单一大型零售点': 7, '城市混合用地': 8, '含住宅的城市混合用地': 9, '办公': 10, '文化娱乐': 11, '酒店旅馆': 12, '医疗设施': 13, 'K_12教育设施': 14, '大学教育设施': 15, '政府行政和服务': 16, '监狱和惩教设施': 17, '宗教设施': 18, '墓地': 19, '其他机构': 20, '国家实验室': 21, '矿物提取': 22, '一般工业': 23, '制造加工': 24, '仓储配送': 25, '不确定用地': 26, '贮存': 27, '铁路': 28, '高速公路': 29, '其他具有相关设施的线性交通': 30, '航空运输': 31, '独立停车场': 32, '通讯': 33, '公用事业通行权': 34, '废水处理设施': 35, '垃圾填埋场': 36, '其它公用设施废物': 37, '雨水管理': 38, '联运设施': 39, '农业': 40, '开放空间主要娱乐设施': 41, '高尔夫球场': 42, '开放空间主要保护区': 43, '非公共开放空间': 44, '步道或绿道': 45, '空置住宅用地': 46, '空置商业用地': 47, '空置工业用地': 48, '其它空置': 49, '在建住宅': 50, '在建商业': 51, '在建工业': 52, '其他或未知在建': 53, '水体': 54, '非包裹区域': 55, '未分类': 56}}
label2name={v:k for k,v in landuse_mapping['CHname'].items()}
print(label2name)
```

    {0: '独栋单户住宅', 1: '连排单户住宅', 2: '多户住宅', 3: '托车移动住宅', 4: '住宅开发区内公共开放空间', 5: '购物广场', 6: '区域社区零售中心', 7: '单一大型零售点', 8: '城市混合用地', 9: '含住宅的城市混合用地', 10: '办公', 11: '文化娱乐', 12: '酒店旅馆', 13: '医疗设施', 14: 'K_12教育设施', 15: '大学教育设施', 16: '政府行政和服务', 17: '监狱和惩教设施', 18: '宗教设施', 19: '墓地', 20: '其他机构', 21: '国家实验室', 22: '矿物提取', 23: '一般工业', 24: '制造加工', 25: '仓储配送', 26: '不确定用地', 27: '贮存', 28: '铁路', 29: '高速公路', 30: '其他具有相关设施的线性交通', 31: '航空运输', 32: '独立停车场', 33: '通讯', 34: '公用事业通行权', 35: '废水处理设施', 36: '垃圾填埋场', 37: '其它公用设施废物', 38: '雨水管理', 39: '联运设施', 40: '农业', 41: '开放空间主要娱乐设施', 42: '高尔夫球场', 43: '开放空间主要保护区', 44: '非公共开放空间', 45: '步道或绿道', 46: '空置住宅用地', 47: '空置商业用地', 48: '空置工业用地', 49: '其它空置', 50: '在建住宅', 51: '在建商业', 52: '在建工业', 53: '其他或未知在建', 54: '水体', 55: '非包裹区域', 56: '未分类'}
    


```python
parentClass_mapping={'城市化区域': ['1000'], 
                     '住宅': ['1110', '1111', '1112', '1130', '1140', '1150', '1151'], 
                     '商业': ['1200', '1210', '1211', '1212', '1214', '1215', '1216', '1220', '1240', '1250'], 
                     '机构': ['1300', '1310', '1320', '1321', '1322', '1330', '1340', '1350', '1360', '1370', '1380'], 
                     '工业': ['1400', '1410', '1420', '1430', '1431', '1432', '1433', '1450'], 
                     '交通_通讯_公共事业和垃圾处理': ['1500', '1510', '1511', '1512', '1520', '1530', '1540', '1550', '1560', '1561', '1562', '1563', '1564', '1565', '1570'],
                     '其它': ['2000', '4000', '4100', '4110', '4120', '4130', '4140', '4200', '4210', '4220', '4230', '4240', '9999'], 
                     '开放空间': ['3000', '3100', '3200', '3300', '3400', '3500'],
                     '水体': ['5000'],
                     '非包裹区域': ['6000']}

label2parentClass={}
for num,label in landuse_mapping['LANDUSE'].items():
    for parentName,num_lst in parentClass_mapping.items():
        if num in num_lst:
            label2parentClass[label]=parentName
print(label2parentClass)  
```

    {0: '住宅', 1: '住宅', 2: '住宅', 3: '住宅', 4: '住宅', 5: '商业', 6: '商业', 7: '商业', 8: '商业', 9: '商业', 10: '商业', 11: '商业', 12: '商业', 13: '机构', 14: '机构', 15: '机构', 16: '机构', 17: '机构', 18: '机构', 19: '机构', 20: '机构', 21: '机构', 22: '工业', 23: '工业', 24: '工业', 25: '工业', 26: '工业', 27: '工业', 28: '交通_通讯_公共事业和垃圾处理', 29: '交通_通讯_公共事业和垃圾处理', 30: '交通_通讯_公共事业和垃圾处理', 31: '交通_通讯_公共事业和垃圾处理', 32: '交通_通讯_公共事业和垃圾处理', 33: '交通_通讯_公共事业和垃圾处理', 34: '交通_通讯_公共事业和垃圾处理', 35: '交通_通讯_公共事业和垃圾处理', 36: '交通_通讯_公共事业和垃圾处理', 37: '交通_通讯_公共事业和垃圾处理', 38: '交通_通讯_公共事业和垃圾处理', 39: '交通_通讯_公共事业和垃圾处理', 40: '其它', 41: '开放空间', 42: '开放空间', 43: '开放空间', 44: '开放空间', 45: '开放空间', 46: '其它', 47: '其它', 48: '其它', 49: '其它', 50: '其它', 51: '其它', 52: '其它', 53: '其它', 54: '水体', 55: '非包裹区域', 56: '其它'}
    

配置一级分类对应的颜色及用于色彩对位指定的整数序列（levels）字典，通过`matplotlib`库提供的`matplotlib.colors.from_levels_and_colors`方法构建`cmap（colormap）`对象。


```python
import matplotlib
parentClass_idNcolor={
    '住宅':[0,"wheat"],
    '商业':[1,"tomato"],
    '机构':[2,"thistle"],
    '工业':[3,"darkslateblue"],
    '交通_通讯_公共事业和垃圾处理':[4,"slategrey"],
    '其它':[5,"whitesmoke"],
    '开放空间':[6,"yellowgreen"],
    '水体':[7,'cornflowerblue'],
    '非包裹区域':[8,"gray"]
    }

parentClass_color={v[0]:v[1] for v in parentClass_idNcolor.values()}
print(parentClass_color)
cmap_LC, norm=matplotlib.colors.from_levels_and_colors(list(parentClass_color.keys()),list(parentClass_color.values()),extend='max')
cmap_LC
```

    {0: 'wheat', 1: 'tomato', 2: 'thistle', 3: 'darkslateblue', 4: 'slategrey', 5: 'whitesmoke', 6: 'yellowgreen', 7: 'cornflowerblue', 8: 'gray'}
    




<img src="./imgs/2_8_2/2_8_2_02.png" height='auto' width='auto' title="caDesign">




```python
label2parentClassID={k:parentClass_idNcolor[v][0] for k,v in label2parentClass.items()}
print(label2parentClassID)
```

    {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1, 13: 2, 14: 2, 15: 2, 16: 2, 17: 2, 18: 2, 19: 2, 20: 2, 21: 2, 22: 3, 23: 3, 24: 3, 25: 3, 26: 3, 27: 3, 28: 4, 29: 4, 30: 4, 31: 4, 32: 4, 33: 4, 34: 4, 35: 4, 36: 4, 37: 4, 38: 4, 39: 4, 40: 5, 41: 6, 42: 6, 43: 6, 44: 6, 45: 6, 46: 5, 47: 5, 48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 7, 55: 8, 56: 5}
    

* 解决地图大而样方组小的叠加显示问题

不读取全部栅格数据，仅读取样方组区域，建立`rio_read_subset()`函数实现，主要使用了`rasterio`库提供的`Window`方法。需要注意地图以坐标表达，（正值）经度由小到大的方向为从左到右，（正值）纬度从下到上，即左下角坐标最小；而图像通常以行列表述，从左上角开始，向右（列）增大，向下（行）增大，因此在定义`rio_read_subset()`函数时，经纬度通过`src.index`方法转换后为行列，后续计算则需要区分清高（height）宽（width）计算所用坐标和`Window`输入参数的变化。


```python
def rio_read_subset(fn,lbNrt_coordinates):
    '''
    指定左下角和右上角坐标，部分读取栅格数据

    Parameters
    ----------
    fn : string
        栅格数据文件路径.
    lbNrt_coordinates :list[[float,float]] 
        左下角坐标和右上角坐标嵌套列表.

    Returns
    -------
    data : array
        根据左下角和右上角坐标提取的部分栅格数据.
    transform : affine.Affine
        投影变换.

    '''    
    from rasterio.windows import Window
    import rasterio as rio
    
    lb_x,lb_y=lbNrt_coordinates[0]
    rt_x,rt_y=lbNrt_coordinates[1]        

    with rio.open(fn) as src:    
        lb_row_idx,lb_col_idx=src.index(lb_x, lb_y) # rio.transform.rowcol(src.transform,lb_x,lb_y)    
        rt_row_idx,rt_col_idx=src.index(rt_x,rt_y)
        height,width=lb_row_idx-rt_row_idx,rt_col_idx-lb_col_idx    
        window=Window(lb_col_idx,lb_row_idx-height,width,height)           
        data=src.read(window=window)         
        transform=rio.windows.transform(window,src.transform)

    return data,transform  
```


```python
lu_a,transform_a=rio_read_subset(args.data.landuse_tif,[a_lb_pj,a_rt_pj])  
```

定义`array_values_replacing()`函数实现数组值的替换，即可以将土地利用分类，根据二级分类和一级分类的映射关系，将二级分类转换为一级分类。


```python
def array_values_replacing(array,mapping):
    '''
    根据字典，进行维数组数值的替换（不包含在映射字典中的值，将替换为-1）

    Parameters
    ----------
    array : 2d-array
        数组.
    mapping : dict
        数值替换映射字典.

    Returns
    -------
    array_replaced : 2d-array
        替换值后的数组.

    '''    
    import numpy as np
    indexer=np.array([mapping.get(i, -1) for i in range(array.min(), array.max() + 1)])
    array_replaced=indexer[(array - array.min())]    
    return array_replaced

lu_a_parentClass=array_values_replacing(lu_a,label2parentClassID)
print(lu_a_parentClass)
```

    [[[8 8 8 ... 8 8 8]
      [5 5 5 ... 8 8 8]
      [5 5 5 ... 8 8 8]
      ...
      [3 8 8 ... 4 4 4]
      [3 8 8 ... 4 4 4]
      [8 8 8 ... 4 4 4]]]
    

在使用`rasterio.plot.show`方法打印地图，需要配置`transform`参数定位到地图实际的地理位置上；配置`norm`参数对位自定义的`cmap`颜色。土地利用地图和样方组均打印到同一子图`ax`下。


```python
f, ax=plt.subplots(figsize=(20,20))
show(lu_a_parentClass,ax=ax,transform=transform_a,cmap=cmap_LC,norm=norm)
quadrats_a_gdf.plot(color='none',edgecolor='k',linewidth=1,ax=ax,linestyle='--')
plt.show()
```

<img src="./imgs/2_8_2/output_26_0.png" height='auto' width='auto' title="caDesign">
    


同样的方法操作样方组b。


```python
lu_b,transform_b=rio_read_subset(args.data.landuse_tif,[b_lb_pj,b_rt_pj])   
lu_b_parentClass=array_values_replacing(lu_b,label2parentClassID)

f, ax=plt.subplots(figsize=(20,20))
show(lu_b_parentClass,ax=ax,transform=transform_b,cmap=cmap_LC,norm=norm)
quadrats_b_gdf.plot(color='none',edgecolor='k',linewidth=1,ax=ax,linestyle='--')
plt.show()
```

<img src="./imgs/2_8_2/output_28_0.png" height='auto' width='auto' title="caDesign">
    

#### 2) 栅格采样

构建了样方组，已知土地利用栅格数据，将“不平等性和空间隔离”一章定义的`zonal_stats_raster()`区域统计函数置于`util_misc`模块调用，进行栅格采样（区域统计）。采样选取了`majority`方法，即以样方内栅格单元数最多的分类作为采样值。


```python
import util_misc

landcover_zonal_stats_a_gdf=util_misc.zonal_stats_raster(args.data.landuse_tif,quadrats_a_gdf,stats=['count','majority'])  
landcover_zonal_stats_a_gdf['majority']=landcover_zonal_stats_a_gdf.majority.astype(int)

landcover_zonal_stats_b_gdf=util_misc.zonal_stats_raster(args.data.landuse_tif,quadrats_b_gdf,stats=['count','majority'])  
landcover_zonal_stats_b_gdf['majority']=landcover_zonal_stats_b_gdf.majority.astype(int)
```

根据采样值，对位增加二级分类字段`name`。


```python
landcover_zonal_stats_a_gdf['name']=landcover_zonal_stats_a_gdf.majority.apply(lambda x:label2name[x])
landcover_zonal_stats_b_gdf['name']=landcover_zonal_stats_b_gdf.majority.apply(lambda x:label2name[x])
```

根据二级分类字段，对位增加一级分类字段`parent_name`。


```python
landcover_zonal_stats_a_gdf['parent_name']=landcover_zonal_stats_a_gdf.majority.apply(lambda x:label2parentClass[x])
landcover_zonal_stats_b_gdf['parent_name']=landcover_zonal_stats_b_gdf.majority.apply(lambda x:label2parentClass[x])
landcover_zonal_stats_b_gdf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>count</th>
      <th>majority</th>
      <th>index</th>
      <th>fre_55</th>
      <th>fre_0</th>
      <th>fre_18</th>
      <th>fre_4</th>
      <th>fre_41</th>
      <th>fre_46</th>
      <th>...</th>
      <th>fre_25</th>
      <th>fre_27</th>
      <th>fre_30</th>
      <th>fre_29</th>
      <th>fre_54</th>
      <th>fre_11</th>
      <th>fre_20</th>
      <th>fre_9</th>
      <th>name</th>
      <th>parent_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((406551.748 4622830.184, 406451.748 4...</td>
      <td>400</td>
      <td>55</td>
      <td>0</td>
      <td>206.0</td>
      <td>194.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((406551.748 4622930.184, 406451.748 4...</td>
      <td>400</td>
      <td>0</td>
      <td>0</td>
      <td>140.0</td>
      <td>196.0</td>
      <td>64.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((406551.748 4623030.184, 406451.748 4...</td>
      <td>400</td>
      <td>0</td>
      <td>0</td>
      <td>131.0</td>
      <td>197.0</td>
      <td>72.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((406551.748 4623130.184, 406451.748 4...</td>
      <td>400</td>
      <td>0</td>
      <td>0</td>
      <td>67.0</td>
      <td>304.0</td>
      <td>NaN</td>
      <td>29.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((406551.748 4623230.184, 406451.748 4...</td>
      <td>400</td>
      <td>41</td>
      <td>0</td>
      <td>2.0</td>
      <td>69.0</td>
      <td>NaN</td>
      <td>106.0</td>
      <td>223.0</td>
      <td>NaN</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>开放空间主要娱乐设施</td>
      <td>开放空间</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 44 columns</p>
</div>



#### 3) 构建复杂网络

由样方组（GeoDataFrame格式）构建复杂网络，通过`PySAL`库提供的`libpysal.weights`方法构建空间权重，并通过`to_networkx`方法直接转换为`NetWorkX`库的图类实现。为简化操作并增加样方组指定列为图顶点属性的功能，定义`G_from_gdf_spatialWeights()`函数。


```python
print(landcover_zonal_stats_a_gdf.parent_name.unique())
print(landcover_zonal_stats_b_gdf.parent_name.unique())
```

    ['交通_通讯_公共事业和垃圾处理' '非包裹区域' '住宅' '其它' '商业' '工业' '机构' '开放空间' '水体']
    ['非包裹区域' '住宅' '开放空间' '机构' '商业' '交通_通讯_公共事业和垃圾处理' '其它' '工业']
    


```python
def G_from_gdf_spatialWeights(gdf_,saptial_weight,columns):
    '''
    由GeoDataFrame（Polygon）格式数据，根据空间权重构建复杂网络

    Parameters
    ----------
    gdf_ : GeoDataFrame
        地理空间数据，几何对象为Polygon.
    saptial_weight : string
        空间权重类型，包括queen、rook和bishop.
    columns : list[string]
        转换为复杂网络顶点属性的列名.

    Returns
    -------
    G : TYPE
        DESCRIPTION.

    '''    
    import libpysal.weights as LW
    import numpy as np
    import networkx as nx
    
    gdf=gdf_.copy(deep=True)
    if saptial_weight=='queen':
        w=LW.contiguity.Queen.from_dataframe(gdf)
    elif saptial_weight=='rook':
        w=LW.contiguity.Rook.from_dataframe(gdf)
    elif saptial_weight=='bishop':
        w=LW.contiguity.Bishop.from_dataframe(gdf)        
    G=w.to_networkx()    
    gdf['centroid']=gdf.geometry.apply(lambda x:x.centroid)
    coordinates=np.column_stack((gdf.centroid.x, gdf.centroid.y))    
    pos=dict(zip(G.nodes, coordinates))
    nodes_attributes_dict={}
    nodes_attributes_dict['pos']=pos
    for col in columns:
        nodes_attributes_dict[col]=dict(zip(G.nodes,gdf[col]))
           
    nodes_attributes4G={node:{k:v[node] for k,v in nodes_attributes_dict.items()} for node in G.nodes}
    nx.set_node_attributes(G,nodes_attributes4G)
    
    return G
```


```python
G_a=G_from_gdf_spatialWeights(landcover_zonal_stats_a_gdf,'queen',columns=['majority','name','parent_name'])
```

定义的`G_drawing()`函数打印图中指定`nodes`参数可以根据指定的分组列表，给分组以不同的随机颜色。为获取图G指定顶点属性的顶点分组，定义`group_G_attribute()`函数。下述代码分别打印了两样方组的复杂网络，按二级分类赋色顶点。


```python
def group_G_attribute(G,attribute):
    '''
    给定图G，和顶点属性，根据顶点属性（通常为分类）分组

    Parameters
    ----------
    G : networkx.classes.graph.Graph
        图（复杂网络）.
    attribute : string
        顶点属性名.

    Returns
    -------
    group : dict
        以属性值为键，对应属性值的顶点编号为值的分组.

    '''    
    import networkx as nx
    
    from collections import defaultdict
    group=defaultdict(list)
    nodes_attribute_dict=nx.get_node_attributes(G_a,attribute)
    for key, val in sorted(nodes_attribute_dict.items()):
        group[val].append(key)    
        
    return group
```


```python
group_majority_a=group_G_attribute(G_a,'majority')
```


```python
import networkx as nx
util_misc.G_drawing(G_a,figsize=(20,20),pos=nx.get_node_attributes(G_a,'pos'),node_size=70,font_size=10,node_labels='majority',nodes=list(group_majority_a.values()))
```


<img src="./imgs/2_8_2/output_42_0.png" height='auto' width='auto' title="caDesign">   



```python
G_b=G_from_gdf_spatialWeights(landcover_zonal_stats_b_gdf,'queen',columns=['majority','name','parent_name'])
group_majority_b=group_G_attribute(G_b,'majority')
util_misc.G_drawing(G_b,figsize=(20,20),pos=nx.get_node_attributes(G_b,'pos'),node_size=70,font_size=10,node_labels='majority',nodes=list(group_majority_b.values()))
```

<img src="./imgs/2_8_2/output_43_0.png" height='auto' width='auto' title="caDesign">
    


使用`pickle`方法将图G存入本地。如果使用`NetWorkX`库提供的`GML`等格式，则需要将顶点属性`pos`为数组形式数值转换为字符串。


```python
import pickle 

with open("./data/G_a.gml",'wb') as f:
    pickle.dump(G_a,f)
with open("./data/G_b.gml",'wb') as f:
    pickle.dump(G_b,f)
```

定义`subG_from_attribute_val()`函数可以根据指定的一个到多个属性返回各个属性对应的子图。


```python
def subG_from_attribute_val(G,attribute,values):
    '''
    根据属性值，返回子图

    Parameters
    ----------
    G : networkx.classes.graph.Graph
        图（复杂网络）.
    attribute : string
        顶点属性.
    values : list[Any]
        对应顶点属性的值.

    Returns
    -------
    subG : networkx.classes.graph.Graph
        子图.
    subG_nodes_dict : dict
        属性值对应的顶点分组.

    '''    
    import networkx as nx
    
    flatten_lst=lambda lst: [m for n_lst in lst for m in flatten_lst(n_lst)] if type(lst) is list else [lst]    
    keys_from_value=lambda dict_object,value:list(filter(lambda x: dict_object[x] == value, dict_object))    
    
    subG_nodes_dict={}
    G_attribute=nx.get_node_attributes(G,attribute)
    subG_nodes_dict={v:keys_from_value(G_attribute,v) for v in values}      
    subG=nx.subgraph(G,flatten_lst(list(subG_nodes_dict.values())))
    return subG,subG_nodes_dict
```

提取一级分类的'开放空间'，'住宅'和'商业'3个类别，观察两个样方组这3个类别之间的分布关系。


```python
subG_a_open_spaceNresidential,subG_a_open_spaceNresidential_nodes=subG_from_attribute_val(G_a,'parent_name',['开放空间','住宅','商业'])
util_misc.G_drawing(subG_a_open_spaceNresidential,
                    pos=nx.get_node_attributes(subG_a_open_spaceNresidential,'pos'),
                    figsize=(9,9),
                    font_size=3,
                    nodes_size=[50,50,50],
                    node_size=2,
                    nodes=subG_a_open_spaceNresidential_nodes.values(),
                    nodes_color=['green','y','r'])
```

<img src="./imgs/2_8_2/output_49_0.png" height='auto' width='auto' title="caDesign">
    



```python
subG_b_open_spaceNresidential,subG_b_open_spaceNresidential_nodes=subG_from_attribute_val(G_b,'parent_name',['开放空间','住宅','商业'])
util_misc.G_drawing(subG_b_open_spaceNresidential,
                    pos=nx.get_node_attributes(subG_b_open_spaceNresidential,'pos'),
                    figsize=(9,9),
                    font_size=3,
                    nodes_size=[50,50,50],
                    node_size=2,
                    nodes=subG_b_open_spaceNresidential_nodes.values(),
                    nodes_color=['green','y','r'])
```

<img src="./imgs/2_8_2/output_50_0.png" height='auto' width='auto' title="caDesign">
    



### 2.8.2.2 图属性的基本度量

#### 1）Assortativity（同配性）

同配性描述为图中顶点连接（度）或具有相似属性顶点的连接趋势，为网络同质性（homophily）的一种度量（具有相似或相同属性顶点在图中连接密集的程度，值域为-1到1）。同配性高的网络同类属性（或度）趋于相互连接，因此诸如顶点丢失等破坏事件，对网络的影响较小，即网络较稳健（robust）。但是，因为同类的集中性，使得信息流方面的效率可能低下，多样化的交互和体验较弱<sup>[1]</sup>。下述自定义了一个简单网络图G，赋予顶点属性`color`为不同值，包括`red`、`blue`和`green`。使用`nx.attribute_assortativity_coefficient`<sup>[2]</sup>方法计算基于属性的同配系数，当边仅出现在同一属性值内部时，基于顶点属性的同配性为1，为边连接的同属性值的顶点相同；当增加边$\{2,7\}$后，顶点2和顶点7的`color`属性值不同，分别为`blue`和`green`，因此可以发现同配系数值降低为0.657；当继续增加具有不同属性值顶点之间的边连接时，例如增加边$\{1,3\}$后，同配系数降至为0.428。


```python
import networkx as nx

G=nx.Graph()
G.add_nodes_from([0, 1,4,5,6], color="red")
G.add_nodes_from([2, 3], color="blue")
G.add_nodes_from([7, 8], color="green")
G.add_edges_from([(0, 1), (2, 3),(0,4),(0,5),(5,6),]) 
_,subG_nodes=subG_from_attribute_val(G,'color',['red','blue','green'])
util_misc.G_drawing(G,nodes=subG_nodes.values())
print(nx.attribute_assortativity_coefficient(G, "color"))
```

<img src="./imgs/2_8_2/output_52_0.png" height='auto' width='auto' title="caDesign">
    

    


    1.0
    


```python
G.add_edges_from([(0, 1), (2, 3),(0,4),(0,5),(5,6),(2,7)]) 
_,subG_nodes=subG_from_attribute_val(G,'color',['red','blue','green'])
util_misc.G_drawing(G,nodes=subG_nodes.values())
print(nx.attribute_assortativity_coefficient(G, "color"))
```


<img src="./imgs/2_8_2/output_53_0.png" height='auto' width='auto' title="caDesign">    

    


    0.657142857142857
    


```python
G.add_edges_from([(0, 1), (2, 3),(0,4),(0,5),(5,6),(2,7),(1,3)]) 
_,subG_nodes=subG_from_attribute_val(G,'color',['red','blue','green'])
util_misc.G_drawing(G,nodes=subG_nodes.values())
print(nx.attribute_assortativity_coefficient(G, "color"))
```

<img src="./imgs/2_8_2/output_54_0.png" height='auto' width='auto' title="caDesign">
    

    


    0.4285714285714284
    

将基于属性的同配性用于土地利用的复杂网络两个样方组，且分别计算了一级分类和二级分类，通过计算结果得知位于市中心区域的组A同配性要低于位于郊区的组B，即组A不同类别顶点之间的连接丰富度高于组B，组A的信息流动性更强，具有更好的多样化交互和体验，与市中心的商业化职能相匹配；组B为住区，大面积的住区单元互相连接，仅部分住区顶点与其它类别顶点直接相连，网络稳健，但缺少多样化和信息流动性。


```python
import pickle 

with open("./data/G_a.gml",'rb') as f:
    G_a=pickle.load(f)
with open("./data/G_b.gml",'rb') as f:
    G_b=pickle.load(f)
```


```python
assortativity_a_name=nx.attribute_assortativity_coefficient(G_a,'name')
assortativity_a_pname=nx.attribute_assortativity_coefficient(G_a,'parent_name')
assortativity_b_name=nx.attribute_assortativity_coefficient(G_b,'name')
assortativity_b_pname=nx.attribute_assortativity_coefficient(G_b,'parent_name')

print(assortativity_a_name,assortativity_a_pname)
print(assortativity_b_name,assortativity_b_pname)
```

    0.28959391883614494 0.30695643502457387
    0.505307129324546 0.5258722154316439
    

计算各个分类与其它所有分类连接（边）的数量（counts）或者概率（probability）可以辅助判断城市功能布局的潜在合理性，例如用`nx.attribute_mixing_matrix`方法返回基于顶点属性连接的数量或概率矩阵，对`开放空间`列排序，可以发现`开放空间`连接概率从大到小的类别依次为`开放空间`（自身）、`非包裹区域`（道路）、`住宅`、`机构`、`商业`、`其它`、`交通_通讯_公共事业和垃圾处理	`、`工业`到`水体`，这样的连接概率是符合城市生活需求的一般规律，更多的居民更倾向于到附近的开放空间活动，而机构，包括大学教育设施、K_12教育设施 、政府行政和服务等同样对开放空间有需求；商业区域以购物广场、文化娱乐和主要零售服务等为主，往往相对集中，开放空间的配置相对较弱。比较组A和组B的计算结果，排除自身和道路，开放空间均与住宅具有更高的连接性，其次为机构。因为市中心和郊区的城市功能差异，市中心商业顶点要高于郊区，郊区的工业邻接开放空间的概率则高于商业。


```python
import pandas as pd
import numpy as np

G_unique_attribute=lambda G,attribute:{v:k for k,v in dict(list(enumerate(np.unique(list(nx.get_node_attributes(G,attribute).values()))))).items()}

G_a_parent_name_unique=G_unique_attribute(G_a,'parent_name')
print(G_a_parent_name_unique)
LU_joint_probability_Ga=pd.DataFrame(nx.attribute_mixing_matrix(G_a,'parent_name',mapping=G_a_parent_name_unique),columns=G_a_parent_name_unique.keys(),index=G_a_parent_name_unique.keys())
LU_joint_probability_Ga.sort_values(by=['开放空间'],ascending=False)
```

    {'交通_通讯_公共事业和垃圾处理': 0, '住宅': 1, '其它': 2, '商业': 3, '工业': 4, '开放空间': 5, '机构': 6, '水体': 7, '非包裹区域': 8}
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>交通_通讯_公共事业和垃圾处理</th>
      <th>住宅</th>
      <th>其它</th>
      <th>商业</th>
      <th>工业</th>
      <th>开放空间</th>
      <th>机构</th>
      <th>水体</th>
      <th>非包裹区域</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>开放空间</th>
      <td>0.000562</td>
      <td>0.004272</td>
      <td>0.000731</td>
      <td>0.000787</td>
      <td>0.000450</td>
      <td>0.004497</td>
      <td>0.002530</td>
      <td>0.000000</td>
      <td>0.004497</td>
    </tr>
    <tr>
      <th>非包裹区域</th>
      <td>0.022203</td>
      <td>0.068971</td>
      <td>0.006352</td>
      <td>0.027431</td>
      <td>0.022485</td>
      <td>0.004497</td>
      <td>0.023665</td>
      <td>0.000506</td>
      <td>0.098370</td>
    </tr>
    <tr>
      <th>住宅</th>
      <td>0.007870</td>
      <td>0.100731</td>
      <td>0.003710</td>
      <td>0.011692</td>
      <td>0.002979</td>
      <td>0.004272</td>
      <td>0.016807</td>
      <td>0.000281</td>
      <td>0.068971</td>
    </tr>
    <tr>
      <th>机构</th>
      <td>0.007476</td>
      <td>0.016807</td>
      <td>0.002867</td>
      <td>0.007813</td>
      <td>0.001518</td>
      <td>0.002530</td>
      <td>0.068353</td>
      <td>0.000281</td>
      <td>0.023665</td>
    </tr>
    <tr>
      <th>商业</th>
      <td>0.009500</td>
      <td>0.011692</td>
      <td>0.001349</td>
      <td>0.038673</td>
      <td>0.007251</td>
      <td>0.000787</td>
      <td>0.007813</td>
      <td>0.002811</td>
      <td>0.027431</td>
    </tr>
    <tr>
      <th>其它</th>
      <td>0.002192</td>
      <td>0.003710</td>
      <td>0.009556</td>
      <td>0.001349</td>
      <td>0.001911</td>
      <td>0.000731</td>
      <td>0.002867</td>
      <td>0.000393</td>
      <td>0.006352</td>
    </tr>
    <tr>
      <th>交通_通讯_公共事业和垃圾处理</th>
      <td>0.057111</td>
      <td>0.007870</td>
      <td>0.002192</td>
      <td>0.009500</td>
      <td>0.007645</td>
      <td>0.000562</td>
      <td>0.007476</td>
      <td>0.001237</td>
      <td>0.022203</td>
    </tr>
    <tr>
      <th>工业</th>
      <td>0.007645</td>
      <td>0.002979</td>
      <td>0.001911</td>
      <td>0.007251</td>
      <td>0.049354</td>
      <td>0.000450</td>
      <td>0.001518</td>
      <td>0.002754</td>
      <td>0.022485</td>
    </tr>
    <tr>
      <th>水体</th>
      <td>0.001237</td>
      <td>0.000281</td>
      <td>0.000393</td>
      <td>0.002811</td>
      <td>0.002754</td>
      <td>0.000000</td>
      <td>0.000281</td>
      <td>0.001799</td>
      <td>0.000506</td>
    </tr>
  </tbody>
</table>
</div>




```python
G_b_parent_name_unique=G_unique_attribute(G_b,'parent_name')
print(G_b_parent_name_unique)
LU_joint_probability_Gb=pd.DataFrame(nx.attribute_mixing_matrix(G_b,'parent_name',mapping=G_b_parent_name_unique),columns=G_b_parent_name_unique.keys(),index=G_b_parent_name_unique.keys())
LU_joint_probability_Gb.sort_values(by=['开放空间'],ascending=False)
```

    {'交通_通讯_公共事业和垃圾处理': 0, '住宅': 1, '其它': 2, '商业': 3, '工业': 4, '开放空间': 5, '机构': 6, '非包裹区域': 7}
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>交通_通讯_公共事业和垃圾处理</th>
      <th>住宅</th>
      <th>其它</th>
      <th>商业</th>
      <th>工业</th>
      <th>开放空间</th>
      <th>机构</th>
      <th>非包裹区域</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>开放空间</th>
      <td>0.001630</td>
      <td>0.037212</td>
      <td>0.000337</td>
      <td>0.002361</td>
      <td>0.002530</td>
      <td>0.071388</td>
      <td>0.002698</td>
      <td>0.002248</td>
    </tr>
    <tr>
      <th>住宅</th>
      <td>0.003991</td>
      <td>0.535132</td>
      <td>0.009725</td>
      <td>0.015514</td>
      <td>0.002305</td>
      <td>0.037212</td>
      <td>0.016695</td>
      <td>0.016695</td>
    </tr>
    <tr>
      <th>机构</th>
      <td>0.000562</td>
      <td>0.016695</td>
      <td>0.000899</td>
      <td>0.001855</td>
      <td>0.001518</td>
      <td>0.002698</td>
      <td>0.058123</td>
      <td>0.002698</td>
    </tr>
    <tr>
      <th>工业</th>
      <td>0.000562</td>
      <td>0.002305</td>
      <td>0.000000</td>
      <td>0.001743</td>
      <td>0.013041</td>
      <td>0.002530</td>
      <td>0.001518</td>
      <td>0.000562</td>
    </tr>
    <tr>
      <th>商业</th>
      <td>0.001124</td>
      <td>0.015514</td>
      <td>0.001967</td>
      <td>0.043620</td>
      <td>0.001743</td>
      <td>0.002361</td>
      <td>0.001855</td>
      <td>0.004666</td>
    </tr>
    <tr>
      <th>非包裹区域</th>
      <td>0.000450</td>
      <td>0.016695</td>
      <td>0.001349</td>
      <td>0.004666</td>
      <td>0.000562</td>
      <td>0.002248</td>
      <td>0.002698</td>
      <td>0.003598</td>
    </tr>
    <tr>
      <th>交通_通讯_公共事业和垃圾处理</th>
      <td>0.001124</td>
      <td>0.003991</td>
      <td>0.000000</td>
      <td>0.001124</td>
      <td>0.000562</td>
      <td>0.001630</td>
      <td>0.000562</td>
      <td>0.000450</td>
    </tr>
    <tr>
      <th>其它</th>
      <td>0.000000</td>
      <td>0.009725</td>
      <td>0.006183</td>
      <td>0.001967</td>
      <td>0.000000</td>
      <td>0.000337</td>
      <td>0.000899</td>
      <td>0.001349</td>
    </tr>
  </tbody>
</table>
</div>



`NetWorkX`库提供了`attribute_mixing_dict`方法可以返回各类（属性值）和其它类具体连接的数量或概率（由参数`normalized`确定返回类型）。


```python
nx.attribute_mixing_dict(G_a,'parent_name')
```




    {'交通_通讯_公共事业和垃圾处理': {'交通_通讯_公共事业和垃圾处理': 1016,
      '非包裹区域': 395,
      '住宅': 140,
      '其它': 39,
      '机构': 133,
      '工业': 136,
      '商业': 169,
      '开放空间': 10,
      '水体': 22},
     '非包裹区域': {'交通_通讯_公共事业和垃圾处理': 395,
      '非包裹区域': 1750,
      '其它': 113,
      '住宅': 1227,
      '商业': 488,
      '机构': 421,
      '工业': 400,
      '开放空间': 80,
      '水体': 9},
     '其它': {'非包裹区域': 113,
      '住宅': 66,
      '其它': 170,
      '交通_通讯_公共事业和垃圾处理': 39,
      '工业': 34,
      '机构': 51,
      '商业': 24,
      '开放空间': 13,
      '水体': 7},
     '住宅': {'非包裹区域': 1227,
      '住宅': 1792,
      '交通_通讯_公共事业和垃圾处理': 140,
      '商业': 208,
      '机构': 299,
      '开放空间': 76,
      '其它': 66,
      '工业': 53,
      '水体': 5},
     '商业': {'非包裹区域': 488,
      '商业': 688,
      '住宅': 208,
      '机构': 139,
      '开放空间': 14,
      '工业': 129,
      '交通_通讯_公共事业和垃圾处理': 169,
      '其它': 24,
      '水体': 50},
     '机构': {'住宅': 299,
      '机构': 1216,
      '非包裹区域': 421,
      '开放空间': 45,
      '商业': 139,
      '工业': 27,
      '交通_通讯_公共事业和垃圾处理': 133,
      '其它': 51,
      '水体': 5},
     '开放空间': {'机构': 45,
      '开放空间': 80,
      '非包裹区域': 80,
      '住宅': 76,
      '商业': 14,
      '交通_通讯_公共事业和垃圾处理': 10,
      '其它': 13,
      '工业': 8},
     '工业': {'非包裹区域': 400,
      '商业': 129,
      '机构': 27,
      '工业': 878,
      '住宅': 53,
      '交通_通讯_公共事业和垃圾处理': 136,
      '其它': 34,
      '开放空间': 8,
      '水体': 49},
     '水体': {'交通_通讯_公共事业和垃圾处理': 22,
      '商业': 50,
      '非包裹区域': 9,
      '水体': 32,
      '工业': 49,
      '其它': 7,
      '机构': 5,
      '住宅': 5}}



在同配性方面除了基于顶点属性的同配性外，还有基于顶点度的同配性计算，`NetWorkX`库均提供有相关方法。

#### 2）Connectivity and Components（连通性和分支）

连通性和分支可查看“复杂网络（图论）基础与NetworkX”一章连通性一节的数学定义。对连通性和分支相关度量的计算使用样方组B顶点属性为`parent_name`（土地利用一级分类），值为`开放空间`的子网络。


```python
subG_b_open_space,_=subG_from_attribute_val(G_b,'parent_name',['开放空间'])
util_misc.G_drawing(subG_b_open_space,
                    pos=nx.get_node_attributes(subG_b_open_space,'pos'),
                    figsize=(9,9),
                    font_size=6, 
                    node_size=2
                    )
```

<img src="./imgs/2_8_2/output_65_0.png" height='auto' width='auto' title="caDesign">
    

    


`is_connected`(G)：如果图是连通的返回True，否则返回False。

显然图`subG_b_open_space`由很多独立不连通的分支组成，因此为不连通的。


```python
print(nx.is_connected(subG_b_open_space))
```

    False
    

`number_connected_components`(G)：返回图连通分支的数量。

计算知图`subG_b_open_space`独立连通的开放空间数量有30个。


```python
print(nx.number_connected_components(subG_b_open_space))
```

    30
    

`connected_components`(G)：返回图所有连通分支的顶点集合。


```python
G=nx.path_graph(4)
nx.add_path(G, [10, 11, 12])
util_misc.G_drawing(G)
list(nx.connected_components(G))
```


<img src="./imgs/2_8_2/output_71_0.png" height='auto' width='auto' title="caDesign">    

    





    [{0, 1, 2, 3}, {10, 11, 12}]



返回样方组B所有独立的连通分支顶点集合并打印查看图。


```python
print(list(nx.connected_components(subG_a_open_space)))
print('-'*50)
connected_components_subG_b_open_space=list(nx.connected_components(subG_b_open_space))
print(connected_components_subG_b_open_space)
util_misc.G_drawing(subG_b_open_space,
                    pos=nx.get_node_attributes(subG_b_open_space,'pos'),
                    figsize=(9,9),
                    font_size=6, 
                    node_size=2,
                    nodes_size=[50]*len(connected_components_subG_b_open_space),
                    nodes=connected_components_subG_b_open_space
                    )
```

    [{2053}, {1086, 1142, 1198, 1030}, {1161, 1162, 1217, 1218}, {1035, 978, 979, 980, 922, 923}, {1245, 1133, 1189}, {1646, 1702}, {2015, 1959}, {1123, 1066, 1067, 1011}, {301}, {49, 50, 105}, {2232, 2287, 2288, 2231}, {965, 966}, {82}, {601}, {1898, 1899}, {237}, {501}, {2169}]
    --------------------------------------------------
    [{4, 5, 6, 61, 62}, {972, 1028, 973}, {2056, 2057, 2058, 2059, 2063, 2064, 1946, 1947, 1951, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2002, 2003, 2007, 2268, 2269, 2270, 2271, 2272, 2273, 1890, 2275, 1892, 2278, 1895, 2280, 2281, 2282, 2283, 2284, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175}, {1665, 1666, 1608, 1552, 1777, 1721, 1722}, {1445, 1613, 1614, 1389, 1557, 1558, 1333, 1277, 1501, 1502}, {256, 257, 258, 259, 139, 140, 141, 142, 143, 144, 145, 26, 27, 28, 29, 30, 31, 32, 195, 196, 197, 198, 199, 200, 201, 202, 204, 83, 84, 85, 86, 87, 88, 89, 252, 253, 254, 255}, {1007, 1005, 1062, 1006}, {1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1418, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 1306, 1307, 1309, 1310, 1699, 2088, 2089, 2090, 2091, 2092, 1197, 1198, 1584, 1585, 1586, 1587, 1977, 1978, 1979, 1980, 1981, 1473, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1362, 1755, 2146, 2147, 2148, 1252, 1253, 1254, 1641, 1642, 1643, 2033, 2034, 2035, 2036, 1529, 1917, 1918}, {1293, 1294, 1295, 1296, 1297, 1181, 1182, 1183, 1184, 1068, 1069, 1070, 1071, 1072, 1349, 1350, 1351, 1352, 1353, 1354, 1237, 1238, 1239, 1240, 1241, 1124, 1125, 1126, 1127, 1128, 1012, 1013, 1014, 1015, 1016}, {1534, 1478, 1590}, {91}, {805, 806, 749, 750, 751, 693, 694, 636, 637}, {137, 193}, {657, 713}, {2197, 2198}, {1798, 1799, 1800, 1742, 1743, 1744, 1686}, {168}, {172}, {1213}, {1215}, {736, 792}, {1760}, {239}, {2292}, {1303}, {856, 855, 799}, {293}, {894, 895}, {405}, {962}]
    

<img src="./imgs/2_8_2/output_73_1.png" height='auto' width='auto' title="caDesign">
    



`node_connected_component`(G, n)：返回包含顶点`n`的独立连通分支顶点集合。

提取样方组B一级分类开放空间下顶点值为1917所在的分支，即名为woodglenn park的公共开放空间。


```python
ncc_woodglenn_park=nx.node_connected_component(subG_b_open_space, 1917) # Woodglenn Park
print(ncc_woodglenn_park)
subG_woodglenn_park=nx.subgraph(subG_b_open_space,ncc_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                   )
```

    {1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1418, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 1306, 1307, 1309, 1310, 1699, 2088, 2089, 2090, 2091, 2092, 1197, 1198, 1584, 1585, 1586, 1587, 1977, 1978, 1979, 1980, 1981, 1473, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1362, 1755, 2146, 2147, 2148, 1252, 1253, 1254, 1641, 1642, 1643, 2033, 2034, 2035, 2036, 1529, 1917, 1918}
    

<img src="./imgs/2_8_2/output_75_1.png" height='auto' width='auto' title="caDesign">
    
    


`node_connectivity`(G, s=None, t=None)：计算有向图或无向图近似的顶点连通度。

`subG_woodglenn_park`子网络（分支）连通度为1，即只需要移除最少一个顶点就可以断开网络。


```python
print(approx.node_connectivity(subG_woodglenn_park))
```

    1
    

`k_edge_augmentation`(G, k, avail=None, weight=None, partial=False)：将图变为k-连通的，需要增加的边集。

通过配置参数`k`，实现k-连通，下述引用的`NetWorkX`库示例，通过配置`k`值为1、2和3的三种情况，返回实现k-连通的边集，`k`值越大，为连通度越高，则边集的大小通常也会增多。


```python
# Unweighted cases
G=nx.path_graph((1, 2, 3, 4))
G.add_node(5)
util_misc.G_drawing(G)
print(sorted(nx.k_edge_augmentation(G, k=1)))
print(sorted(nx.k_edge_augmentation(G, k=2)))
kea_3=nx.k_edge_augmentation(G, k=3)
print(sorted(kea_3))
G.add_edges_from(nx.k_edge_augmentation(G, k=3))
util_misc.G_drawing(G)
```

<img src="./imgs/2_8_2/output_79_0.png" height='auto' width='auto' title="caDesign">
    

    


    [(1, 5)]
    [(1, 5), (5, 4)]
    [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]
    


<img src="./imgs/2_8_2/output_79_2.png" height='auto' width='auto' title="caDesign">  

    


如果要将`subG_woodglenn_park`子网络的`k`由当前的1增加到2，需要增加边$\{1198,1917\}$。


```python
kea_2=list(nx.k_edge_augmentation(subG_woodglenn_park, k=2))
print(kea_2)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=kea_2
                   )
```

    [(1198, 1917)]
    


<img src="./imgs/2_8_2/output_81_1.png" height='auto' width='auto' title="caDesign">    

    


如果要将`subG_woodglenn_park`子网络的`k`由当前的1增加到2，需要增加边集的大小为8，其中顶点1917为构建边集连接最多的顶点。


```python
from itertools import tee
kea_3=nx.k_edge_augmentation(subG_woodglenn_park, k=3)
print(kea_3)
kea_3_a,kea_3_b,kea_3_c,kea_3_d=tee(kea_3,4)
print(list(kea_3_a))
subG_woodglenn_park_copy=subG_woodglenn_park.copy()
subG_woodglenn_park_copy.add_edges_from(kea_3_b)
util_misc.G_drawing(subG_woodglenn_park_copy,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(kea_3_c),
                    routes=list(kea_3_d)
                   )
```

    <generator object k_edge_augmentation at 0x000001FA8DE2B200>
    [(1418, 1917), (1927, 1917), (2088, 1917), (1473, 1917), (1306, 1918), (1310, 1917), (1198, 1917), (1584, 1917)]
    


<img src="./imgs/2_8_2/output_83_1.png" height='auto' width='auto' title="caDesign">   



`is_k_edge_connected`(G, k)：判断图是否为k-连通的。


```python
nx.is_k_edge_connected(subG_woodglenn_park_copy, 3)
```




    True



`is_locally_k_edge_connected`(G, s, t, k)：判断图中两顶点之间是否为k-连通的。


```python
from networkx.algorithms.connectivity import is_locally_k_edge_connected
is_locally_k_edge_connected(subG_woodglenn_park_copy, 1755, 1198, k=3)
```




    True



`k_edge_components`(G, k)<sup>[3, 4]</sup>：生成图每一最大k-连通分支的顶点集合。

`k_edge_subgraphs`(G, k)<sup>[5]</sup>：生成图每一最大k-连通子图的顶点集合。


```python
import itertools as it
from networkx.utils import pairwise
paths=[
    (1, 2, 4, 3, 1, 4),
    (5, 6, 7, 8, 5, 7, 8, 6),
    ]
G=nx.Graph()
G.add_nodes_from(it.chain(*paths))
G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))
util_misc.G_drawing(G,node_size=9)
# note this returns {1, 4} unlike k_edge_subgraphs
print(sorted(map(sorted, nx.k_edge_components(G, k=3))))
print(sorted(map(sorted, nx.k_edge_subgraphs(G, k=3))))
```


<img src="./imgs/2_8_2/output_89_0.png" height='auto' width='auto' title="caDesign">    

    


    [[1, 4], [2], [3], [5, 6, 7, 8]]
    [[1], [2], [3], [4], [5, 6, 7, 8]]
    

计算`subG_woodglenn_park`图`k`为2和3时k-连通子图的顶点集合。可以发现，当`k`为2时，分支顶点集$\{1306,1307,1362\}$满足要求，而`k`为3时，则不再满足要求，打散为独立的顶点集。


```python
kec_subG_woodglenn_park=sorted(nx.k_edge_components(subG_woodglenn_park,k=2))
print(kec_subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=kec_subG_woodglenn_park,
                   )
```

    [{1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2088, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}, {1418}, {1306, 1307, 1362}, {1252, 1253, 1254, 1197, 1198, 1309, 1310}, {1699, 1641, 1642, 1643, 1584, 1585, 1586, 1587, 1529}, {1473}, {1917}, {1918}]
    


<img src="./imgs/2_8_2/output_91_1.png" height='auto' width='auto' title="caDesign"><img src="./imgs/2_8_2/" height='auto' width='auto' title="caDesign">    

    



```python
kec_subG_woodglenn_park=sorted(nx.k_edge_components(subG_woodglenn_park,k=3))
print(kec_subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=kec_subG_woodglenn_park,
                   )
```

    [{1920, 1921, 1922, 1923, 1924, 1925, 1926, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}, {1927}, {1418}, {1699}, {2088}, {1917}, {1918}, {1473}, {1641, 1642, 1643, 1584, 1585, 1586, 1587, 1529}, {1252, 1253, 1254, 1197, 1198, 1309, 1310}, {1306}, {1362}, {1307}]
    


<img src="./imgs/2_8_2/output_92_1.png" height='auto' width='auto' title="caDesign">    

    


`k_edge_subgraphs`方法类似`k_edge_components`方法，比较`k`为3时返回的顶点集，保持一致。


```python
kes_subG_woodglenn_park=sorted(nx.k_edge_subgraphs(subG_woodglenn_park,k=3))
print(kes_subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=kes_subG_woodglenn_park,
                   )
```

    [{1362}, {1927}, {1917}, {1920, 1921, 1922, 1923, 1924, 1925, 1926, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}, {1307}, {1641, 1642, 1643, 1584, 1585, 1586, 1587, 1529}, {1699}, {2088}, {1306}, {1418}, {1473}, {1918}, {1252, 1253, 1254, 1197, 1198, 1309, 1310}]
    

<img src="./imgs/2_8_2/output_94_1.png" height='auto' width='auto' title="caDesign">   

    


`bridge_components`(G)：找到图G所有桥结/连通（bridge-connected）分支。




```python
G = nx.barbell_graph(5, 0)
util_misc.G_drawing(G)
from networkx.algorithms.connectivity.edge_kcomponents import bridge_components
sorted(map(sorted, bridge_components(G)))
```


<img src="./imgs/2_8_2/output_96_0.png" height='auto' width='auto' title="caDesign">   

    





    [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]



对于`subG_woodglenn_par`图，断开桥（一条边）后顶点数大于2的分支有4个。使用`bridges`(G, root=None)方法则可以直接找到桥集合，对于该图含有7个桥。


```python
bridge_subG_woodglenn_park=sorted(bridge_components(subG_woodglenn_park))
print(bridge_subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=bridge_subG_woodglenn_park,
                   )
```

    [{1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2088, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}, {1418}, {1306, 1307, 1362}, {1252, 1253, 1254, 1197, 1198, 1309, 1310}, {1699, 1641, 1642, 1643, 1584, 1585, 1586, 1587, 1529}, {1473}, {1917}, {1918}]
    


<img src="./imgs/2_8_2/output_98_1.png" height='auto' width='auto' title="caDesign">    




```python
list(nx.bridges(subG_woodglenn_park))
```




    [(1418, 1362),
     (1418, 1473),
     (1307, 1252),
     (1699, 1755),
     (1473, 1529),
     (1863, 1918),
     (1917, 1918)]



`EdgeComponentAuxGraph`类<sup>[4]</sup>：一个在图中查找所有k-连通分支的简单算法。


```python
import itertools as it
from networkx.utils import pairwise
from networkx.algorithms.connectivity import EdgeComponentAuxGraph
# Build an interesting graph with multiple levels of k-edge-ccs
paths=[
    (1, 2, 3, 4, 1, 3, 4, 2),  # a 3-edge-cc (a 4 clique)
    (5, 6, 7, 5),  # a 2-edge-cc (a 3 clique)
    (1, 5),  # combine first two ccs into a 1-edge-cc
    (0,),  # add an additional disconnected 1-edge-cc
]
G=nx.Graph()
G.add_nodes_from(it.chain(*paths))
G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))
util_misc.G_drawing(G)
# Constructing the AuxGraph takes about O(n ** 4)
aux_graph=EdgeComponentAuxGraph.construct(G)
# Once constructed, querying takes O(n)
print(sorted(map(sorted, aux_graph.k_edge_components(k=1))))
print(sorted(map(sorted, aux_graph.k_edge_components(k=2))))
print(sorted(map(sorted, aux_graph.k_edge_components(k=3))))
print(sorted(map(sorted, aux_graph.k_edge_components(k=4))))
```


<img src="./imgs/2_8_2/output_101_0.png" height='auto' width='auto' title="caDesign">   

    


    [[0], [1, 2, 3, 4, 5, 6, 7]]
    [[0], [1, 2, 3, 4], [5, 6, 7]]
    [[0], [1, 2, 3, 4], [5], [6], [7]]
    [[0], [1], [2], [3], [4], [5], [6], [7]]
    

用`EdgeComponentAuxGraph.construct`方法构建`subG_woodglenn_par`图的实例化对象，调用`k_edge_components`方法查找不同`k`值的分支。


```python
aux_graph_subG_woodglenn_park=EdgeComponentAuxGraph.construct(subG_woodglenn_park)
print(sorted(map(sorted, aux_graph_subG_woodglenn_park.k_edge_components(k=1))))
print(sorted(map(sorted, aux_graph_subG_woodglenn_park.k_edge_components(k=2))))
print(sorted(map(sorted, aux_graph_subG_woodglenn_park.k_edge_components(k=3))))
print(sorted(map(sorted, aux_graph_subG_woodglenn_park.k_edge_components(k=4))))
```

    [[1197, 1198, 1252, 1253, 1254, 1306, 1307, 1309, 1310, 1362, 1418, 1473, 1529, 1584, 1585, 1586, 1587, 1641, 1642, 1643, 1699, 1755, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1917, 1918, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1977, 1978, 1979, 1980, 1981, 2033, 2034, 2035, 2036, 2088, 2089, 2090, 2091, 2092, 2146, 2147, 2148, 2202, 2203, 2204, 2258, 2259, 2260]]
    [[1197, 1198, 1252, 1253, 1254, 1309, 1310], [1306, 1307, 1362], [1418], [1473], [1529, 1584, 1585, 1586, 1587, 1641, 1642, 1643, 1699], [1755, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1977, 1978, 1979, 1980, 1981, 2033, 2034, 2035, 2036, 2088, 2089, 2090, 2091, 2092, 2146, 2147, 2148, 2202, 2203, 2204, 2258, 2259, 2260], [1917], [1918]]
    [[1197, 1198, 1252, 1253, 1254, 1309, 1310], [1306], [1307], [1362], [1418], [1473], [1529, 1584, 1585, 1586, 1587, 1641, 1642, 1643], [1699], [1755, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1977, 1978, 1979, 1980, 1981, 2033, 2034, 2035, 2036, 2089, 2090, 2091, 2092, 2146, 2147, 2148, 2202, 2203, 2204, 2258, 2259, 2260], [1917], [1918], [1927], [2088]]
    [[1197, 1253, 1254, 1309], [1198], [1252], [1306], [1307], [1310], [1362], [1418], [1473], [1529], [1584], [1585, 1586, 1641, 1642, 1643], [1587], [1699], [1755], [1807], [1808, 1809, 1810, 1811, 1812, 1813, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1977, 1978, 1979, 1980, 1981, 2033, 2034, 2035, 2036, 2089, 2090, 2091, 2092, 2146, 2147, 2148, 2202, 2203, 2204, 2259], [1814], [1917], [1918], [1927], [2088], [2258], [2260]]
    

打印4-连通分支结果。当`k`不断增加，被逐次移除的顶点次序，也反映了被移除的顶点连通度大小。


```python
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(aux_graph_subG_woodglenn_park.k_edge_components(k=4)),
                   )
```


<img src="./imgs/2_8_2/output_105_0.png" height='auto' width='auto' title="caDesign">    



`k_components`(G, flow_func=None)<sup>[6, 7, 8]</sup>：返回图G的k-分支结构。k-分支是图G的最大子图，至少为k-连通的，需要至少删除`k`个顶点将其分解为更多分支。k-分支因为在连通性方面是嵌套的，因此具有内在的层次结构：例如一个连通图可以包含多个2-分支，每个2-分支可以再包含一个或多个3-分支等。


```python
# Petersen graph has 10 nodes and it is triconnected, thus all
# nodes are in a single component on all three connectivity levels
G = nx.petersen_graph()
util_misc.G_drawing(G)
k_components = nx.k_components(G)
k_components
```

<img src="./imgs/2_8_2/output_107_0.png" height='auto' width='auto' title="caDesign">
    

    





    {3: [{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}],
     2: [{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}],
     1: [{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}]}



因为样方组A和B为`Queen`空间权重的复杂网络，处于中间的顶点度为8，处于边缘的顶点度通常为5，处于角点的顶点度则为3，因此当用`k_components`计算`subG_woodglenn_par`图，`k`最大迭代到4停止。


```python
kc_subG_wp=nx.k_components(subG_woodglenn_park)
print(kc_subG_wp)
```

    {4: [{1920, 1921, 1922, 1923, 1924, 1925, 1926, 1809, 1810, 1811, 1812, 1813, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2146, 2147, 2033, 2034, 2035, 2036}], 3: [{1252, 1253, 1254, 1309, 1197, 1198, 1310}, {1584, 1585, 1586, 1641, 1642, 1529}, {1643, 1642, 1587, 1586}, {1920, 1921, 1922, 1923, 1924, 1925, 1926, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}], 2: [{1252, 1253, 1254, 1309, 1197, 1198, 1310}, {1306, 1307, 1362}, {1699, 1641, 1642, 1643, 1584, 1585, 1586, 1587, 1529}, {1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 2202, 2203, 2204, 2088, 2089, 2090, 2091, 2092, 1977, 1978, 1979, 1980, 1981, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 2258, 2259, 2260, 1755, 2146, 2147, 2148, 2033, 2034, 2035, 2036}], 1: [{1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1306, 1307, 1309, 1310, 2088, 2089, 2090, 2091, 2092, 1584, 1585, 1586, 1587, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1362, 2146, 2147, 2148, 1641, 1642, 1643, 1917, 1918, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1418, 2202, 2203, 2204, 1699, 1197, 1198, 1977, 1978, 1979, 1980, 1981, 1473, 2258, 2259, 2260, 1755, 1252, 1253, 1254, 2033, 2034, 2035, 2036, 1529}]}
    


```python
for k,v in kc_subG_wp.items():
    util_misc.G_drawing(subG_woodglenn_park,
                        pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                        figsize=(10,5),
                        font_size=9, 
                        nodes=list(v),
                        title=f"k={k}",
                       )
```


<img src="./imgs/2_8_2/output_110_0.png" height='auto' width='auto' title="caDesign">    

    


<img src="./imgs/2_8_2/output_110_1.png" height='auto' width='auto' title="caDesign">
    

    


<img src="./imgs/2_8_2/output_110_2.png" height='auto' width='auto' title="caDesign">
    

    


<img src="./imgs/2_8_2/output_110_3.png" height='auto' width='auto' title="caDesign">
    



`all_node_cuts`(G, k=None, flow_func=None)<sup>[7]</sup>：返回无向图G所有最小k割集，即基数顶点的集合等于图G的顶点连通度。


```python
# A two-dimensional grid graph has 4 cutsets of cardinality 2
G = nx.grid_2d_graph(5, 5)
util_misc.G_drawing(G,figsize=(5,5))
cutsets = list(nx.all_node_cuts(G))
print(cutsets)
print(all(2 == len(cutset) for cutset in cutsets))
nx.node_connectivity(G)
```


<img src="./imgs/2_8_2/output_112_0.png" height='auto' width='auto' title="caDesign">    

    


    [{(4, 1), (3, 0)}, {(0, 3), (1, 4)}, {(3, 4), (4, 3)}, {(0, 1), (1, 0)}]
    True
    




    2




```python
cutsets_subG_wp = list(nx.all_node_cuts(subG_woodglenn_park))
print(cutsets_subG_wp)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=cutsets_subG_wp,
                   )
```

    [{1755}, {1699}, {1529}, {1473}, {1418}, {1362}, {1307}, {1252}, {1863}, {1918}]
    

<img src="./imgs/2_8_2/output_113_1.png" height='auto' width='auto' title="caDesign">
    
    


`edge_disjoint_paths`(G, s, t, flow_func=None, cutoff=None, auxiliary=None, residual=None)：返回两点间边不相交的路。边不相交的路是不共享任何边的路。路的数量即为边连通度。

`node_disjoint_paths`(G, s, t, flow_func=None, cutoff=None, auxiliary=None, residual=None)：返回两点间顶点不相交的路。顶点不相交路是仅共享给定两个顶点的路。两个顶点之间顶点独立路的数量即为本地顶点连通度。


```python
from networkx.algorithms import approximation as approx
from networkx.algorithms.connectivity.connectivity import local_edge_connectivity

G=nx.icosahedral_graph()
G_edp=list(nx.edge_disjoint_paths(G, 0, 6))
print(G_edp)
print(local_edge_connectivity(G, 0, 6)) # 计算本地边连通度
print(list(nx.node_disjoint_paths(G, 0, 6))) 
print(approx.local_node_connectivity(G,0,6)) # 计算本地顶点连通度
util_misc.G_drawing(G,routes=G_edp)
```

    [[0, 1, 6], [0, 5, 6], [0, 7, 9, 3, 6], [0, 8, 2, 6], [0, 11, 4, 6]]
    5
    [[0, 1, 6], [0, 5, 6], [0, 7, 9, 3, 6], [0, 8, 2, 6], [0, 11, 4, 6]]
    5
    


<img src="./imgs/2_8_2/output_115_1.png" height='auto' width='auto' title="caDesign">   

    



```python
edp_subG_wp = list(nx.edge_disjoint_paths(subG_woodglenn_park,1814,2088))
print(edp_subG_wp)
print(len(edp_subG_wp))
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    routes=edp_subG_wp,
                   )
```

    [[1814, 1813, 1868, 1923, 1978, 2033, 2088], [1814, 1869, 1924, 1979, 2034, 2089, 2088]]
    2
    


<img src="./imgs/2_8_2/output_116_1.png" height='auto' width='auto' title="caDesign">   

    



```python
ndp_subG_wp = list(nx.node_disjoint_paths(subG_woodglenn_park,1814,2088))
print(ndp_subG_wp)
print(len(ndp_subG_wp))
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=ndp_subG_wp,
                   )
```

    [[1814, 1813, 1868, 1923, 1978, 2033, 2088], [1814, 1869, 1924, 1979, 2034, 2089, 2088]]
    2
    


<img src="./imgs/2_8_2/output_117_1.png" height='auto' width='auto' title="caDesign">    

    


`average_node_connectivity`(G, flow_func=None)<sup>[9]</sup>：返回图G的平均连通度，为所有顶点对上局部顶点连通度的均值。

下述计算了样方组B各个连通分支的平均连通度，并将计算结果以顶点属性方式存储并打印显示。


```python
connected_components_subG_b_open_space=list(nx.connected_components(subG_b_open_space))
connected_components_subG_b_open_space_dict=dict(zip(range(len(connected_components_subG_b_open_space)),connected_components_subG_b_open_space))
subG_b_cc={k:subG_b_open_space.subgraph(v) for k,v in connected_components_subG_b_open_space_dict.items()}
subG_b_cc_anc={k:nx.average_node_connectivity(g) for k,g in subG_b_cc.items()}
print(subG_b_cc_anc)
```

    {0: 2.7, 1: 2.0, 2: 1.9508196721311475, 3: 1.8095238095238095, 4: 1.7777777777777777, 5: 3.9900426742532007, 6: 2.1666666666666665, 7: 2.348893360160966, 8: 3.976470588235294, 9: 1.0, 10: 0, 11: 2.8055555555555554, 12: 1.0, 13: 1.0, 14: 1.0, 15: 2.6666666666666665, 16: 0, 17: 0, 18: 0, 19: 0, 20: 1.0, 21: 0, 22: 0, 23: 0, 24: 0, 25: 2.0, 26: 0, 27: 1.0, 28: 0, 29: 0}
    


```python
from collections import ChainMap
cc_node2idx=ChainMap(*[{i:k for i in v} for k,v in connected_components_subG_b_open_space_dict.items()])
nx.set_node_attributes(subG_b_open_space, cc_node2idx, name="cc_idx")
```


```python
cc_node2cc={k:round(subG_b_cc_anc[v],2) for k,v in cc_node2idx.items()}
nx.set_node_attributes(subG_b_open_space, cc_node2cc, name="cc")
```


```python
subG_b_open_space.nodes[4]
```




    {'pos': array([ 406501.74751261, 4623280.18400216]),
     'majority': 41,
     'name': '开放空间主要娱乐设施',
     'parent_name': '开放空间',
     'cc_idx': 0,
     'cc': 2.7}




```python
util_misc.G_drawing(subG_b_open_space,
                    pos=nx.get_node_attributes(subG_b_open_space,'pos'),
                    figsize=(15,15),
                    font_size=2, 
                    node_size=2,
                    nodes_size=[50]*len(connected_components_subG_b_open_space),
                    nodes=connected_components_subG_b_open_space,
                    node_labels='cc'
                    )
```


<img src="./imgs/2_8_2/output_123_0.png" height='auto' width='auto' title="caDesign">    



#### 3）Clique（团）

团（Clique）是无向图中顶点的子集，满足每两个不同的顶点都是相邻的，其子图为完全图<sup>[10]</sup>。

`enumerate_all_cliques`(G)<sup[11]></sup>：返回无向图中的所有团。
    
`number_of_cliques`(G, nodes=None, cliques=None)：返回每个顶点的最大团数。
    
`graph_clique_number`(G, cliques=None)：返回图的团数。图的团数是图中最大团的大小。
    
`cliques_containing_node`(G, nodes=None, cliques=None)：返回包含给定顶点所属团的列表。


```python
G=nx.lollipop_graph(3, 2)
G.add_edges_from([(6,7),(5,7),(7,8),(5,6)])
G.add_node("a")
util_misc.G_drawing(G,node_size=5)
print(list(nx.enumerate_all_cliques(G)))
print(nx.number_of_cliques(G))
print(nx.graph_clique_number(G))
print(list(nx.cliques_containing_node(G,0)))
```


<img src="./imgs/2_8_2/output_125_0.png" height='auto' width='auto' title="caDesign">    

    


    [[0], [1], [2], [3], [4], [6], [7], [5], [8], ['a'], [0, 1], [0, 2], [1, 2], [2, 3], [3, 4], [6, 7], [6, 5], [7, 5], [7, 8], [0, 1, 2], [6, 7, 5]]
    {0: 1, 1: 1, 2: 2, 3: 2, 4: 1, 6: 1, 7: 2, 5: 1, 8: 1, 'a': 1}
    3
    [[2, 0, 1]]
    

将上述关于团的所有度量均用于`subG_woodglenn_park`图再次计算。


```python
print(sum([len(i)>2 for i in list(nx.enumerate_all_cliques(subG_woodglenn_park))]))
print(nx.graph_clique_number(subG_woodglenn_park))
print('-'*50)
print(nx.number_of_cliques(subG_woodglenn_park))
```

    181
    4
    --------------------------------------------------
    {1920: 3, 1921: 4, 1922: 4, 1923: 4, 1924: 4, 1925: 4, 1926: 3, 1927: 1, 1418: 2, 1807: 1, 1808: 2, 1809: 2, 1810: 3, 1811: 4, 1812: 3, 1813: 2, 1814: 1, 2202: 2, 2203: 4, 2204: 2, 1306: 1, 1307: 2, 1309: 2, 1310: 1, 1699: 2, 2088: 1, 2089: 3, 2090: 4, 2091: 4, 2092: 2, 1197: 2, 1198: 1, 1584: 2, 1585: 4, 1586: 3, 1587: 1, 1977: 3, 1978: 4, 1979: 4, 1980: 4, 1981: 3, 1473: 2, 1863: 3, 1864: 4, 1865: 4, 1866: 4, 1867: 4, 1868: 4, 1869: 4, 1870: 3, 2258: 1, 2259: 2, 2260: 1, 1362: 2, 1755: 3, 2146: 3, 2147: 4, 2148: 2, 1252: 3, 1253: 4, 1254: 2, 1641: 2, 1642: 3, 1643: 2, 2033: 3, 2034: 4, 2035: 4, 2036: 3, 1529: 3, 1917: 1, 1918: 2}
    


```python
ccn_subG_wp=list(nx.cliques_containing_node(subG_woodglenn_park,1921))
print(ccn_subG_wp)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park_copy,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=ccn_subG_wp,
                   )
```

    [[1864, 1920, 1865, 1921], [1865, 1921, 1922, 1866], [1920, 1921, 1977], [1921, 1922, 1978, 1977]]
    


<img src="./imgs/2_8_2/output_128_1.png" height='auto' width='auto' title="caDesign">    

    


#### 4）Clustering（聚类）

`triangles`(G, nodes=None)：计算图中各个顶点含三角形的数量。

`transitivity`(G)：传递性（transitivity）描述相邻顶点相互连接的概率，为三角形（triangle）占三元（triads，为共享顶点的两个边）的比例。


```python
G = nx.complete_graph(5)
util_misc.G_drawing(G)
print(nx.triangles(G, 0))
print(nx.triangles(G))
print(nx.triangles(G, (0, 1)))
print(nx.transitivity(G))
```


<img src="./imgs/2_8_2/output_130_0.png" height='auto' width='auto' title="caDesign">    

    


    6
    {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}
    {0: 6, 1: 6}
    1.0
    


```python
print(sorted(nx.triangles(subG_woodglenn_park).items(),key=lambda x:x[1]))
```

    [(1418, 0), (1473, 0), (1917, 0), (1918, 0), (1927, 1), (1306, 1), (1307, 1), (1699, 1), (2088, 1), (1362, 1), (1584, 2), (1755, 2), (1252, 2), (1529, 2), (1807, 3), (1814, 3), (1310, 3), (1198, 3), (1587, 3), (2258, 3), (2260, 3), (1309, 4), (1197, 4), (1863, 4), (1641, 4), (1643, 4), (1920, 5), (1926, 5), (2089, 5), (1981, 5), (1808, 6), (1809, 6), (1813, 6), (2202, 6), (2204, 6), (2092, 6), (1585, 6), (2259, 6), (2148, 6), (1254, 6), (1810, 7), (1812, 7), (1586, 7), (1977, 7), (1870, 7), (2146, 7), (1642, 7), (2033, 7), (2036, 7), (1811, 8), (1253, 8), (1921, 10), (1925, 10), (2090, 10), (1980, 10), (1864, 10), (1922, 12), (1923, 12), (1924, 12), (2203, 12), (2091, 12), (1978, 12), (1979, 12), (1865, 12), (1866, 12), (1867, 12), (1868, 12), (1869, 12), (2147, 12), (2034, 12), (2035, 12)]
    

应用于`subG_woodglenn_park`图重复上述计算，可知woodglenn park开放空间区域的传递性为0.482。


```python
print(nx.triangles(subG_woodglenn_park, 1863))
print(sorted(nx.triangles(subG_woodglenn_park).items(),key=lambda x:x[1]))
print(nx.triangles(subG_woodglenn_park, (1863, 1584)))
print(nx.transitivity(subG_woodglenn_park))
```

    4
    [(1418, 0), (1473, 0), (1917, 0), (1918, 0), (1927, 1), (1306, 1), (1307, 1), (1699, 1), (2088, 1), (1362, 1), (1584, 2), (1755, 2), (1252, 2), (1529, 2), (1807, 3), (1814, 3), (1310, 3), (1198, 3), (1587, 3), (2258, 3), (2260, 3), (1309, 4), (1197, 4), (1863, 4), (1641, 4), (1643, 4), (1920, 5), (1926, 5), (2089, 5), (1981, 5), (1808, 6), (1809, 6), (1813, 6), (2202, 6), (2204, 6), (2092, 6), (1585, 6), (2259, 6), (2148, 6), (1254, 6), (1810, 7), (1812, 7), (1586, 7), (1977, 7), (1870, 7), (2146, 7), (1642, 7), (2033, 7), (2036, 7), (1811, 8), (1253, 8), (1921, 10), (1925, 10), (2090, 10), (1980, 10), (1864, 10), (1922, 12), (1923, 12), (1924, 12), (2203, 12), (2091, 12), (1978, 12), (1979, 12), (1865, 12), (1866, 12), (1867, 12), (1868, 12), (1869, 12), (2147, 12), (2034, 12), (2035, 12)]
    {1863: 4, 1584: 2}
    0.4820846905537459
    

聚类系数（Clustering coefficients），是图中顶点倾向于聚类在一起程度的度量。一个顶点的局部聚类系数量化了它的邻点离成为团（clique）有多近，即顶点的一跳邻域内封闭的三角形的比例，或者为邻点之间实际实现的连接（triangle）与有可能连接（triads）数量的比例。例如，对于图G1、G2和G3，分析顶点`A`的聚类系数，计算用`networkx.algorithms.cluster`模块提供的`clustering`方法：

1. 邻点之间实际实现的连接与所有可能连接数量的比例：节点`A`的邻点为（`P1`,`P2`,`P3`），`P1`,`P2`,`P3`之间最多可以有3个连接，对于图G1包含全部3个连接，对于图G2含1个连接，对于图G3不含连接，因此聚类系数分别为3/3=1、1/3=0.333和0/3=0；
2. 邻点内封闭的三角形比例：顶点`A`的邻点为（`P1`,`P2`,`P3`），与顶点`A`最多形成3个三角形，$ \bigtriangleup AP1P2 $，$ \bigtriangleup AP1P3 $和$ \bigtriangleup AP2P3$，对于图G1、G2和G3符合条件的三角形数量分别为3，1和0，因此聚类系数分别为3/3=1、1/3=0.333和0/3=0。

`average_clustering`(G[, trials, seed])<sup>[12, 13]</sup>：估计图G的平均聚类系数，为局部聚类的平均值。


```python
from networkx.algorithms.cluster import clustering
from networkx.algorithms import approximation

G1=nx.Graph()
G1.add_edges_from([("P1","P2"),("P1","P3"),("P2","P3"),("A","P1"),("A","P2"),("A","P3")])
G_drawing(G1)
print(clustering(G1,"A"))
print(approximation.average_clustering(G1, trials=1000, seed=10) )
```


<img src="./imgs/2_8_2/output_135_0.png" height='auto' width='auto' title="caDesign">    

    


    1.0
    1.0
    


```python
G2=nx.Graph()
G2.add_edges_from([("P2","P3"),("A","P1"),("A","P2"),("A","P3")])
G_drawing(G2)
print(clustering(G2,"A"))
print(approximation.average_clustering(G2, trials=1000, seed=10))
```


<img src="./imgs/2_8_2/output_136_0.png" height='auto' width='auto' title="caDesign">    

    


    0.3333333333333333
    




    0.579




```python
G3=nx.Graph()
G3.add_edges_from([("A","P1"),("A","P2"),("A","P3")])
G_drawing(G3)
print(clustering(G3,"A"))
print(approximation.average_clustering(G3, trials=1000, seed=10))   
```


<img src="./imgs/2_8_2/output_137_0.png" height='auto' width='auto' title="caDesign">   

    


    0
    0.0
    

计算样方组B所有开放空间连通分支的平均聚类系数。为了方便计算一个图的所有子图类的度量，定义`subGs_metric()`函数，输入图、子图顶点字典（索引值为键，顶点列表为值）和`NetWorkX`库提供的方法作为参数进行计算。


```python
def subGs_metric(G,nodes_group,metric_func):
    '''
    指定度量方法，计算图各个导出子图的值

    Parameters
    ----------
    G : networkx.classes.graph.Graph
        图G.
    nodes_group : dict
        键为索引，值为图的顶点列表.
    metric_func : function
        可调用的NetWorkX库提供的函数.

    Returns
    -------
    metrics : dict
        键位索引，值为由metric_func度量函数计算的结果值.

    '''    
    import networkx as nx
    
    idxes,nodes_nested=nodes_group.keys(),nodes_group.values()
    subGs=[nx.subgraph(G,nodes) for nodes in nodes_nested]
    metric_results=map(metric_func,subGs)
    metrics=dict(zip(idxes,metric_results))
    
    return metrics
```

打印样方组B所有开放空间连通分支的索引值，用于度量值检索空间分布位置。


```python
util_misc.G_drawing(subG_b_open_space,
                    pos=nx.get_node_attributes(subG_b_open_space,'pos'),
                    figsize=(7,7),
                    font_size=2, 
                    node_size=2,
                    nodes_size=[50]*len(connected_components_subG_b_open_space),
                    nodes=connected_components_subG_b_open_space,
                    node_labels='cc_idx'
                    )
```


<img src="./imgs/2_8_2/output_141_0.png" height='auto' width='auto' title="caDesign">    

    



```python
cc_subG_b_open_space=list(nx.connected_components(subG_b_open_space))
cc_subG_b_open_space_dict=dict(zip(range(len(cc_subG_b_open_space)),cc_subG_b_open_space))
```


```python
sorting_dict_by_values=lambda d:sorted(d.items(),key=lambda x:x[1])
print(sorting_dict_by_values(subGs_metric(G_b,cc_subG_b_open_space_dict,nx.average_clustering)))
```

    [(9, 0.0), (10, 0.0), (12, 0.0), (13, 0.0), (14, 0.0), (16, 0.0), (17, 0.0), (18, 0.0), (19, 0.0), (20, 0.0), (21, 0.0), (22, 0.0), (23, 0.0), (24, 0.0), (26, 0.0), (27, 0.0), (28, 0.0), (29, 0.0), (4, 0.4866666666666667), (5, 0.5201754385964914), (7, 0.5325285043594901), (2, 0.5407066052227344), (3, 0.5476190476190476), (8, 0.5741496598639456), (11, 0.6814814814814816), (15, 0.819047619047619), (6, 0.8333333333333333), (0, 0.8666666666666666), (1, 1.0), (25, 1.0)]
    

`clustering`(G, nodes=None, weight=None)<sup>[12, 14,15,16]</sup>：计算各个顶点的聚类系数。


```python
G=nx.complete_graph(5)
G.remove_edge(4,2)
util_misc.G_drawing(G)
print(nx.clustering(G, 0))
print(nx.clustering(G))
```

<img src="./imgs/2_8_2/output_145_0.png" height='auto' width='auto' title="caDesign">
    
!
    


    0.8333333333333334
    {0: 0.8333333333333334, 1: 0.8333333333333334, 2: 1.0, 3: 0.8333333333333334, 4: 1.0}
    

`NetWorkX`库也提供了`square_clustering`(G[, nodes])四边形聚类系数和`generalized_degree`(G[, nodes])等方法。

#### 5）Centrality（中心性）

对图中心性的解释参考*Handbook of Graphs and Networks in People Analytics: With Examples in R and Python*<sup>[1]</sup>，其提供的图$G_{14} $（法国办公楼网络）为下图所示（定义为无权重的无向图），该复杂网络的边文件（CSV格式）可以从给定的地址下载。


```python
import networkx as nx
import pandas as pd

g14w_edges=pd.read_csv("https://ona-book.org/data/g14_edgelist.csv")
print(g14w_edges)
G_14=nx.from_pandas_edgelist(g14w_edges, source="from", target="to", edge_attr=True)
util_misc.G_drawing(G_14,nodes=[[4],[7],[8],[9]],figsize=(5,5))
```

        from  to  weight
    0      9  10       4
    1     10  11       1
    2     11  12       1
    3     10  12       1
    4      9  13       3
    5     13  14       2
    6      9   8       2
    7      9   7       3
    8      8   7       1
    9      4   6       1
    10     4   7       2
    11     4   8       3
    12     6   7       2
    13     4   1       1
    14     4   2       1
    15     4   3       1
    16     4   5       2
    17     1   2       1
    


<img src="./imgs/2_8_2/output_148_1.png" height='auto' width='auto' title="caDesign">    

    


$G_{14} $图中标识了不同颜色的4个顶点，其在图中的连接结构中具有重要作用，如果移除顶点9，图将会被分离为3个子图；而顶点4的度为7，如果移除该顶点也会分离出更多的子图；顶点7则可以有效的到达其它的顶点；而顶点8似乎位于其它3个顶点之间。通过中心性度量，可以观察网络变化可能产生的影响，或者识别网络中代表某种意义的重要顶点。

* Degree centrality（顶点度中心性）

顶点度中心性即为顶点的度，可以通过除以顶点数为$n-1$简单图（相对于多重图图而言）最大可能的度进行归一化处理。顶点度中心性是对顶点邻点连接性（immediate connection）的度量，为直接的影响。具有高度中心性的顶点与更多的邻点（相邻的顶点）相连。与顶点度中心性相关的是自我规模（ego size）。给定顶点$V$的$n$级自我网络（ego network/graph）是一个包括$V$本身和所有距离$V$最多为$n$的顶点集合。顶点自我规模是$n$级自我网络中的顶点数。例如在$G_{14} $图中，顶点8的1级自我规模为4（含自身），2级为11，3级为14（整个图）。可知，顶点的1级自我规模比顶点度大1。

$G_{14} $图中顶点4具有最高的顶点度中心性。

`degree_centrality`(G)：计算顶点度中心性。

> `NetWorkX`库也提供了对于有向图`in_degree_centrality(G)`入度中心性和`out_degree_centrality(G)`出度中心性的计算。


```python
sorting_dict_by_values(nx.degree_centrality(G_14))
```




    [(14, 0.07692307692307693),
     (3, 0.07692307692307693),
     (5, 0.07692307692307693),
     (11, 0.15384615384615385),
     (12, 0.15384615384615385),
     (13, 0.15384615384615385),
     (6, 0.15384615384615385),
     (1, 0.15384615384615385),
     (2, 0.15384615384615385),
     (10, 0.23076923076923078),
     (8, 0.23076923076923078),
     (9, 0.3076923076923077),
     (7, 0.3076923076923077),
     (4, 0.5384615384615385)]




```python
[i[0] for i in dc_subG_b_os]
```




    [1924, 1978, 1979, 2034, 2035]



`subG_b_open_space`图继承于`Queen`类型空间权重，因此除了边缘（含角点）的顶点，具有相同的顶点度中心性，即具有相同的度。


```python
sorting_dict_by_values(nx.degree_centrality(subG_b_open_space))[-5:]
```




    [(1924, 0.02877697841726619),
     (1978, 0.02877697841726619),
     (1979, 0.02877697841726619),
     (2034, 0.02877697841726619),
     (2035, 0.02877697841726619)]



`ego_graph`(G, n, radius=1, center=True, undirected=False, distance=None)：返回以顶点$V$为中心，给定半径（radius）（级数/跳，order）以内所有顶点（含$V$）的导出子图（induced subgraph）。


```python
G_14_1=nx.ego_graph(G_14,4,1)
print(G_14_1.nodes)
util_misc.G_drawing(G_14_1,figsize=(5,5),nodes=[[4]])
```

    [8, 7, 4, 6, 1, 2, 3, 5]
    


<img src="./imgs/2_8_2/output_155_1.png" height='auto' width='auto' title="caDesign">    

    


对于半径为2的导出子图，用不同颜色标识所在半径。


```python
G_14_2=nx.ego_graph(G_14,4,2)
print(G_14_2.nodes)
util_misc.G_drawing(G_14_2,figsize=(5,5),nodes=[G_14_1.nodes,set(G_14_2.nodes)-set(G_14_1.nodes),[4]])
```

    [9, 8, 7, 4, 6, 1, 2, 3, 5]
    


<img src="./imgs/2_8_2/output_157_1.png" height='auto' width='auto' title="caDesign">    



为了方便计算序列半径值变化下的导出ego Graph，及获得变化增加的顶点集，定义`ego_graphs_batch()`函数实现。


```python
def ego_graphs_batch(G, n, radius_lst, center=True, undirected=False, distance=None):
    '''
    给定半径列表，批量导出ego graph，及变化增加的顶点集合

    Parameters
    ----------
    G : networkx.classes.graph.Graph
        图（复杂网络）.
    n : int
        顶点索引值.
    radius_lst : list[number]
        半径列表.
    center : bool, optional
        如果为False，则不包含中心顶点. The default is True.
    undirected : bool, optional
        如果为True，则为双向连通有向图. The default is False.
    distance : key, optional
        使用边的属性值（权重值计算距离半径）. The default is None.

    Returns
    -------
    ego_graphs : list[networkx.classes.graph.Graph]
        DESCRIPTION.
    egoG_nodes_diff : dict[set]
        随半径增加，ego graph变化增加的顶点集.

    '''    
    import networkx as nx
    
    ego_graphs={}
    egoG_nodes=set({})
    egoG_nodes_diff={}
    for idx,radius in enumerate(radius_lst):
        ego_G=nx.ego_graph(G,n,radius)
        ego_graphs[idx]=ego_G
        nodes_diff=set(ego_G.nodes)-egoG_nodes
        if len(nodes_diff)>0:
            egoG_nodes_diff[idx]=nodes_diff
            egoG_nodes=set(ego_G.nodes)|egoG_nodes
        else:
            break     
        
    return ego_graphs,egoG_nodes_diff           
```


```python
from matplotlib.axes._axes import _log as matplotlib_axes_logger
matplotlib_axes_logger.setLevel('ERROR')

ego_graphs,egoG_nodes_diff=ego_graphs_batch(subG_woodglenn_park,1198, list(range(21)))  
cmap=matplotlib.cm.get_cmap('cividis', len(egoG_nodes_diff))
cmap_colors=np.flip(cmap.colors,0)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(egoG_nodes_diff.values()),
                    nodes_color=cmap_colors_flip
                   )
```


<img src="./imgs/2_8_2/output_160_0.png" height='auto' width='auto' title="caDesign">    

    


* Closeness centrality（接近中心性/紧密度）

顶点$v$的紧密度为连通图中顶点$v$到图中其它顶点距离和的倒数。例如$G_{14} $图中顶点8距离为1连通的顶点有4、7和9；距离为2连通的顶点有1、2、3、5、6、10和13；距离为3连通的顶点有11、12和14。这些距离之和为$3 \times 1+2 \times 7+3 \times 3=26$，其倒数为0.038。距离的倒数意味着较小的总的距离将获得更高的紧密度。因此，具有高紧密度的顶点更有效的到达图中的其它顶点。在$G_{14} $图中顶点8具有高紧密度。紧密度是衡量从给定顶点遍历（traversed）整个图效率的度量。具有高紧密度的顶点共享的信息可能会更有效的到达整个网络。

`closeness_centrality`(G, u=None, distance=None, wf_improved=True)<sup>【17, 18】</sup>：计算图的紧密度。`NetWorkX`库提供的紧密度计算方法为：$C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)}$，式中$u$为中心顶点；$v$为顶点$u$可到达的其它顶点；$n-1$为$u$可到达其它顶点的数量。

$G_{14} $图中顶点7具有最高的紧密度。

> `NetWorkX`库也提供了`incremental_closeness_centrality`(G, edge, prev_cc=None, insertion=True, wf_improved=True)方法。


```python
sorting_dict_by_values(nx.closeness_centrality(G_14))
```




    [(14, 0.2708333333333333),
     (11, 0.28888888888888886),
     (12, 0.28888888888888886),
     (3, 0.3333333333333333),
     (5, 0.3333333333333333),
     (1, 0.34210526315789475),
     (2, 0.34210526315789475),
     (13, 0.3611111111111111),
     (10, 0.38235294117647056),
     (6, 0.40625),
     (4, 0.48148148148148145),
     (9, 0.5),
     (8, 0.5),
     (7, 0.52)]



计算`subG_woodglenn_park`图的紧密度，并将紧密度追加到顶点名为`closeness_centrality`的属性中，且根据该属性值大小赋予顶点变化颜色，易于观察紧密度分布。


```python
closenessCentrality_subG_wp=nx.closeness_centrality(subG_woodglenn_park)
nx.set_node_attributes(subG_woodglenn_park, closenessCentrality_subG_wp, name="closeness_centrality")
node_color=[round(255*i) for i in nx.get_node_attributes(subG_woodglenn_park,'closeness_centrality').values()]
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    linewidths=1,
                    font_size=9, 
                    node_size=200,
                    node_color=node_color,
                    cmap=plt.cm.coolwarm
                   )
```


<img src="./imgs/2_8_2/output_164_0.png" height='auto' width='auto' title="caDesign">    



* Betweenness centrality（介数中心度）

顶点$v$的介数中心度是取每一对其它顶点$x$和$y$，计算$x$和$y$之间通过顶点$v$的最短路径数，除以$x$和$y$之间最短路径总数，然后对图中所有顶点对执行同样计算并求和。介数中心度衡量给定顶点在连通图中于其它顶点对的重要性。具有较高介数中心度的顶点在确保网络整体连通性方面发挥着重要作用，如果将其移除，则网络整体断开的风险较高。

`betweenness_centrality`(G, k=None, normalized=True, weight=None, endpoints=False, seed=None)<sup>[19, 20, 21, 22]</sup>：计算介数中心度。

$G_{14} $图中顶点9具有最高的介数中心度。


```python
sorting_dict_by_values(nx.betweenness_centrality(G_14))
```




    [(11, 0.0),
     (12, 0.0),
     (14, 0.0),
     (6, 0.0),
     (1, 0.0),
     (2, 0.0),
     (3, 0.0),
     (5, 0.0),
     (13, 0.15384615384615385),
     (8, 0.1923076923076923),
     (7, 0.2756410256410256),
     (10, 0.28205128205128205),
     (4, 0.532051282051282),
     (9, 0.5897435897435898)]



计算`subG_woodglenn_park`图的介数中心度，可以发现具有较高值的顶点通常位于顶点度较小，连通较大基数分支的薄弱处，例如顶点1699、1755和1418、1473等。


```python
betweennessCentrality_subG_wp=nx.betweenness_centrality(subG_woodglenn_park)
nx.set_node_attributes(subG_woodglenn_park, betweennessCentrality_subG_wp, name="betweenness_centrality")
node_color=[round(255*i) for i in nx.get_node_attributes(subG_woodglenn_park,'betweenness_centrality').values()]
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    linewidths=1,
                    font_size=9, 
                    node_size=200,
                    node_color=node_color,
                    cmap=plt.cm.coolwarm
                   )
```


<img src="./imgs/2_8_2/output_168_0.png" height='auto' width='auto' title="caDesign">    



`betweenness_centrality_subset`(G, sources, targets, normalized=False, weight=None)<sup>[19, 20]</sup>：计算指定顶点对的介数中心度。

> `NetWorkX`库也提供了针对边介数中心度计算的`edge_betweenness_centrality`(G, k=None, normalized=True, weight=None, seed=None)、`edge_betweenness_centrality_subset`(G, sources, targets, normalized=False, weight=None)，及communicability_betweenness_centrality(G)等。


```python
sorting_dict_by_values(nx.betweenness_centrality_subset(G_14,[14,13],[5,12]))
```




    [(11, 0.0),
     (12, 0.0),
     (14, 0.0),
     (6, 0.0),
     (1, 0.0),
     (2, 0.0),
     (3, 0.0),
     (5, 0.0),
     (8, 0.5),
     (7, 0.5),
     (10, 1.0),
     (13, 1.0),
     (4, 1.0),
     (9, 2.0)]



* Eigenvector centrality（特征向量中心性）

一个顶点的特征向量中心性计算是基于其邻点的中心性，为衡量该顶点的相对影响作为其邻点影响的函数。顶点可以通过连接到许多其它低影响的顶点或通过连接到少数具有高影响的顶点而具有高影响。例如$G_{14} $图中顶点10的特征向量中心性为0.115，而顶点2为0.226，这是因为顶点2连接到具有最高顶点度中心性的顶点4。也不难理解顶点4具有最高的特征向量中心性。

`eigenvector_centrality`(G, max_iter=100, tol=1e-06, nstart=None, weight=None)<sup>[23, 24]</sup>：计算图G的特征向量中心性。


```python
sorting_dict_by_values(nx.eigenvector_centrality(G_14))
```




    [(14, 0.028067145146879576),
     (11, 0.04773668169045784),
     (12, 0.04773668169045784),
     (13, 0.09618886694204133),
     (10, 0.11585840348561958),
     (3, 0.16059364565176917),
     (5, 0.16059364565176917),
     (1, 0.22675905135708657),
     (2, 0.22675905135708657),
     (6, 0.2900049403580402),
     (9, 0.301582841850565),
     (8, 0.3780039901700192),
     (7, 0.4435101028690069),
     (4, 0.5503779695532801)]



计算`subG_woodglenn_park`图的特征向量中心性，邻点具有较高顶点度集聚的区域具有较高的特征向量中心性。

> `NetWorkX`库也提供了`eigenvector_centrality_numpy`(G, weight=None, max_iter=50, tol=0)、`katz_centrality`(G, alpha=0.1, beta=1.0, max_iter=1000, tol=1e-06, nstart=None, normalized=True, weight=None和`katz_centrality_numpy`(G, alpha=0.1, beta=1.0, normalized=True, weight=None)等方法。


```python
eigenvectorCentrality_subG_wp=nx.eigenvector_centrality(subG_woodglenn_park)
nx.set_node_attributes(subG_woodglenn_park, eigenvectorCentrality_subG_wp, name="eigenvector_centrality")
node_color=[round(255*i) for i in nx.get_node_attributes(subG_woodglenn_park,'eigenvector_centrality').values()]
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    linewidths=1,
                    font_size=9, 
                    node_size=200,
                    node_color=node_color,
                    cmap=plt.cm.coolwarm
                   )
```


<img src="./imgs/2_8_2/output_174_0.png" height='auto' width='auto' title="caDesign">   

    


* Core decomposition （核分解）

核分解是基于顶点度分离图为多个明显差异的部分（子图），有助于移除周边的顶点集观察核心的部分。

`core_number`(G)：返回每个顶点的核数量。k-core（k-核）是包含顶点度至少为$k$的最大子图。一个顶点的核数量是包含该顶点k-core的最大值$k$。


```python
G=nx.lollipop_graph(6, 3)
G.add_edges_from([(8,9),(7,9),(9,10)])
G.add_edges_from([(4,6)])
util_misc.G_drawing(G)
nx.core_number(G)
```


<img src="./imgs/2_8_2/output_176_0.png" height='auto' width='auto' title="caDesign">    

    





    {0: 5, 1: 5, 2: 5, 3: 5, 4: 5, 5: 5, 6: 2, 7: 2, 8: 2, 9: 2, 10: 1}




```python
print(nx.core_number(subG_woodglenn_park))
```

    {1920: 4, 1921: 4, 1922: 4, 1923: 4, 1924: 4, 1925: 4, 1926: 4, 1927: 2, 1418: 2, 1807: 3, 1808: 3, 1809: 4, 1810: 4, 1811: 4, 1812: 4, 1813: 4, 1814: 3, 2202: 3, 2203: 3, 2204: 3, 1306: 2, 1307: 2, 1309: 3, 1310: 3, 1699: 3, 2088: 2, 2089: 4, 2090: 4, 2091: 4, 2092: 4, 1197: 3, 1198: 3, 1584: 3, 1585: 3, 1586: 3, 1587: 3, 1977: 4, 1978: 4, 1979: 4, 1980: 4, 1981: 4, 1473: 2, 1863: 3, 1864: 4, 1865: 4, 1866: 4, 1867: 4, 1868: 4, 1869: 4, 1870: 4, 2258: 3, 2259: 3, 2260: 3, 1362: 2, 1755: 3, 2146: 4, 2147: 4, 2148: 3, 1252: 3, 1253: 3, 1254: 3, 1641: 3, 1642: 3, 1643: 3, 2033: 4, 2034: 4, 2035: 4, 2036: 4, 1529: 3, 1917: 1, 1918: 1}
    

`k_core`(G, k=None, core_number=None)<sup>[25]</sup>：返回图G的k_core。k-core是包含顶点度数至少为$k$的最大子图。如果不指定参数`k`，则返回主要核。

`k_shell`(G, k=None, core_number=None)<sup>A model of Internet topology using k-shell decomposition Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt, and Eran Shir, PNAS July 3, 2007 vol. 104 no. 27 11150-11154 http://www.pnas.org/content/104/27/11150.full</sup>：返回图G的k_shell。k_shell是包含顶点度数至少为$k$的最大子图，但是顶点在k-core中的将不再(k+1)-core中。

`k_crust`(G, k=None, core_number=None)<sup>[26]</sup>：返回图G的k_crust。k_crust是移除k-core边的图G，移除边后孤立的顶点也将被移除。

`k_corona`(G, k, core_number=None)<sup>[27]</sup>：返回图G的k_corona。k_corona是k-core中顶点的子图，这些顶点在k-core中恰好有$k$个邻点。

`k_truss`(G, k)<sup>[28, 29]</sup>：返回图G的k_truss。k_truss是图G的最大导出子图，至少包含三个顶点，且每边关联到至少$k-2$的三角形（triads）。


```python
k_core_subG_wp=nx.k_core(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=[list(k_core_subG_wp)],
                   )
```


<img src="./imgs/2_8_2/output_179_0.png" height='auto' width='auto' title="caDesign">    




```python
k_shell_subG_wp=nx.k_shell(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=[list(k_shell_subG_wp)],
                   )
```


<img src="./imgs/2_8_2/output_180_0.png" height='auto' width='auto' title="caDesign">    




```python
k_crust_subG_wp=nx.k_crust(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=[list(k_crust_subG_wp)],
                   )
```


<img src="./imgs/2_8_2/output_181_0.png" height='auto' width='auto' title="caDesign">    




```python
k_corona_subG_wp=nx.k_corona(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=[list(k_corona_subG_wp)],
                   )
```


<img src="./imgs/2_8_2/output_182_0.png" height='auto' width='auto' title="caDesign">    




```python
k_truss_subG_wp=nx.k_truss(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=[list(k_truss_subG_wp)],
                   )
```


<img src="./imgs/2_8_2/output_183_0.png" height='auto' width='auto' title="caDesign">   



#### 6）Communities（社区/集群）

Communities（社区）也称之为clusters（集群/簇）或modules（模块），本文统一使用集群一词。在图（复杂网络）中识别集群的方式也有不同的名称，例如集群检测（detection）、集群发现（discovery）和聚类（clustering）等。集群是典型的一个连通子网络，例如下图<sup>[1]</sup>中标识为绿色的顶点集。洋红色的顶点集在集群外部，但是与集群连通。图中剩余的顶点标识为黑色。蓝色的边将集群连通到图的其它部分。集群关键的变量解释如下：

<img src="./imgs/2_8_2/2_8_2_01.png" height="auto" width=500  title="digit-x" />  

* 集群一个顶点的内部度和外部度： 集群内外邻点的数量。例如内部度为一个标识为浅绿色顶点的集群内邻点（黑色边连通）数量；而外部度为一个标识为浅绿色顶点的集群外邻点（蓝色线连通）数量。集群一个顶点的内部度与外部度之和即为该顶点的度。

* 集群内边数：为集群内两点连接的边数量，即图中椭圆虚线内的黑色边数量。

* 集群度：集群中顶点度之和，为绿色顶点邻点数之和。

* 内部边密度：为集群边数与最大可能连通边数的比例。

以符号和公式的方式描述上述变量的解释，假设存在一个集群为$C(V,E)$，且$C \subseteq G(V,E)$，即$C$为$G$的一个子图。集群的顶点数量即集群的阶，表示为$| C | $，集群的边数表示为$\| C \| $。集群$C$顶点$i$的内部度记为$k _i ^{int} $，外部度记为$k _i ^{ext} $，为顶点$i$集群内邻点（$v \in C$）的数量和集群外邻点（$v \in G-C$）的数量。因为顶点$i$的邻点即有在集群内，又有在集群外，因此顶点$i$的顶点度满足$k_{i}=k _i ^{int}+k _i ^{ext} $。如果$k _i ^{ext}=0 $并且$k _i ^{int}  > 0$，则顶点$i$的邻点集$N(i) \in C$；如果$k _i ^{ext}>0 $并且$k _i ^{int}  > 0$，则顶点$i$的邻点部分属于$C$，部分属于$G-C$，且是集群$C$的边界顶点（boundary vertex）；如果$k _i ^{int}  = 0$，则顶点$i \in G-C$，而且没有邻点在$C$中，为图中标识为黑色的顶点。

内部边密度公式为（无向图）：$ \delta _{C} ^{int}= \frac{ \| C \| }{  \left( \begin{array}{c}  |  C| \\2 \end{array} \right)  } = \frac{2   \| C \|}{ |  C|( |  C|-1)} $。

集群度公式为：$k_{C} = \sum_{i \in C}  k_{i} $。

对图G划分集群的算法很多，仅从`NetWorkX`库中列出少数部分说明。

`kernighan_lin_bisection`(G, partition=None, max_iter=10, weight='weight', seed=None)<sup>[30]</sup>：应用Kernighan–Lin算法将图分割为两个部分。该算法通过迭代交换顶点以减少分割的两组之间边的切割。如果不固定参数`seed`，则每次运行结果可能不同。


```python
from networkx.algorithms import community

klb_subG_wp=community.kernighan_lin_bisection(subG_woodglenn_park,max_iter=1000)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=klb_subG_wp,
                   )
```


<img src="./imgs/2_8_2/output_185_0.png" height='auto' width='auto' title="caDesign">    

    


`k_clique_communities`(G, k, cliques=None)<sup>[31]</sup>：使用渗透法（percolation method）在图中寻找k-团（clique）集群。k-团集群是大小为$k$的所有团的联合，这些团可以通过相邻的（共享k-1 个顶点）的k-团达到。


```python
kcc_subG_wp=community.k_clique_communities(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(kcc_subG_wp),
                   )
```


<img src="./imgs/2_8_2/output_187_0.png" height='auto' width='auto' title="caDesign">   

    


`greedy_modularity_communities`(G, weight=None, resolution=1, cutoff=1, best_n=None)<sup>[32, 33, 34, 35]</sup>：使用贪心模块最大化（greedy modularity maximization）寻找图G中的集群。该函数使用的为Clauset-Newman-Moore贪心模块最大化算法，该算法从自身集群中的每个顶点开始，重复加入导致最大模块化的一对集群，直到模块化不可能进一步扩大为止。参数`cutoff`配置集群数量下限；`best_n`配置集群数量上限。


```python
from networkx.algorithms.community import greedy_modularity_communities

gmc_subG_wp=greedy_modularity_communities(subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(gmc_subG_wp),
                   )
```


<img src="./imgs/2_8_2/output_189_0.png" height='auto' width='auto' title="caDesign">    

    


`asyn_lpa_communities`(G, weight=None, seed=None)<sup>[36]</sup>：使用异步标签传播（asynchronous label propagation）算法寻找图G中的集群。该算法是概率性的，每次执行结果可能不同。在用唯一标签初始化每一个顶点后，重复设置该顶点的标签为邻点中出现频数最多的标签，当每个顶点都具有在其邻点中出现频数最多的标签时，算法停止。


```python
alc_subG_wp=community.asyn_lpa_communities(subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(alc_subG_wp),
                   )
```


<img src="./imgs/2_8_2/output_191_0.png" height='auto' width='auto' title="caDesign">    

    


`louvain_communities`(G, weight='weight', resolution=1, threshold=1e-07, seed=None)<sup>[37, 38, 39]</sup>：使用Louvain集群探测算法寻找图G中最佳集群划分。该算法是一种集群提取的简单方法，为基于模块化优化（modularity optimization）的启发式算法（ heuristic method）。该算法分两步，首先将每个顶点分配到各自的集群中，然后试图移动每个顶点到其相邻的集群中找到最大正模块化增益（maximum positive modularity gain）。如果没有获得正增益，则该顶点被保留在原始的集群中。


```python
lc_subG_wp=community.louvain_communities(subG_woodglenn_park)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(lc_subG_wp),
                   )
```


<img src="./imgs/2_8_2/output_193_0.png" height='auto' width='auto' title="caDesign">    



`asyn_fluidc`(G, k, max_iter=100, seed=None)<sup>[40]</sup>：返回图G中由流集群（ Fluid Communities）算法检测到的集群。该算法受启发于流在环境中的相互作用、相互膨胀和推动的简单概念。该初始化是随机的，因此每次执行结果可能不同。首先，由图中的随机顶点初始化$k$个集群，然后随机遍历所有顶点，根据每个顶点所在集群及其相邻的集群更新每个顶点的集群，此过程直至收敛。在任何时候，每个集群的总密度为1，在它包含的顶点之间平均分布。如果集群的顶点发生了变化，则立即调整受影响集群的顶点密度。当完成对所有顶点的完整迭代，使得没有顶点改变它所属的集群时，算法收敛并返回结果。


```python
af_subG_wp=community.asyn_fluidc(subG_woodglenn_park,3)
util_misc.G_drawing(subG_woodglenn_park,
                    pos=nx.get_node_attributes(subG_woodglenn_park,'pos'),
                    figsize=(10,5),
                    font_size=9, 
                    nodes=list(af_subG_wp),
                   )
```


<img src="./imgs/2_8_2/output_195_0.png" height='auto' width='auto' title="caDesign">    

    


* 测量分区

`modularity`(G, communities, weight='weight', resolution=1)<sup>[41, 42, 43, 44]</sup>：返回图的给定分区的模块化度量。


```python
print(community.modularity(subG_woodglenn_park, community.asyn_fluidc(subG_woodglenn_park,3)))
print(community.modularity(subG_woodglenn_park, community.louvain_communities(subG_woodglenn_park)))
print(community.modularity(subG_woodglenn_park, community.asyn_lpa_communities(subG_woodglenn_park)))
print(community.modularity(subG_woodglenn_park, greedy_modularity_communities(subG_woodglenn_park)))
print(community.modularity(subG_woodglenn_park, community.kernighan_lin_bisection(subG_woodglenn_park,max_iter=1000)))
```

    0.5365814463111761
    0.636245434623813
    0.6249233016800584
    0.6332651570489408
    0.4260043827611395
    

`partition_quality`(G, partition)<sup>[45]</sup>：返回图G分区的覆盖率和性能。分区的覆盖率为集群内边数与图总边数的比值。分区的性能为集群内边数加上集群间非边（non-edges）数量除以潜在边的总数。    


```python
print(community.partition_quality(subG_woodglenn_park, community.louvain_communities(subG_woodglenn_park)))
print(community.partition_quality(subG_woodglenn_park, greedy_modularity_communities(subG_woodglenn_park)))
print(community.partition_quality(subG_woodglenn_park, community.kernighan_lin_bisection(subG_woodglenn_park,max_iter=1000)))
```

    (0.8378378378378378, 0.8780684104627766)
    (0.8702702702702703, 0.8523138832997988)
    (0.918918918918919, 0.5694164989939637)
    

`girvan_newman`(G, most_valuable_edge=None)：使用Girvan–Newman方法在图中寻找集群。该算法通过逐步移除原始图中的边来检测集群，移除的边为”最优价值的边“，传统上是具有最高介数中心度的边。当图分解为多个部分时，紧密结合的集群结构就会暴露出来。


```python
from networkx.algorithms import community
G=nx.barbell_graph(5, 1)
util_misc.G_drawing(G)
communities_generator=community.girvan_newman(G)
```


<img src="./imgs/2_8_2/output_201_0.png" height='auto' width='auto' title="caDesign">    




```python
print(next(communities_generator))
print(next(communities_generator))
print(next(communities_generator))
print(next(communities_generator))
print(next(communities_generator))
```

    ({0, 1, 2, 3, 4}, {5, 6, 7, 8, 9, 10})
    ({0, 1, 2, 3, 4}, {6, 7, 8, 9, 10}, {5})
    ({0}, {1, 2, 3, 4}, {6, 7, 8, 9, 10}, {5})
    ({0}, {1}, {2, 3, 4}, {6, 7, 8, 9, 10}, {5})
    ({0}, {1}, {2}, {3, 4}, {6, 7, 8, 9, 10}, {5})
    

`is_partition`(G, communities)：如果集群为图G顶点的分区则返回True，否则为False。


```python
print(community.is_partition(subG_woodglenn_park, community.asyn_fluidc(subG_woodglenn_park,3)))
print(community.is_partition(subG_woodglenn_park, community.louvain_communities(subG_woodglenn_park)))
print(community.is_partition(subG_woodglenn_park, community.asyn_lpa_communities(subG_woodglenn_park)))
print(community.is_partition(subG_woodglenn_park, greedy_modularity_communities(subG_woodglenn_park)))
print(community.is_partition(subG_woodglenn_park, community.kernighan_lin_bisection(subG_woodglenn_park,max_iter=1000)))
print(community.is_partition(subG_woodglenn_park, community.k_clique_communities(subG_woodglenn_park,3)))
```

    True
    True
    True
    True
    True
    False
    

> 如果对调入的模块进行了改动，JupyterLab不会自动更新，可以通过下述代码重新加载模块获得更新，而不必重启Kernel。


```python
import importlib
importlib.reload(util_misc)
```




    <module 'util_misc' from 'C:\\Users\\richi\\omen_richiebao\\omen_github\\USDA_CH_final\\USDA\\notebook\\util_misc.py'>



---

注释（Notes）：

① pyproj（Python库），（<https://pyproj4.github.io/pyproj/stable/>）。

参考文献（References）:

[1] McNulty, K. (2022). Handbook of graphs and networks in people analytics: With examples in R and python. CRC Press. https://ona-book.org/vertex-importance.html

[2] M. E. J. Newman, Mixing patterns in networks, Physical Review E, 67 026126, 2003.

[3] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29;Wang.

[4] Wang, Tianhao, et al. (2015) A simple algorithm for finding all k-edge-connected components. http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264

[5] Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs from a large graph. ACM International Conference on Extending Database Technology 2012 480-–491. https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf

[6] Moody, J. and D. White (2003). Social cohesion and embeddedness: A hierarchical conception of social groups. American Sociological Review 68(1), 103–28. http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf

[7] Kanevsky, A. (1993). Finding all minimum-size separating vertex sets in a graph. Networks 23(6), 533–541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract

[8] Torrents, J. and F. Ferraro (2015). Structural Cohesion: Visualization and Heuristics for Fast Computation. https://arxiv.org/pdf/1503.04476v1

[9] Beineke, L., O. Oellermann, and R. Pippert (2002). The average connectivity of a graph. Discrete mathematics 252(1-3), 31-45. http://www.sciencedirect.com/science/article/pii/S0012365X01001807

[10] Clique (graph theory) Wikipedia，https://en.wikipedia.org/wiki/Clique_(graph_theory)

[11] Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J., Langston, M.A., Samatova, N.F., “Genome-Scale Computational Approaches to Memory-Intensive Applications in Systems Biology”. Supercomputing, 2005. Proceedings of the ACM/IEEE SC 2005 Conference, pp. 12, 12–18 Nov. 2005. <https://doi.org/10.1109/SC.2005.29>.

[12] Generalizations of the clustering coefficient to weighted complex networks by J. Saramäki, M. Kivelä, J.-P. Onnela, K. Kaski, and J. Kertész, Physical Review E, 75 027105 (2007). http://jponnela.com/web_documents/a9.pdf

[13] Marcus Kaiser, Mean clustering coefficients: the role of isolated nodes and leafs on clustering measures for small-world networks. https://arxiv.org/abs/0802.2512

[14] Intensity and coherence of motifs in weighted complex networks by J. P. Onnela, J. Saramäki, J. Kertész, and K. Kaski, Physical Review E, 71(6), 065103 (2005).

[15] Generalization of Clustering Coefficients to Signed Correlation Networks by G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).

[16] Clustering in complex directed networks by G. Fagiolo, Physical Review E, 76(2), 026107 (2007).

[17] Linton C. Freeman: Centrality in networks: I. Conceptual clarification. Social Networks 1:215-239, 1979. https://doi.org/10.1016/0378-8733(78)90021-7

[18] pg. 201 of Wasserman, S. and Faust, K., Social Network Analysis: Methods and Applications, 1994, Cambridge University Press.

[19] Ulrik Brandes: A Faster Algorithm for Betweenness Centrality. Journal of Mathematical Sociology 25(2):163-177, 2001. https://doi.org/10.1080/0022250X.2001.9990249

[20] Ulrik Brandes: On Variants of Shortest-Path Betweenness Centrality and their Generic Computation. Social Networks 30(2):136-145, 2008. https://doi.org/10.1016/j.socnet.2007.11.001

[21] Ulrik Brandes and Christian Pich: Centrality Estimation in Large Networks. International Journal of Bifurcation and Chaos 17(7):2303-2318, 2007. https://dx.doi.org/10.1142/S0218127407018403

[22] Linton C. Freeman: A set of measures of centrality based on betweenness. Sociometry 40: 35–41, 1977 https://doi.org/10.2307/3033543

[23] Phillip Bonacich. “Power and Centrality: A Family of Measures.” American Journal of Sociology 92(5):1170–1182, 1986 <http://www.leonidzhukov.net/hse/2014/socialnetworks/papers/Bonacich-Centrality.pdf>

[24] Mark E. J. Newman. Networks: An Introduction. Oxford University Press, USA, 2010, pp. 169.

[25] An O(m) Algorithm for Cores Decomposition of Networks Vladimir Batagelj and Matjaz Zaversnik, 2003. https://arxiv.org/abs/cs.DS/0310049

[26] A model of Internet topology using k-shell decomposition Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt, and Eran Shir, PNAS July 3, 2007 vol. 104 no. 27 11150-11154 http://www.pnas.org/content/104/27/11150.full

[27] k -core (bootstrap) percolation on complex networks: Critical phenomena and nonlocal effects, A. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes, Phys. Rev. E 73, 056101 (2006) http://link.aps.org/doi/10.1103/PhysRevE.73.056101

[28] Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber, David G. Harris, 2018. https://arxiv.org/abs/1806.05523v2

[29] Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan Cohen, 2005.

[30] Kernighan, B. W.; Lin, Shen (1970). “An efficient heuristic procedure for partitioning graphs.” Bell Systems Technical Journal 49: 291–307. Oxford University Press 2011.

[31] Gergely Palla, Imre Derényi, Illés Farkas1, and Tamás Vicsek, Uncovering the overlapping community structure of complex networks in nature and society Nature 435, 814-818, 2005, doi:10.1038/nature03607

[32] Newman, M. E. J. “Networks: An Introduction”, page 224 Oxford University Press 2011.

[33] Clauset, A., Newman, M. E., & Moore, C. “Finding community structure in very large networks.” Physical Review E 70(6), 2004.

[34] Reichardt and Bornholdt “Statistical Mechanics of Community Detection” Phys. Rev. E74, 2006.

[35] Newman, M. E. J.”Analysis of weighted networks” Physical Review E 70(5 Pt 2):056131, 2004.

[36] Raghavan, Usha Nandini, Réka Albert, and Soundar Kumara. “Near linear time algorithm to detect community structures in large-scale networks.” Physical Review E 76.3 (2007): 036106.

[37] Blondel, V.D. et al. Fast unfolding of communities in large networks. J. Stat. Mech 10008, 1-12(2008). https://doi.org/10.1088/1742-5468/2008/10/P10008

[38] Traag, V.A., Waltman, L. & van Eck, N.J. From Louvain to Leiden: guaranteeing well-connected communities. Sci Rep 9, 5233 (2019). https://doi.org/10.1038/s41598-019-41695-z

[39] Nicolas Dugué, Anthony Perez. Directed Louvain : maximizing modularity in directed networks. [Research Report] Université d’Orléans. 2015. hal-01231784. https://hal.archives-ouvertes.fr/hal-01231784

[40] Parés F., Garcia-Gasulla D. et al. “Fluid Communities: A Competitive and Highly Scalable Community Detection Algorithm”. [https://arxiv.org/pdf/1703.09307.pdf].

[41] M. E. J. Newman “Networks: An Introduction”, page 224. Oxford University Press, 2011.

[42] Clauset, Aaron, Mark EJ Newman, and Cristopher Moore. “Finding community structure in very large networks.” Phys. Rev. E 70.6 (2004). <https://arxiv.org/abs/cond-mat/0408187>

[43] Reichardt and Bornholdt “Statistical Mechanics of Community Detection” Phys. Rev. E 74, 016110, 2006. https://doi.org/10.1103/PhysRevE.74.016110

[44] M. E. J. Newman, “Equivalence between modularity optimization and maximum likelihood methods for community detection” Phys. Rev. E 94, 052315, 2016. https://doi.org/10.1103/PhysRevE.94.052315

[45] Santo Fortunato. “Community Detection in Graphs”. Physical Reports, Volume 486, Issue 3–5 pp. 75–174 <https://arxiv.org/abs/0906.0612>
