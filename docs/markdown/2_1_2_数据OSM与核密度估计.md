> Created on Fri Dec 27 14:28:05 2019 @author: Richie Bao-caDesign设计(cadesign.cn) __+updated on Mon Jul  6 19:29:41 2020 +updated on Fri Dec 24 09:15:15 2021

## 2.1.2 数据OSM与核密度估计

### 2.1.2.1 OpenStreetMap（OSM）数据处理

[OpenStreetMap(OSM)](https://www.openstreetmap.org/#map=13/41.8679/-87.6569)。"欢迎访问OpenStreetMap,这是个为全世界创建和分发免费地理数据的项目。我们之所以这么做，是因为人们认为作为免费的地图，在使用方面实际上有法律或者技术上的限制，阻碍了人们以创作性的、多产的、或意想不到的方式使用它们"。OSM提供了世界各地的道路、小径、咖啡馆、火车站等诸多地理信息数据，是我们在城市空间方面研究的宝贵数据财富。OSM数据的下载通过查看官网信息，一般来讲有两个途径：一个是直接下载显示窗口范围的数据，或输入坐标自定义范围。但是这种方式下载的数据量有限制，如果范围过大则无法下载；另一种方式是直接从资源库下载，不同的资源下载的方式也有所不同，根据自己的需要来确定。同时OSM提供了多年历史数据，这为城市空间变化的研究提供了数据支持。本次所下载的数据从[Geofabrik](https://download.geofabrik.de/north-america/us.html)库中下载，因为分析的目标区域为芝加哥城，下载了[llinois-latest-free.shp.zip](https://download.geofabrik.de/north-america/us/illinois.html)压缩文件340MB，解压后3.73GB。根据下载后点数据的分布情况，为了保持点连续的区域，增加下载[wisconsin-latest.osm.bz2](https://download.geofabrik.de/north-america/us/wisconsin.html)数据文件324MB，解压后3.73GB。可以使用QGIS初步查看数据。其包含的数据层有：lines，multilinestrings，multipolygons，other_relations 和points。

> 下图同时打开了了Ilinois和wisconsin的点数据，内部红色半透明区域为[芝加哥城行政范围](https://data.cityofchicago.org/Facilities-Geographic-Boundaries/Boundaries-City/ewy2-6yfk)，数据来源于[Chicago Data Portal](https://data.cityofchicago.org/). 外部红色虚线为实验数据提取的初步边界。最小的黑色矩形是用于代码调试提取的小规模数据范围。

<a href=""><img src="./imgs/2_1_2_01.jpg" height="auto" width="500" title="caDesign"></a>

#### 1）OSM原始数据处理

.osm数据处理包括合并两个区域数据，以及裁切，或者先分别裁切再合并。可以根据电脑内存需求和处理速度确定前后顺序。裁切.osm数据。这里选用的裁切方法是使用[osmosis](https://wiki.openstreetmap.org/wiki/Osmosis)命令行工具，非常适合处理大数据文件，裁切和更新数据。同时可以参考[Manipulating Data with Osmosis](https://learnosm.org/en/osm-data/osmosis/)。查询osmosis给出的案例，寻找应用polygon提取数据的代码为：`osmosis --read-xml file="planet-latest.osm" --bounding-polygon file="country2pts.txt" --write-xml file="germany.osm"`，共涉及到三个参数，原始.osm数据；裁切边界polygon（.txt数据格式）。需要注意该处的polygon为osmosis格式的polygon格式数据，需要编写转换代码；以及输出路径。

目视粗略判断点集聚的范围，在QGIS中绘制常规的polygon边界，如上图外红色虚线。首先编写polygon到osmosis格式的polygon代码，查询其数据格式为：
```
australia_v
first_area
     0.1446693E+03    -0.3826255E+02
     0.1446627E+03    -0.3825661E+02
     0.1446763E+03    -0.3824465E+02
     0.1446813E+03    -0.3824343E+02
     0.1446824E+03    -0.3824484E+02
     0.1446826E+03    -0.3825356E+02
     0.1446876E+03    -0.3825210E+02
     0.1446919E+03    -0.3824719E+02
     0.1447006E+03    -0.3824723E+02
     0.1447042E+03    -0.3825078E+02
     0.1446758E+03    -0.3826229E+02
     0.1446693E+03    -0.3826255E+02
END
second_area
     0.1422436E+03    -0.3839315E+02
     0.1422496E+03    -0.3839070E+02
     0.1422543E+03    -0.3839025E+02
     0.1422574E+03    -0.3839155E+02
     0.1422467E+03    -0.3840065E+02
     0.1422433E+03    -0.3840048E+02
     0.1422420E+03    -0.3839857E+02
     0.1422436E+03    -0.3839315E+02
END
END
```

定义转换格式函数时，调用了osgeo类，该类包含于[GDAL](https://pypi.org/project/GDAL/)库中。GDAL是一个用于栅格（raster）和矢量（vector）地理空间数据格式的开源转换库，包含大量格式驱动，大多数python的地理空间数据处理库通常基于GDAL编写，是最为基础的库。geopandas库基于fiona库，方便用户对地理空间数据的处理。而fiona包含链接到GDAL的扩展模块。通常在使用python地理空间数据库时，并没有使用哪个库的限制，目前最常用处理地理空间数据的库是geopandas，但是有时这些库不能满足所有要求，因此需要调用GDAL来处理。查看GDAL帮助信息，可以浏览[GDAL/OGR Cookbook!](http://pcjericks.github.io/py-gdalogr-cookbook/index.html)，以及[GDAL documentation](https://gdal.org/)


```python
def shpPolygon2OsmosisTxt(shape_polygon_fp,osmosis_txt_fp): 
    from osgeo import ogr #osgeo包含在GDAL库中
    '''
    function - 转换shape的polygon为osmium的polygon数据格式（.txt），用于.osm地图数据的裁切
    
    Params:
        shape_polygon_fp - 输入shape地理数据格式的polygon
        osmosis_txt_fp - 输出为osmosis格式的polygon数据格式.txt
    '''
    driver=ogr.GetDriverByName('ESRI Shapefile') #GDAL能够处理众多地理数据格式，此时调入了ESRI Shapefile数据格式驱动
    infile=driver.Open(shape_polygon_fp) #打开.shp文件
    layer=infile.GetLayer() #读取层
    f=open(osmosis_txt_fp,"w") 
    f.write("osmosis polygon\nfirst_area\n")
    
    for feature in layer: 
        feature_shape_polygon=feature.GetGeometryRef() 
        print(feature_shape_polygon) #为polygon
        firsts_area_linearring=feature_shape_polygon.GetGeometryRef(0) #polygon不包含嵌套，为单独的形状
        print(firsts_area_linearring) #为linearRing
        area_vertices=firsts_area_linearring.GetPointCount() #提取linearRing对象的点数量
        for vertex in range(area_vertices): #循环点，并向文件中写入点坐标
            lon, lat, z=firsts_area_linearring.GetPoint(vertex)  
            f.write("%s  %s\n"%(lon,lat))
    f.write("END\nEND")  
    f.close()   
    
#转换初步实验边界
shape_polygon_fp='./data/OSMBoundary/OSMBoundary.shp'
osmosis_txt_fp='./data/OSMBoundary.txt'
shpPolygon2OsmosisTxt(shape_polygon_fp,osmosis_txt_fp)

#转换代码调试小批量数据边界
shape_polygon_small_fp='./data/OSMBoundary_small/OSMBoundary_small.shp'
osmosis_txt_small_fp='./data/OSMBoundary_small.txt'
shpPolygon2OsmosisTxt(shape_polygon_small_fp,osmosis_txt_small_fp)
```

    POLYGON ((-90.0850881031402 40.9968994947319,-90.0850881031402 43.6657936592248,-87.383039973871 43.6657936592248,-87.383039973871 40.9968994947319,-90.0850881031402 40.9968994947319))
    LINEARRING (-90.0850881031402 40.9968994947319,-90.0850881031402 43.6657936592248,-87.383039973871 43.6657936592248,-87.383039973871 40.9968994947319,-90.0850881031402 40.9968994947319)
    POLYGON ((-87.6807286451907 41.8373927809521,-87.6807286451907 41.9214101975252,-87.5941157249019 41.9214101975252,-87.5941157249019 41.8373927809521,-87.6807286451907 41.8373927809521))
    LINEARRING (-87.6807286451907 41.8373927809521,-87.6807286451907 41.9214101975252,-87.5941157249019 41.9214101975252,-87.5941157249019 41.8373927809521,-87.6807286451907 41.8373927809521)
    

执行转换后，写入.txt格式文件的实际实验边界polygon如下：
```
osmosis polygon
first_area
-90.08508810314017  40.99689949473193
-90.08508810314017  43.66579365922478
-87.38303997387102  43.66579365922478
-87.38303997387102  40.99689949473193
-90.08508810314017  40.99689949473193
END
END
```

用于调试小批量数据提取的.txt边界：
```
osmosis polygon
first_area
-87.68072864519071  41.83739278095207
-87.68072864519071  41.92141019752525
-87.59411572490187  41.92141019752525
-87.59411572490187  41.83739278095207
-87.68072864519071  41.83739278095207
END
END
```

osmosis也提供多个.osm地理空间数据的合并，其合并示例代码为`osmosis --rx 1.osm --rx 2.osm --rx 3.osm --merge --wx merged.osm`。首先执行合并操作，针对该实验的osmosis合并代码`osmosis --rx "F:/GitHubBigData/illinois-latest.osm" --rx "F:/GitHubBigData/wisconsin-latest.osm"--merge --wx "F:/GitHubBigData/illinois-wisconsin.osm"`，合并后的文件大小为7.57GB。再执行裁切命令`osmosis --read-xml file="F:\GitHubBigData\illinois-wisconsin.osm" --bounding-polygon file="C:\Users\richi\omen_richiebao\omen_github\USDA_CH_final\USDA\notebook\data\OSMBoundary.txt" --write-xml file="F:\GitHubBigData\osm_clip.osm"`，裁切后的文件大小为3.80GB。可以再通过QGIS查看数据是否已经按照预期合并裁切完毕。用于代码调试的小规模数据提取直接裁切`osmosis --read-xml file="F:\GitHubBigData\illinois-wisconsin.osm" --bounding-polygon file="C:\Users\richi\omen_richiebao\omen_github\USDA_CH_final\USDA\notebook\data\OSMBoundary_small.txt" --write-xml file="F:\GitHubBigData\osm_small_clip.osm"`。

> osmosis命令行，于windows系统的命令行终端中执行，建议在[Windows PowerShell](https://docs.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7)终端中执行代码。具体文件路径需根据个人情况调整。

<a href=""><img src="./imgs/2_1_2_02.jpg" height="auto" width="auto" title="caDesign"></a>

OSM使用附加在基本数据结构上的标签（tag）来表示地面上的物理特征（feature），例如道路或者建筑物等。在QGIS中打开属性表，可以查看各要素所属于的标签。对于具体标签的内容可以查看[Map Features](https://wiki.openstreetmap.org/wiki/Map_Features)，下面仅列出主要标签的分类：

| 序号   |      一级标签      |  二级标签 |
|----------|:-------------|------:|
| 1 |   Aerialway |  |
| 2 |     Aeroway   |   |
| 3 |  Amenity |     Sustenance,Education,  Transportation, Financial, Healthcare, Entertainment, Arts & Culture, Others|
|4| Barrier| Linear barriers, Access control on highways|
| 5 |  Boundary |Attributes   |
| 6| Building |  Accommodation, Commercial, Religious,Civic/Amenity, Agricultural/Plant production, Sports,Storage,Cars, Power/Technical buildings,Other Buildings, Additional Attributes|
| 7 | Craft |   |
| 8 | Emergency | Medical Rescue,Firefighters, Lifeguards,  Assembly point,Other Structure |
| 9 |  Geological |   |
| 10 | Highway |  Roads, Link roads, Special road types, Paths,Lifecycle, Attributes,Other highway features|
| 11 | Historic |   |
| 12 | Landuse | Common Landuse Key Values - Developed land, Common Landuse Key Values - Rural and agricultural land, Other Landuse Key Values |
| 13 | Leisure |   |
| 14 |  Man_made |   |
| 15 | Military |   |
| 16 | Natural |  Vegetation or surface related, Water related, Landform related |
| 17 |Office  |   |
| 18 | Place | Administratively declared places,   Populated settlements, urban,Populated settlements, urban and rural, Other places|
| 19 |  Power |  Public Transport |
| 20 | Public Transport |  |
| 21 | Railway |  Tracks, Additional features, Stations and Stops, Other railways|
| 22 | Route |   |
| 23 | Shop | Food, beverages,  General store, department store, mall,  Clothing, shoes, accessories, Discount store, charity, Health and beauty, Do-it-yourself, household, building materials, gardening, Furniture and interior, Electronics, Outdoors and sport, vehicles, Art, music, hobbies,Stationery, gifts, books, newspapers, Others|
| 24 | Sport  |   |
| 25 |  Telecom |   |
| 26 |Tourism  |   |
| 27 |  Waterway | Natural watercourses, Man-made waterways, Facilities,Barriers on waterways,Other features on waterways|
| Additional properties |  |   |
| 1 | Addresses | Tags for individual houses, For countries using hamlet, subdistrict, district, province, state, Tags for interpolation ways |
| 2 | Annotation  |   |
| 3 | Name |   |
| 4 | Properties  |   |
| 5 | References  |   |
| 6 | Restrictions  |   |


> osmosis 工具是由OSM及其开源社区成员所建立的[osmcode.org](https://osmcode.org/)开发的工具。

#### 2）读取、转换.osm数据

用python读取.osm数据仍然使用[osmcode.org](https://osmcode.org/)提供的工具[pyosmium](https://docs.osmcode.org/pyosmium/latest/)。pyosmium用于处理不同格式的OSM文件，内核为c++的osmium库，能够有效快速的处理OSM数据。上述处理后的.osm数据文件osm_clip.osm为3.80GB，如果一开始就使用较大的数据来编写程序，花费的时间成本可能较高。可以给更少的数据编写、调试，达到预期效果后再使用待要分析的大文件数据。

> [pyosmium GitHub仓库及安装](https://github.com/osmcode/pyosmium)

编写读取.osm数据，需要对OSM的数据结构有所了解，从而能够清晰的提取所需要的值。[元素（elements）](https://wiki.openstreetmap.org/wiki/Elements)是OSM物理世界概念数据模型的基本组成部分，包括节点nodes、路径或区域ways、关系relations，及标签tag。

| 元素（elements）   |      图标     |  解释 |对位shape地理空间数据（vector矢量）|
|----------|:-------------|------:|------:|
| node |   <a href=""><img src="./imgs/30px-Osm_element_node.png" height="auto" width="auto" title="caDesign"></a> |由经纬度坐标定义的地理空间点  |point|
| way |    <a href=""><img src="./imgs/30px-Osm_element_way.svg.png" height="auto" width="auto" title="caDesign"></a><a href=""><img src="./imgs/30px-Osm_element_closedway.svg.png" height="auto" width="auto" title="caDesign"></a><a href=""><img src="./imgs/30px-Osm_element_area.svg.png" height="auto" width="auto" title="caDesign"></a>   | 由点(20-2000个)构成的路径以及闭合的区域，包含open way, closed way和area  |polyline,polygon|
| relation |     <a href=""><img src="./imgs/30px-Osm_element_relation.svg.png" height="auto" width="auto" title="caDesign"></a>   | 记录两个或多个元素之间关系的多用途数据结构，关系可以有不同的含义，其意义由对应的标签定义  ||
| tag|  <a href=""><img src="./imgs/30px-Osm_element_tag.svg.png" height="auto" width="auto" title="caDesign"></a>   | nodes、ways和relations都可以有描述其意义的标签，一个标签由键key:值value组成，Key必须是唯一的  |字段 field|

* 示例

**node**
```html
<node id="25496583" lat="51.5173639" lon="-0.140043" version="1" changeset="203496" user="80n" uid="1238" visible="true" timestamp="2007-01-28T11:40:26Z">
    <tag k="highway" v="traffic_signals"/>
</node>
```

**way**

简单的路径或区域 simple way
```html
  <way id="5090250" visible="true" timestamp="2009-01-19T19:07:25Z" version="8" changeset="816806" user="Blumpsy" uid="64226">
    <nd ref="822403"/>
    <nd ref="21533912"/>
    <nd ref="821601"/>
    <nd ref="21533910"/>
    <nd ref="135791608"/>
    <nd ref="333725784"/>
    <nd ref="333725781"/>
    <nd ref="333725774"/>
    <nd ref="333725776"/>
    <nd ref="823771"/>
    <tag k="highway" v="residential"/>
    <tag k="name" v="Clipstone Street"/>
    <tag k="oneway" v="yes"/>
  </way>
```

多边形区域集合 multipolygon area

<img src="./imgs/300px-Multipolygon_Illustration_2.svg.png" height="auto" width="auto" title="caDesign"><img src="./imgs/300px-Multipolygon_Illustration_1b.svg.png" height="auto" width="auto" title="caDesign">

```html
  <relation id="12" timestamp="2008-12-21T19:31:43Z" user="kevjs1982" uid="84075">
    <member type="way" ref="2878061" role="outer"/> <!-- picture ref="1" -->
    <member type="way" ref="8125153" role="inner"/> <!-- picture ref="2" -->
    <member type="way" ref="8125154" role="inner"/> <!-- picture ref="3" -->

    <member type="way" ref="3811966" role=""/> <!-- empty role produces
        a warning; avoid this; most software works around it by computing
        a role, which is more expensive than having one set explicitly;
        not shown in the sample pictures to the right -->

    <tag k="type" v="multipolygon"/>
  </relation>
```




* 元素的属性

| 名称   | 值类型          |  解释 |
|----------|:-------------|------:|
| id |integer (64-bit)   | 用于表示元素 |
| user |character string   | 最后修改对象的用户名 |
| uid | integer | 最后修改对象的用户ID |
| timestamp | W3C standard date and time  | 最后修改时间 |
|visible  | "true" or "false"  | 数据库中的对象是否被删除 |
|version  | integer  | 版本控制 |
|changeset  | integer  |创建或更新对象时使用的变更集编号  |

了解OSM基本的数据类型、结构和属性，通过继承osmium的类.SimpleHandler，用.apply_file方法传入.osm文件，并定义所要提取的元素类型，并给出该元素类型的属性提取对应的属性值。在地理空间数据分析中，通常比较关键的属性包括：元素修改的最后时间（.timestamp），标签（tags,<tag.k,tag.v>），生成的几何对象（geometry<point,linestring,multipolygon>）。下述函数分别提取了node, way(area)对象的属性和几何对象，同时将其转换为GeoDataFrame的数据格式，并存储为`GPKG`的格式数据，方便日后调用，尤其大批量数据。因为涉及到大批量数据，因此调入datatime时间模块，观察所用时间，帮助调试代码。


```python
import osmium as osm
class osmHandler(osm.SimpleHandler):    
    '''
    class-通过继承osmium类 class osmium.SimpleHandler读取.osm数据. 
    '''
    
    def __init__(self):
        osm.SimpleHandler.__init__(self)
        self.osm_node=[]
        self.osm_way=[]
        self.osm_area=[]
        
    def node(self,n):
        import pandas as pd
        import shapely.wkb as wkblib
        wkbfab=osm.geom.WKBFactory()
        
        wkb=wkbfab.create_point(n)
        point=wkblib.loads(wkb,hex=True)
        self.osm_node.append([
            'node',
            point,
            n.id,
            n.version,
            n.visible,
            pd.Timestamp(n.timestamp),
            n.uid,
            n.user,
            n.changeset,
            len(n.tags),
            {tag.k:tag.v for tag in n.tags},
            ])

    def way(self,w):     
        import pandas as pd
        import shapely.wkb as wkblib
        wkbfab=osm.geom.WKBFactory()
        
        try:
            wkb=wkbfab.create_linestring(w)
            linestring=wkblib.loads(wkb, hex=True)
            self.osm_way.append([
                'way',
                linestring,
                w.id,
                w.version,
                w.visible,
                pd.Timestamp(w.timestamp),
                w.uid,
                w.user,
                w.changeset,
                len(w.tags),
                {tag.k:tag.v for tag in w.tags}, 
                ])
        except:
            pass
        
    def area(self,a):  
        import pandas as pd
        import shapely.wkb as wkblib
        wkbfab=osm.geom.WKBFactory()        
        
        try:
            wkb=wkbfab.create_multipolygon(a)
            multipolygon=wkblib.loads(wkb, hex=True)
            self.osm_area.append([
                'area',
                multipolygon,
                a.id,
                a.version,
                a.visible,
                pd.Timestamp(a.timestamp),
                a.uid,
                a.user,
                a.changeset,
                len(a.tags),
                {tag.k:tag.v for tag in a.tags}, 
                ])
        except:
            pass      

import datetime        
a_T=datetime.datetime.now()
print("start time:",a_T)
#osm_Chicago_fp=r"F:\data\osm_small_clip.osm" #待读取的.osm数据路径, 用提取的小范围数据调试代码
osm_Chicago_fp=r"F:\data\osm_clip.osm" #用小批量数据调试完之后，计算实际的实验数据

osm_handler=osmHandler() #实例化类osmHandler()
osm_handler.apply_file(osm_Chicago_fp,locations=True) #调用 class osmium.SimpleHandler的apply_file方法
b_T=datetime.datetime.now()
print("end time:",b_T)
duration=(b_T-a_T).seconds/60
print("Total time spend:%.2f minutes"%duration)
```

    start time: 2021-12-24 11:00:18.357860
    end time: 2021-12-24 11:34:11.350215
    Total time spend:33.87 minutes
    

当读取全部OSM元素数据后，定义保存函数，如果是小批量数据，通常可以一起保存，但是本次实验数据有3.80GB，将读取后的数据转换为GeoDataFrame数据格式，并保存较为花费时间。因此将OSM元素逐个转换保存。同时，注意到在小批量调试时，保存node为GeoJSON格式文件其大小为104MB，而保存为GPKG仅有52.3MB，因此对于实验数据的保存，这里选择后者。


```python
def save_osm(osm_handler,osm_type,save_path=r"./data/",fileType="GPKG"):    
    import geopandas as gpd
    import os
    import datetime
    
    a_T=datetime.datetime.now()
    print("start time:",a_T)  
    '''
    function-根据条件逐个保存读取的osm数据（node, way and area）
    
    Paras:
        osm_handler - osm返回的node,way和area数据
        osm_type - 要保存的osm元素类型
        save_path - 保存路径
        fileType - 保存的数据类型，shp, GeoJSON, GPKG
    '''
    def duration(a_T):
        b_T=datetime.datetime.now()
        print("end time:",b_T)
        duration=(b_T-a_T).seconds/60
        print("Total time spend:%.2f minutes"%duration)
        
    def save_gdf(osm_node_gdf,fileType,osm_type):
        if fileType=="GeoJSON":
            osm_node_gdf.to_file(os.path.join(save_path,"osm_%s.geojson"%osm_type),driver='GeoJSON')
        elif fileType=="GPKG":
            osm_node_gdf.to_file(os.path.join(save_path,"osm_%s.gpkg"%osm_type),driver='GPKG')
        elif fileType=="shp":
            osm_node_gdf.to_file(os.path.join(save_path,"osm_%s.shp"%osm_type))

    epsg_wgs84=4326 #配置坐标系统，参考：https://spatialreference.org/        
    osm_columns=['type','geometry','id','version','visible','ts','uid','user','changeet','tagLen','tags']
    if osm_type=="node":
        osm_node_gdf=gpd.GeoDataFrame(osm_handler.osm_node,columns=osm_columns,crs=epsg_wgs84)
        save_gdf(osm_node_gdf,fileType,osm_type)
        duration(a_T)
        return osm_node_gdf

    elif osm_type=="way":
        osm_way_gdf=gpd.GeoDataFrame(osm_handler.osm_way,columns=osm_columns,crs=epsg_wgs84)
        save_gdf(osm_way_gdf,fileType,osm_type)
        duration(a_T)
        return osm_way_gdf
        
    elif osm_type=="area":
        osm_area_gdf=gpd.GeoDataFrame(osm_handler.osm_area,columns=osm_columns,crs=epsg_wgs84)
        save_gdf(osm_area_gdf,fileType,osm_type)
        duration(a_T)
        return osm_area_gdf
```


```python
node_gdf=save_osm(osm_handler,osm_type="node",save_path="./data/OSM_processed",fileType="GPKG")
```

    start time: 2021-12-24 11:35:34.746935
    end time: 2021-12-24 13:03:08.123318
    Total time spend:87.55 minutes
    


```python
way_gdf=save_osm(osm_handler,osm_type="way",save_path=r"./data/OSM_processed",fileType="GPKG")
```

    start time: 2021-12-24 14:16:00.736027
    end time: 2021-12-24 14:28:42.828275
    Total time spend:12.70 minutes
    


```python
area_gdf=save_osm(osm_handler,osm_type="area",save_path=r"./data/OSM_processed",fileType="GPKG")
```

    start time: 2021-12-24 14:29:30.864597
    end time: 2021-12-24 14:39:25.170465
    Total time spend:9.90 minutes
    

存储过程中，该部分实验数据，node元素存储时间约87分钟，存储的GPKG文件大小为3.10GB，way和area元素则相对存储时间较短，存储文件较小。因为已经转换为GeoDataFrame格式地理空间数据格式，因此可以直接.plot()查看数据分布情况，初步判断是否读取和转换正确。下述代码用来测试读取的时间，其中way和area读取时间较短，而node元素读取时间较长。


```python
def start_time():
    import datetime
    '''
    function-计算当前时间
    '''
    start_time=datetime.datetime.now()
    print("start time:",start_time)
    return start_time

def duration(start_time):
    import datetime
    '''
    function-计算持续时间
    
    Paras:
    start_time - 开始时间
    '''
    end_time=datetime.datetime.now()
    print("end time:",end_time)
    duration=(end_time-start_time).seconds/60
    print("Total time spend:%.2f minutes"%duration)
```


```python
import geopandas as gpd

start_time=start_time()
read_way_gdf=gpd.read_file("./data/OSM_processed/osm_way.gpkg")
duration(start_time)
```

    start time: 2021-12-24 17:14:44.041892
    end time: 2021-12-24 17:17:46.256983
    Total time spend:3.03 minutes
    

> 因为数据量较大，直接gdf.plot()会花费较长时间


```python
import matplotlib.pyplot as plt

Chicago_boundary_city_fp='./data/Chicago boundaries_city/Chicago boundaries_city.shp'
Chicago_boundary_city=gpd.read_file(Chicago_boundary_city_fp)

fig, ax=plt.subplots(figsize=(40,40))
read_way_gdf.plot(ax=ax,linewidth=0.5,zorder=1)
Chicago_boundary_city.plot(ax=ax,color='none', edgecolor='red',alpha=1,linewidth=5,zorder=2)
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_04.png" height="auto" width="auto" title="caDesign"></a>
    



```python
del read_way_gdf #如果内存有限，可以使用del 删除不再使用的变量，节约内存
```


```python
start_time=start_time()
read_area_gdf=gpd.read_file("./data/OSM_processed/osm_area.gpkg")
duration(start_time)
```

    start time: 2021-12-24 17:10:05.802124
    end time: 2021-12-24 17:12:52.787002
    Total time spend:2.77 minutes
    


```python
fig, ax=plt.subplots(figsize=(40,40))
read_area_gdf.plot(ax=ax,color='none', edgecolor='black',linewidth=0.5,zorder=1)
Chicago_boundary_city.plot(ax=ax,color='none', edgecolor='red',alpha=1,linewidth=5,zorder=2)
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_05.png" height="auto" width="auto" title="caDesign"></a>
    



```python
start_time=start_time()
read_node_gdf=gpd.read_file("./data/OSM_processed/osm_node.gpkg")
duration(start_time)
```

    start time: 2021-12-24 17:43:04.319218
    end time: 2021-12-24 18:13:09.240528
    Total time spend:30.07 minutes
    


```python
fig, ax=plt.subplots(figsize=(40,40))
read_node_gdf.plot(ax=ax,color='black',markersize=1)
Chicago_boundary_city.plot(ax=ax,color='none', edgecolor='red',alpha=1,linewidth=5,zorder=2)
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_06.png" height="auto" width="auto" title="caDesign"></a>
    


### 2.1.2.2 核密度估计与地理空间点密度分布

#### 1）单变量（一维数组）的核密度估计  

当直方图的组距无限缩小至极限后，能够拟合出一条曲线，计算这个分布曲线的公式即为概率密度函数（Probability Density Function,PDF），这是在[正态分布](https://richiebao.github.io/USDA_CH_final/#/./markdown/2_1_1_%E6%95%B0%E6%8D%AEPOI%E4%B8%8E%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1%E5%92%8C%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83)一节中所阐述的内容，用于估计概率密度函数的非参数方法就是核密度估计。核密度估计（Kernel density estimation, KDE）是一个基本的数据平滑问题（a fundamental data smoothing problem），例如对不平滑的直方图平滑，给定一个核K, 并指定带宽（bandwidth），其值为正数，核密度估计定义为： $\hat{f} _{n} (x)= \frac{1}{nh}  \sum_{i=1}^n {K( \frac{x- x_{i} }{h} )} $，其中K为核函数，$h$为带宽，核函数有多个，例举其中高斯核为：$\frac{1}{ \sqrt{2 \pi } }  e^{- \frac{1}{2}  x^{2} } $，将其带入核密度估计公式结果为：$\hat{f} _{n} (x)= \frac{1}{ \sqrt{2 \pi } nh}  \sum_{i=1}^n { e^{ -\frac{ (x- x_{i} )^{2} }{2 h^{2} } } } $。

在下述代码中绘制了三条曲线，红色粗线为概率密度函数；两条细线均为核密度估计（高斯核），只是蓝色线是依据核密度公式直接编写代码，并设置带宽h=0.4；绿色线则是使用scipy库下的`stats.gaussian_kde()`方法计算高斯核密度估计。

> 非参数统计（Nonparametric Statistics）是统计的一个分支，但不是完全基于参数化的概率分布，例如通过参数均值和方差（或标准差）定义一个正态分布，非参数统计基于自由分布（distribution-free）或指定的分布但未给分布参数，例如当处理PDF的一般情况时，不能像正态分布那样给定参数进行分类。其基本思想是在尽可能少的假定时，利用数据对一个未知量做出推断，通常意味着利用具有无穷维的统计模型。 

> 对于核密度估计名词中密度一词可以形象理解为下图中橄榄绿小竖线的分布密度。

参考：Wikipedia以及 Larry Wasserman.All of nonparametric statistics.Springer (October 21, 2005)；中文版为：[美]Larry Wasserman.吴喜之译.现代非参数统计[M].科学出版社,北京.2008.5；Urmila Diwekar,Amy David.Bonus algorithm for large scale stochastic nonlinear programming problems.Springer; 2015 edition (March 5, 2015)


```python
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt
import math

x=np.linspace(stats.norm.ppf(0.001,loc=0,scale=1),stats.norm.ppf(0.999,loc=0,scale=1), 100) #等分概率为0.1%到99.9%之间的数值。如果不给参数loc和scale,则默认为标准正态分布，即loc=0, scale=1
pdf=stats.norm.pdf(x)

plt.figure(figsize=(25,5))
plt.plot(x,pdf,'r-', lw=5, alpha=0.6, label='norm_pdf')

random_variates=stats.norm.rvs(loc=0,scale=1,size=500)
count, bins, ignored =plt.hist(random_variates,bins=100,density=True,histtype='stepfilled',alpha=0.2)
plt.eventplot(random_variates,color='y',linelengths=0.03,lineoffsets=0.025) #给定位置画出对应的短线

rVar_sort=np.sort(random_variates)
h=0.4 #带宽（bandwidth,bw）
n=len(rVar_sort)
kde_Gaussian=[sum(math.exp(-1*math.pow(vi-vj,2)/(2*math.pow(h,2))) for vj in rVar_sort)/(h*n*math.sqrt(2*math.pi)) for vi in rVar_sort] #将上述高斯核密度估计公式转换为代码
plt.plot(rVar_sort,kde_Gaussian,'b-', lw=2, alpha=0.6, label='kde_formula,h=%s'%h)

scipyStatsGaussian_kde=stats.gaussian_kde(random_variates)
plt.plot(bins,scipyStatsGaussian_kde(bins),'g-', lw=2, alpha=0.6, label='scipyStatsGaussian_kde')
plt.legend()
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_07.png" height="auto" width="auto" title="caDesign"></a>
    


带宽（bandwidth）影响光滑的程度，下述实验设置不同的值，观察核密度曲线的变化情况。关于最适宜的带宽推断，<em>Bonus algorithm for large scale stochastic nonlinear programming problems</em>第3章，<em>Probability Density Function and Kernel Density Estimation</em>一节中提到一种方法，可以参考。


```python
bws=np.arange(0.1,1,0.2)
colors_kde=['C{}'.format(i) for i in range(len(bws))] #maplotlib，指定颜色
i=0
plt.figure(figsize=(25,5))
for h in bws:
    kde_Gaussian=[sum(math.exp(-1*math.pow(vi-vj,2)/(2*math.pow(h,2))) for vj in rVar_sort)/(h*n*math.sqrt(2*math.pi)) for vi in rVar_sort] #将上述高斯核密度估计公式转换为代码
    plt.plot(rVar_sort,kde_Gaussian,color=colors_kde[i], lw=2, alpha=0.6, label='kde_formula,h=%.2f'%h)
    i+=1
plt.legend()
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_08.png" height="auto" width="auto" title="caDesign"></a>
    


#### 2）多变量（多维数组）的核密度估计

上文叙述了OSM数据处理的方法，并简要的概述了OSM地理空间数据集的结构。OSM的Node标签分类丰富，针对不同的问题可以提取不同标签用于分析。因为标签中的便利设施（amenity）与人们的日常生活栖息相关，包括生计、教育、交通、金融、医疗、娱乐、艺术和文化等，更进一步的分类多达100多类。使用geopandas的gdf.clip(polygon)方法进一步裁切数据到目标区域保存，读取后再提取标签（tags）为amenity的空间点数据，计算核密度估计，查看其分布情况。


```python
import util_misc
import geopandas as gpd

start_time=util_misc.start_time() #start_time()和duration(start_time)函数放置于util_misc.py文件中，方便调用
read_node_gdf=gpd.read_file("./data/OSM_processed/osm_node.gpkg")
util_misc.duration(start_time)
```

    start time: 2021-12-24 21:11:29.190573
    end time: 2021-12-24 21:40:36.262947
    Total time spend:29.12 minutes
    


```python
read_node_gdf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>type</th>
      <th>id</th>
      <th>version</th>
      <th>visible</th>
      <th>ts</th>
      <th>uid</th>
      <th>user</th>
      <th>changeet</th>
      <th>tagLen</th>
      <th>tags</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>node</td>
      <td>219850</td>
      <td>55</td>
      <td>True</td>
      <td>2018-02-20T05:50:28</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>2</td>
      <td>{"highway": "motorway_junction", "ref": "276C"}</td>
      <td>POINT (-87.91012 41.75859)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>node</td>
      <td>219851</td>
      <td>48</td>
      <td>True</td>
      <td>2018-02-20T05:50:29</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>2</td>
      <td>{"highway": "motorway_junction", "ref": "277A"}</td>
      <td>POINT (-87.90764 41.75931)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>node</td>
      <td>219966</td>
      <td>5</td>
      <td>True</td>
      <td>2009-04-04T22:47:50</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>0</td>
      <td>{}</td>
      <td>POINT (-87.91596 43.01149)</td>
    </tr>
    <tr>
      <th>3</th>
      <td>node</td>
      <td>219968</td>
      <td>12</td>
      <td>True</td>
      <td>2015-08-04T05:38:49</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>2</td>
      <td>{"ref": "73B", "highway": "motorway_junction"}</td>
      <td>POINT (-87.92464 43.05606)</td>
    </tr>
    <tr>
      <th>4</th>
      <td>node</td>
      <td>219969</td>
      <td>6</td>
      <td>True</td>
      <td>2009-04-14T00:13:37</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>0</td>
      <td>{}</td>
      <td>POINT (-87.92441 43.05684)</td>
    </tr>
  </tbody>
</table>
</div>



* 使用专项研究中物种-鸟观测分析的边界，裁切OSM的node数据。


```python
chicago_species_study_area_wgs84_fp='./data/Chicago study area_species/chicago_species_study_area_wgs84.shp'
chicago_species_study_area_wgs84=gpd.read_file(chicago_species_study_area_wgs84_fp)
start_time=util_misc.start_time() 
chicago_species_node_gdf=read_node_gdf.clip(chicago_species_study_area_wgs84)
util_misc.duration(start_time)

chicago_species_node_gdf.to_file('./data/OSM_processed/osm_node_4speciesStudy.gpkg',driver='GPKG')
```

    start time: 2021-12-24 21:49:56.113615
    end time: 2021-12-24 22:07:42.284118
    Total time spend:17.77 minutes
    


```python
import geopandas as gpd
osm_node_4speciesStudy=gpd.read_file('./data/OSM_processed/osm_node_4speciesStudy.gpkg')
amenity_poi=osm_node_4speciesStudy[osm_node_4speciesStudy.tags.apply(lambda row: "amenity" in eval(row).keys())] #提取标tags列，含标签"amenity"的所有行
print("Amenity extraction finished!")
```

    Amenity extraction finished!
    

提取仅含"amenity"的行后，数据大幅度减少。


```python
print(
    "the overal data number:",osm_node_4speciesStudy.shape,'\n',
    "the amenity data number:",amenity_poi.shape,'\n',     
     )

import matplotlib.pyplot as plt
Chicago_boundary_city_fp='./data/Chicago boundaries_city/Chicago boundaries_city.shp'
Chicago_boundary_city=gpd.read_file(Chicago_boundary_city_fp)
fig, ax=plt.subplots(figsize=(15,15))
amenity_poi.plot(ax=ax,marker=".",markersize=5,zorder=1)
Chicago_boundary_city.plot(ax=ax,color='none', edgecolor='red',alpha=1,linewidth=5,zorder=2)
plt.show()
```

    the overal data number: (7124076, 11) 
     the amenity data number: (12606, 11) 
    
    


    
<a href=""><img src="./imgs/2_1_2_09.png" height="auto" width="auto" title="caDesign"></a>
    


##### 1. 核密度估计-scipy.stats.gaussian_kde()方法

核密度估计可以平滑多维数据，例如热力图的制作是基于核密度估计的二维平滑，以OSM数据为例，直接使用`scipy.stats.gaussian_kde()`计算点分布的核密度。


```python
import pandas as pd
import numpy as np
from scipy import stats
pd.options.mode.chained_assignment=None

poi_coordinates=np.array([amenity_poi.geometry.x,amenity_poi.geometry.y])
amenity_kernel=stats.gaussian_kde(poi_coordinates) #核密度估计
amenity_poi['amenityKDE']=amenity_kernel(poi_coordinates) 
```

建立地图，打印显示核密度分布。

> mapbox需要连接国外服务器


```python
import plotly.express as px

mapbox_token='pk.eyJ1IjoicmljaGllYmFvIiwiYSI6ImNrYjB3N2NyMzBlMG8yc254dTRzNnMyeHMifQ.QT7MdjQKs9Y6OtaJaJAn0A'
px.set_mapbox_access_token(mapbox_token)
fig=px.scatter_mapbox(amenity_poi,lat=amenity_poi.geometry.y, lon=amenity_poi.geometry.x,color='amenityKDE',color_continuous_scale=px.colors.sequential.PuBuGn,size_max=15,zoom=10)
fig.update_layout(autosize=False,width=800,height=800,)
fig.show()
amenity_poi.head()
```

<a href=""><img src="./imgs/2_1_2_10.jpg" height="auto" width="auto" title="caDesign"></a>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>type</th>
      <th>id</th>
      <th>version</th>
      <th>visible</th>
      <th>ts</th>
      <th>uid</th>
      <th>user</th>
      <th>changeet</th>
      <th>tagLen</th>
      <th>tags</th>
      <th>geometry</th>
      <th>amenityKDE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>51751</th>
      <td>node</td>
      <td>354150593</td>
      <td>2</td>
      <td>True</td>
      <td>2009-08-09T20:12:06</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>7</td>
      <td>{"ele": "185", "name": "Wacker Elementary Scho...</td>
      <td>POINT (-87.64847 41.71624)</td>
      <td>3.342937</td>
    </tr>
    <tr>
      <th>73722</th>
      <td>node</td>
      <td>354128001</td>
      <td>1</td>
      <td>True</td>
      <td>2009-03-01T01:48:33</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>7</td>
      <td>{"ele": "179", "name": "Our Lady School", "ame...</td>
      <td>POINT (-87.56699 41.71559)</td>
      <td>1.879984</td>
    </tr>
    <tr>
      <th>73753</th>
      <td>node</td>
      <td>354247611</td>
      <td>3</td>
      <td>True</td>
      <td>2010-02-17T23:04:22</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>9</td>
      <td>{"ele": "179", "name": "Our Lady Gate of Heave...</td>
      <td>POINT (-87.56671 41.71587)</td>
      <td>1.900003</td>
    </tr>
    <tr>
      <th>75310</th>
      <td>node</td>
      <td>354146543</td>
      <td>1</td>
      <td>True</td>
      <td>2009-03-01T02:23:05</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>7</td>
      <td>{"ele": "187", "name": "Saint Margaret School"...</td>
      <td>POINT (-87.65449 41.71531)</td>
      <td>3.031726</td>
    </tr>
    <tr>
      <th>75906</th>
      <td>node</td>
      <td>354273265</td>
      <td>3</td>
      <td>True</td>
      <td>2010-02-17T23:04:13</td>
      <td>0</td>
      <td></td>
      <td>0</td>
      <td>9</td>
      <td>{"ele": "187", "name": "Saint Margaret of Scot...</td>
      <td>POINT (-87.65505 41.71448)</td>
      <td>2.970502</td>
    </tr>
  </tbody>
</table>
</div>



提取'amenity'字段，查看分类，并单独计算'restaurant'的核密度。


```python
amenity_poi['amenity']=amenity_poi.tags.apply(lambda row:eval(row)["amenity"])
print("服务设施子类：\n",amenity_poi.amenity.unique())
```

    服务设施子类：
     ['school' 'place_of_worship' 'fountain' 'fuel' 'bank' 'parking'
     'restaurant' 'fire_station' 'bar' 'bureau_de_change' 'ice_cream'
     'public_building' 'fast_food' 'courthouse' 'bicycle_rental' 'pharmacy'
     'atm' 'clinic' 'social_facility' 'drinking_water' 'vending_machine'
     'money_transfer' 'dentist' 'cafe' 'bicycle_parking' 'bench' 'theatre'
     'waste_basket' 'recycling' 'parking_entrance' 'social_centre'
     'arts_centre' 'car_wash' 'post_box' 'bicycle_repair_station' 'cinema'
     'pub' 'car_sharing' 'shower' 'community_centre' 'car_rental' 'toilets'
     'veterinary' 'post_office' 'marketplace' 'boat_rental' 'photo_booth'
     'charging_station' 'taxi' 'food_court' 'police' 'loading_dock' 'library'
     'venue' 'nightclub' 'hospital' 'dojo' 'shelter' 'ferry_terminal'
     'doctors' 'college' 'studio' 'embassy' 'university' 'events_venue'
     'clock' 'retail' 'internet_cafe' 'driving_school' 'health_center'
     'parking_space' 'research_institute' 'bus_station' 'kindergarten'
     'townhall' 'community_center' 'Auto Repair Shop' 'public_bookcase'
     'public_bath' 'device_charging_station' 'book_return' 'animal_boarding'
     'childcare' 'music_school' 'dancing_school' 'Community Center' 'dental'
     'grave_yard' 'telephone' 'language_school' 'prep_school' 'spa' 'gym'
     'animal_shelter' 'payment_centre' 'salon' 'dance_theater' 'brewery'
     'water_point' 'bbq' 'gymnasium' 'waste_disposal' 'music_venue' 'ATM'
     'swimming_pool' 'payment_terminal' 'child_care']
    


```python
restaurant_df=amenity_poi.loc[amenity_poi.amenity=='restaurant']
restaurant_coordinates=np.array([restaurant_df.geometry.x,restaurant_df.geometry.y])
restaurant_kernel=stats.gaussian_kde(restaurant_coordinates) 
restaurant_df['restaurant_kde']=restaurant_kernel(restaurant_coordinates)

import plotly.express as px
mapbox_token='pk.eyJ1IjoicmljaGllYmFvIiwiYSI6ImNrYjB3N2NyMzBlMG8yc254dTRzNnMyeHMifQ.QT7MdjQKs9Y6OtaJaJAn0A'
px.set_mapbox_access_token(mapbox_token)
fig=px.scatter_mapbox(restaurant_df,lat=restaurant_df.geometry.y, lon=restaurant_df.geometry.x,color='amenityKDE',color_continuous_scale=px.colors.sequential.PuBuGn,size_max=15,zoom=10)
fig.update_layout(autosize=False,width=800,height=800,)
fig.show()
```

<a href=""><img src="./imgs/2_1_2_11.jpg" height="auto" width="auto" title="caDesign"></a>

##### 2. 核密度估计结果转换为地理栅格数据

在地图表达上，上述二维地理空间点的核密度估计最终的计算值落在了点位置本身。如果希望能够以栅格的形式显示估计值，可以将其转换为栅格数据，本质上就是地理空间点数据转栅格数据。在下述的方法中，提供了两种转换方式，一种方式是将存储有核密度估计值的GeoDataFrame格式数据先直接使用`gdf.to_file()`存储为.shp格式的点数据，然后定义.shp转栅格的函数；第二种方式是直接定义一个函数，能够直接计算核密度估计并同时直接存储为栅格数据。

__EPSG编号体系__

在这两种方式中均需要定义GeoDataFrame格式数据的坐标投影，并提取信息用于使用GDAL库提取或定义坐标投影，因此必须在geopandas库和GDAL库之间有可以互相转换的共同的坐标体系，EPSG编号体系是比较好的选择。EPSG（European Petroleum Survey Group）最早建立了该编码体系，其中最为重要的编码包括：

EPSG:4326 - 即WGS84，广泛应用于地图和导航系统，在地理空间数据分析中，这个地理坐标系统是最为基础表征位置数据的坐标系统，通常各类地理空间的数据信息都以WGS84为基本的坐标系统，而后可以在不同数据类型或者平台，以及根据分析目的的不同，尤其实际地理位置的变化来配置投影。

EPSG:3857 - 伪墨卡托投影，也被称为球体墨卡托，用于显示许多基于网页的地图工具，包括Google地图和OpenStreetMap等。

关于EPSG编码可以查看：[spatialreference](https://spatialreference.org/)，和[epsg.io](https://epsg.io/)

本次实验输出栅格的坐标投影系统为EPSG:32616，即WGS 84 / UTM zone 16N，对应芝加哥城Landsat遥感影像所使用的坐标投影系统。通常在分析某一城市空间问题时，可能用到很多类型的，不同来源的数据，尽量以最基本的WGS84作为数据存储坐标系统之外，数据的显示往往需要对应区域的坐标系统，从而优化显示结果，适宜阅读。

* .shp格式地理空间点数据转栅格数据

注意在定义字段名时，如果写入.shp格式数据后，字段名有可能被裁切，例如如果定义字段名为“amenity_kde”，那么用geopandas存储为.shp后，字段名可能被裁切为"amenity_kd"，如果读取该数据，不注意字段名的变化，可能带来不易察觉的错误。


```python
import geopandas as gpd
from pyproj import CRS
import os

print("original projection:",amenity_poi.crs)
amenity_poi_copy=amenity_poi.copy(deep=True)
amenity_poi_copy=amenity_poi.to_crs(CRS("EPSG:32616"))  #EPSG:32616 - WGS 84 / UTM zone 16N - Projected
print("re-projecting:",amenity_poi_copy.crs)

amenity_kde_fn='./data_processed/amenity_kde/amenity_kde.shp'
amenity_poi_copy.to_file(amenity_kde_fn)
```

    original projection: epsg:4326
    re-projecting: EPSG:32616
    

该函数定义的核心是GDAL库提供的`gdal.RasterizeLayer()`方法，可以将读取的.shp点层属性字段的值写入对应位置的栅格，避免编写对位栅格单元位置和字段值数组的代码。在栅格投影定义上直接提取.shp点数据的坐标投影系统，代码位置于向栅格单元写入数据之后，如果位于之前，则会出现坐标投影错误。在栅格定义时，空值通常设置为-9999。GDAL提供栅格定义的方式为先获取栅格驱动`gdal.GetDriverByName('GTiff')`，再建立`.Create(raster_path, x_res, y_res, 1, gdal.GDT_Float64)`。并配置地理变换`target_ds.SetGeoTransform((x_min, cellSize, 0, y_max, 0, -cellSize))`，通过读取栅格波段`band=target_ds.GetRasterBand(1)`，向其写入值`band.WriteArray()`完成栅格的定义。地理变换中，因为地图通常向上为北向，因此第3和第5个参数通常配置为0。


```python
def pts2raster(pts_shp,raster_path,cellSize,field_name=False):
    #将点数据写入为raster数据。使用raster.SetGeoTransform,栅格化数据。参考GDAL官方代码
    from osgeo import gdal, ogr,osr
    '''
    function - 将.shp格式的点数据转换为.tif栅格(raster)
    
    Paras:
        pts_shp - .shp格式点数据文件路径
        raster_path - 保存的栅格文件路径
        cellSize - 栅格单元大小
        field_name - 写入栅格的.shp点数据属性字段
    '''
    #定义空值（没有数据）的栅格数值 Define NoData value of new raster
    NoData_value=-9999
    
    #打开.shp点数据，并返回地理区域范围 Open the data source and read in the extent
    source_ds=ogr.Open(pts_shp)
    source_layer=source_ds.GetLayer()
    x_min, x_max, y_min, y_max=source_layer.GetExtent()
    
    #使用GDAL库建立栅格 Create the destination data source
    x_res=int((x_max - x_min) / cellSize)
    y_res=int((y_max - y_min) / cellSize)
    target_ds=gdal.GetDriverByName('GTiff').Create(raster_path, x_res, y_res, 1, gdal.GDT_Float64) #create(filename,x_size,y_size,band_count,data_type,creation_options)。gdal的数据类型 gdal.GDT_Float64,gdal.GDT_Int32...
    target_ds.SetGeoTransform((x_min, cellSize, 0, y_max, 0, -cellSize))
    outband=target_ds.GetRasterBand(1)
    outband.SetNoDataValue(NoData_value)

    #向栅格层中写入数据
    if field_name:
        gdal.RasterizeLayer(target_ds,[1], source_layer,options=["ATTRIBUTE={0}".format(field_name)])
    else:
        gdal.RasterizeLayer(target_ds,[1], source_layer,burn_values=[-1])   
        
    #配置投影坐标系统
    spatialRef=source_layer.GetSpatialRef()
    target_ds.SetProjection(spatialRef.ExportToWkt())       
        
    outband.FlushCache()
    return gdal.Open(raster_path).ReadAsArray()

amenity_kde_fn='./data_processed/amenity_kde/amenity_kde.shp'
raster_path='./data_processed/amenity_epsg32616.tif'
cellSize=300
field_name='amenityKDE'
poiRaster_array=pts2raster(amenity_kde_fn,raster_path,cellSize,field_name)
print("conversion completed!")
```

    conversion completed!
    

python中处理栅格数据的库可以使用[rasterio](https://rasterio.readthedocs.io/en/latest/quickstart.html#reading-raster-data)，相比GDAL能够大幅度减少代码的数量，其方法也更便捷。用该库读取栅格数据的相关信息，并读取数据为数组（array，并打印栅格查看数据。

> 如果环境中已经安装了geopandas，再安装rasterio（`conda install -c conda-forge rasterio`）后运行代码如果提示错误，可以新建环境安装rasterio


```python
import rasterio
raster_path='./data_processed/amenity_epsg32616.tif'
dataset=rasterio.open(raster_path)
print(
    "band count:",dataset.count,'\n', #查看栅格波段数量
    "columns wide:",dataset.width,'\n', #查看栅格宽度
    "rows hight:",dataset.height,'\n', #查看栅格高度
    "dataset's index and data type:",{i: dtype for i, dtype in zip(dataset.indexes, dataset.dtypes)},'\n',#查看波段及其数据类型
    "bounds:",dataset.bounds,'\n', #查看外接矩形边界左下角与右上角坐标
    "geospatial transform:",dataset.transform,'\n', #数据集的地理空间变换
    "lower right corner:",dataset.transform*(dataset.width,dataset.height),'\n', #计算外接矩形边界右下角坐标
    "crs:",dataset.crs,'\n', #地理坐标投影系统
    "band's index number:",dataset.indexes,'\n' #栅格层（波段）索引
    )
band1=dataset.read(1) #读取栅格波段数据为数组
print(band1)
```

    band count: 1 
     columns wide: 134 
     rows hight: 190 
     dataset's index and data type: {1: 'float64'} 
     bounds: BoundingBox(left=416035.55653533165, bottom=4607564.55138286, right=456235.55653533165, top=4664564.55138286) 
     geospatial transform: | 300.00, 0.00, 416035.56|
    | 0.00,-300.00, 4664564.55|
    | 0.00, 0.00, 1.00| 
     lower right corner: (456235.55653533165, 4607564.55138286) 
     crs: EPSG:32616 
     band's index number: (1,) 
    
    [[-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ... -9.99900000e+03
      -9.99900000e+03 -9.99900000e+03]
     [-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ... -9.99900000e+03
      -9.99900000e+03 -9.99900000e+03]
     [-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ... -9.99900000e+03
      -9.99900000e+03 -9.99900000e+03]
     ...
     [-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ... -9.99900000e+03
      -9.99900000e+03 -9.99900000e+03]
     [-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ...  5.85025771e-01
      -9.99900000e+03  4.76761650e-01]
     [-9.99900000e+03 -9.99900000e+03 -9.99900000e+03 ... -9.99900000e+03
      -9.99900000e+03 -9.99900000e+03]]
    


```python
from rasterio.plot import show
import matplotlib.pyplot as plt

plt.figure(figsize=(15,10))
show((dataset,1),cmap='Greens') 
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_12.png" height="auto" width="auto" title="caDesign"></a>
    


rasterio库支持的颜色(基本同matplotlib库，可以在该库查看具体名称对应的颜色带)： 'Accent', 'Accent_r', 'Blues', 'Blues_r', 'BrBG', 'BrBG_r', 'BuGn', 'BuGn_r', 'BuPu', 'BuPu_r', 'CMRmap', 'CMRmap_r', 'Dark2', 'Dark2_r', 'GnBu', 'GnBu_r', 'Greens', 'Greens_r', 'Greys', 'Greys_r', 'OrRd', 'OrRd_r', 'Oranges', 'Oranges_r', 'PRGn', 'PRGn_r', 'Paired', 'Paired_r', 'Pastel1', 'Pastel1_r', 'Pastel2', 'Pastel2_r', 'PiYG', 'PiYG_r', 'PuBu', 'PuBuGn', 'PuBuGn_r', 'PuBu_r', 'PuOr', 'PuOr_r', 'PuRd', 'PuRd_r', 'Purples', 'Purples_r', 'RdBu', 'RdBu_r', 'RdGy', 'RdGy_r', 'RdPu', 'RdPu_r', 'RdYlBu', 'RdYlBu_r', 'RdYlGn', 'RdYlGn_r', 'Reds', 'Reds_r', 'Set1', 'Set1_r', 'Set2', 'Set2_r', 'Set3', 'Set3_r', 'Spectral', 'Spectral_r', 'Wistia', 'Wistia_r', 'YlGn', 'YlGnBu', 'YlGnBu_r', 'YlGn_r', 'YlOrBr', 'YlOrBr_r', 'YlOrRd', 'YlOrRd_r', 'afmhot', 'afmhot_r', 'autumn', 'autumn_r', 'binary', 'binary_r', 'bone', 'bone_r', 'brg', 'brg_r', 'bwr', 'bwr_r', 'cividis', 'cividis_r', 'cool', 'cool_r', 'coolwarm', 'coolwarm_r', 'copper', 'copper_r', 'cubehelix', 'cubehelix_r', 'flag', 'flag_r', 'gist_earth', 'gist_earth_r', 'gist_gray', 'gist_gray_r', 'gist_heat', 'gist_heat_r', 'gist_ncar', 'gist_ncar_r', 'gist_rainbow', 'gist_rainbow_r', 'gist_stern', 'gist_stern_r', 'gist_yarg', 'gist_yarg_r', 'gnuplot', 'gnuplot2', 'gnuplot2_r', 'gnuplot_r', 'gray', 'gray_r', 'hot', 'hot_r', 'hsv', 'hsv_r', 'inferno', 'inferno_r', 'jet', 'jet_r', 'magma', 'magma_r', 'nipy_spectral', 'nipy_spectral_r', 'ocean', 'ocean_r', 'pink', 'pink_r', 'plasma', 'plasma_r', 'prism', 'prism_r', 'rainbow', 'rainbow_r', 'seismic', 'seismic_r', 'spring', 'spring_r', 'summer', 'summer_r', 'tab10', 'tab10_r', 'tab20', 'tab20_r', 'tab20b', 'tab20b_r', 'tab20c', 'tab20c_r', 'terrain', 'terrain_r', 'twilight', 'twilight_r', 'twilight_shifted', 'twilight_shifted_r', 'viridis', 'viridis_r', 'winter', 'winter_r'

在QGI中打开栅格数据查看结果。该部分的栅格化过程，开始配置了空值为，`outband.SetNoDataValue(-9999)`，后续向栅格写入数据时，仅含有值的位置替换原空值，因此，所看到的栅格空值部分透明。

<a href=""><img src="./imgs/2_1_2_03.png" height="auto" width="600" title="caDesign"></a>

* 给定GeoDataFrame格式的地理空间点数据，计算核密度估计存储为栅格数据

下述函数的定义将核密度估计置于函数之内，可以传入GeoDataFrame格式地理空间点数据（pts_gdf），给定保存位置（raster_path），栅格单元大小（cellSize），以及调整核密度估计值比例缩放因子（scale）直接获取最后的核密度估计值栅格图（热力图）。这种计算方法能够减少中间步骤，不需先转换为.shp格式的点数据后再存储为栅格数据。但是这种将多个步骤置于一个函数中的计算方式，会将“单步”的计算时长拉长，因此最好在函数内通过print()函数打印相关完成信息，避免大批量数据计算时，不知道完成进度，无法确定程序是否仍在正常运行，或者已经完成，甚至已经中断。

GDAL库提供建立栅格，向栅格单元写入数值的方法是outband.WriteArray()，传入的参数为数组，这个数组对应着栅格的位置，因此计算完核密度估计之后，定义提取估计值的位置坐标需要重新进行定义，而不能直接用点坐标。在位置（positions）定义上借助np.meshgrid()实现，同时需要注意上述定义的positions位置提取估计值，其顺序是逆反的，即由下往上逐行读取，这个通常符合对图片像素的定义顺序，在地理栅格数据中，通常是由上往下写入，因此用np.flip(Z,0)翻转数组，将最后一行提为正数第一行，倒数第二行为正数第二行，以此类推。


```python
def ptsKDE_geoDF2raster(pts_geoDF,raster_path,cellSize,scale):
    from osgeo import gdal,ogr,osr
    import numpy as np
    from scipy import stats
    '''
    function - 计算GeoDaraFrame格式的点数据核密度估计，并转换为栅格数据
    
    Paras:
        pts_geoDF - GeoDaraFrame格式的点数据
        raster_path - 保存的栅格文件路径
        cellSize - 栅格单元大小
        scale - 缩放核密度估计值
    '''
    #定义空值（没有数据）的栅格数值 Define NoData value of new raster
    NoData_value=-9999
    x_min, y_min,x_max, y_max=pts_geoDF.geometry.total_bounds

    #使用GDAL库建立栅格 Create the destination data source
    x_res=int((x_max - x_min) / cellSize)
    y_res=int((y_max - y_min) / cellSize)
    target_ds=gdal.GetDriverByName('GTiff').Create(raster_path, x_res, y_res, 1, gdal.GDT_Float64 )
    target_ds.SetGeoTransform((x_min, cellSize, 0, y_max, 0, -cellSize))
    outband=target_ds.GetRasterBand(1)
    outband.SetNoDataValue(NoData_value)   
    
    #配置投影坐标系统
    spatialRef = osr.SpatialReference()
    epsg=int(pts_geoDF.crs.srs.split(":")[-1])
    spatialRef.ImportFromEPSG(epsg)  
    target_ds.SetProjection(spatialRef.ExportToWkt())
    
    #向栅格层中写入数据
    #print(x_res,y_res)
    X, Y = np.meshgrid(np.linspace(x_min,x_max,x_res), np.linspace(y_min,y_max,y_res)) #用于定义提取核密度估计值的栅格单元坐标数组
    positions=np.vstack([X.ravel(), Y.ravel()])
    values=np.vstack([pts_geoDF.geometry.x, pts_geoDF.geometry.y])    
    print("Start calculating kde...")
    kernel=stats.gaussian_kde(values)
    Z=np.reshape(kernel(positions).T, X.shape)
    print("Finish calculating kde!")
    #print(values)
        
    outband.WriteArray(np.flip(Z,0)*scale) #需要翻转数组，写栅格单元        
    outband.FlushCache()
    print("conversion has completed!")
    return gdal.Open(raster_path).ReadAsArray()
    
raster_path_gpd='./data_processed/amenity_kde_gdf.tif'
cellSize=500 #cellSize值越小，需要计算的时间越长，开始调试时，可以尝试将其调大以节约计算时间
scale=10**10 #相当于math.pow(10,10)
poiRasterGeoDF_array=ptsKDE_geoDF2raster(amenity_poi_copy,raster_path_gpd,cellSize,scale)   
```

    Start calculating kde...
    Finish calculating kde!
    conversion has completed!
    


```python
import rasterio
dataset_gpd=rasterio.open(raster_path_gpd)

from rasterio.plot import show
import matplotlib.pyplot as plt
#plt.figure(figsize=(8,8))
fig, axs=plt.subplots(1,2,figsize=(10, 10))

show((dataset_gpd,1),contour=True,cmap='Greens',ax=axs[0]) #开启等高线模式
show((dataset_gpd,1),cmap='Greens',ax=axs[1])
axs[0].tick_params(axis='x', rotation=90)
axs[1].tick_params(axis='x', rotation=90)
plt.show()
```


    
<a href=""><img src="./imgs/2_1_2_13.png" height="auto" width="auto" title="caDesign"></a>
    

