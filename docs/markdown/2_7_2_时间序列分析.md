> Created on Wed Nov  9 20:34:28 2022  @author: Richie Bao-caDesign设计(cadesign.cn)

## 2.7.2 时间序列分析


### 2.7.2.1 AoT预处理后温度数据读取与时间序列图表打印

AoT预处理后温度数据时间跨度为2020年12个月，时间精度为1小时，庞大的数据量很难通过对数据的直接查看洞悉数据整体概况和局部变化情况，因此需要借助图表形式直观观察。查看数据的目的初步包括：1，不同节点时间轴向上的温度数值变化，可以观察不同时间尺度的数值变化（例如小时、日、周或月，和任意时间区段等）。通常因为节点位置环境不同，不同节点温度变化应存在差异；2，查看各个节点测量数值的时间轴向分布区段。一方面，确定单独节点轴向上测量数据的时间跨度和断续情况，较高的跨度和连续度有利于处理潜在更多的数据分析内容和更高的分析精度。再者，纵向上观察各节点测量数据的对应情况，如果同一时间段更多的节点均具有数据，这有利于节点间影响因素的分析；3，需要能够通过节点测量值观察图表，对应到目标节点空间分布位置，确定节点所在环境，对应城市相关空间因素（例如建筑分布和高度、植被覆盖度、节点所在全景图等），分析测量值的空间因素和空间关系，及时空分析等。

参数管理使用`AttrDict()`方法（具体查看“Cityscapes数据集——参数管理”一节），首先配置读写PostgreSQL数据库参数于`db`子属性下，并读取在“城市环境传感器AoT（SAGE）数据预处理”一节中预处理写入到数据库表名为“temperature”的温度数据。


```python
from database import postSQL2gpd,gpd2postSQL
from util_misc import AttrDict
__C=AttrDict() 
args=__C

__C.db=AttrDict() 
__C.db.UN='postgres'
__C.db.PW='123456'
__C.db.DB='AoT_20220831'
__C.db.GC='geometry' 
__C.db.db_info=dict(geom_col=args.db.GC,myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB)
```


```python
aot_temperature_gdf=postSQL2gpd(table_name="temperature",geom_col=args.db.GC,myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB)
print(f"aot_temperature_gdf rows:{len(aot_temperature_gdf)}")
aot_temperature_gdf.head(3)
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is temperature.
    aot_temperature_gdf rows:523877
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timestamp</th>
      <th>node_id</th>
      <th>subsystem</th>
      <th>sensor</th>
      <th>parameter</th>
      <th>value_hrf_sum</th>
      <th>value_hrf_count</th>
      <th>value_hrf_average</th>
      <th>value_hrf_min</th>
      <th>value_hrf_max</th>
      <th>project_id</th>
      <th>vsn</th>
      <th>address</th>
      <th>lat</th>
      <th>lon</th>
      <th>description</th>
      <th>start_timestamp</th>
      <th>end_timestamp</th>
      <th>geometry</th>
      <th>ts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06112e77</td>
      <td>lightsense</td>
      <td>tmp421</td>
      <td>temperature</td>
      <td>-8.52</td>
      <td>142</td>
      <td>-0.060</td>
      <td>-0.06</td>
      <td>-0.06</td>
      <td>AoT_Chicago</td>
      <td>06B</td>
      <td>Ashland Ave &amp; 59th St Chicago IL</td>
      <td>41.786756</td>
      <td>-87.664343</td>
      <td>AoT Chicago (S) [C]</td>
      <td>2018/02/26 00:00:00</td>
      <td>None</td>
      <td>POINT (444797.242 4626313.694)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e061183bf</td>
      <td>metsense</td>
      <td>htu21d</td>
      <td>temperature</td>
      <td>-203.42</td>
      <td>143</td>
      <td>-1.423</td>
      <td>-1.58</td>
      <td>-1.21</td>
      <td>AoT_Chicago</td>
      <td>11A</td>
      <td>ComEd Training Center</td>
      <td>41.829806</td>
      <td>-87.659467</td>
      <td>AoT Chicago (S) [CP] {ComEd}</td>
      <td>2019/04/25 00:00:00</td>
      <td>None</td>
      <td>POINT (445239.085 4631090.243)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e061183bf</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>-143.40</td>
      <td>143</td>
      <td>-1.003</td>
      <td>-1.25</td>
      <td>-0.65</td>
      <td>AoT_Chicago</td>
      <td>11A</td>
      <td>ComEd Training Center</td>
      <td>41.829806</td>
      <td>-87.659467</td>
      <td>AoT Chicago (S) [CP] {ComEd}</td>
      <td>2019/04/25 00:00:00</td>
      <td>None</td>
      <td>POINT (445239.085 4631090.243)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
  </tbody>
</table>
</div>



用于同一测量内容的传感器，通常有多个不同类型，因为不同类型传感器的测量精度不同，同一时间下不同传感器测量值存在差异，例如测量温度的传感器由字段`subsystem`和`sensor`确定，通过读取“sensors.csv”文件，提取`parameter`字段为`temperature`值，可以查看测量温度包含的所有传感器类型。


```python
import pandas as pd

AoT_sensors_fp='./data/AoT_Chicago.complete.2022-08-31/sensors.csv'
AoT_sensors=pd.read_csv(AoT_sensors_fp)
AoT_sensors_temperature=AoT_sensors[AoT_sensors["parameter"]=="temperature"]
AoT_sensors_temperature
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ontology</th>
      <th>subsystem</th>
      <th>sensor</th>
      <th>parameter</th>
      <th>hrf_unit</th>
      <th>hrf_minval</th>
      <th>hrf_maxval</th>
      <th>datasheet</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>26</th>
      <td>/sensing/meteorology/temperature</td>
      <td>metsense</td>
      <td>bmp180</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>85.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>27</th>
      <td>/sensing/meteorology/temperature</td>
      <td>metsense</td>
      <td>htu21d</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>28</th>
      <td>/sensing/meteorology/temperature</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>C</td>
      <td>-55.0</td>
      <td>80.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>29</th>
      <td>/sensing/meteorology/temperature</td>
      <td>metsense</td>
      <td>tmp112</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>30</th>
      <td>/sensing/meteorology/temperature</td>
      <td>metsense</td>
      <td>tsys01</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>57</th>
      <td>/system/environment/temperature</td>
      <td>lightsense</td>
      <td>hih6130</td>
      <td>temperature</td>
      <td>C</td>
      <td>-25.0</td>
      <td>85.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>59</th>
      <td>/system/environment/temperature</td>
      <td>wagman</td>
      <td>htu21d</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>65</th>
      <td>/system/environment/temperature</td>
      <td>lightsense</td>
      <td>tmp421</td>
      <td>temperature</td>
      <td>C</td>
      <td>-55.0</td>
      <td>127.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>74</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>lps25h</td>
      <td>temperature</td>
      <td>C</td>
      <td>-30.0</td>
      <td>105.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
    <tr>
      <th>76</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>at0</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors</td>
    </tr>
    <tr>
      <th>77</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>at1</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors</td>
    </tr>
    <tr>
      <th>78</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>at2</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors</td>
    </tr>
    <tr>
      <th>79</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>at3</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors</td>
    </tr>
    <tr>
      <th>80</th>
      <td>/system/other/temperature</td>
      <td>chemsense</td>
      <td>sht25</td>
      <td>temperature</td>
      <td>C</td>
      <td>-40.0</td>
      <td>125.0</td>
      <td>https://github.com/waggle-sensor/sensors/raw/m...</td>
    </tr>
  </tbody>
</table>
</div>



为了查看不同温度传感器的测量值，提取同一节点，例如`001e06113107`，截取开始的`2020/01/01 00:30:00`时间段测量值，可以初步查看得知部分传感器测量值均值`value_hrf_average`偏高，例如“bmp180”为7.773、“hih6130”为4.674等，且各个时间段获取测量值的各类传感器类型可能不同，因此直接用所有各类传感器的测量值做分析可能并不准确。同时，从各个传感器获取的数据量存在差异，例如“pr103j2”采样数为85584条，而“tsys01”为46351条。因此，需要均衡上述各影响因素，确定提取一类传感器测量值或者组合几类用于分析。


```python
t_sample_nodeID=aot_temperature_gdf[aot_temperature_gdf["node_id"]=="001e06113107"]
t_sample_nodeID[:11]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timestamp</th>
      <th>node_id</th>
      <th>subsystem</th>
      <th>sensor</th>
      <th>parameter</th>
      <th>value_hrf_sum</th>
      <th>value_hrf_count</th>
      <th>value_hrf_average</th>
      <th>value_hrf_min</th>
      <th>value_hrf_max</th>
      <th>project_id</th>
      <th>vsn</th>
      <th>address</th>
      <th>lat</th>
      <th>lon</th>
      <th>description</th>
      <th>start_timestamp</th>
      <th>end_timestamp</th>
      <th>geometry</th>
      <th>ts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>97</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>chemsense</td>
      <td>at0</td>
      <td>temperature</td>
      <td>-203.57</td>
      <td>142</td>
      <td>-1.434</td>
      <td>-1.71</td>
      <td>-1.24</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>98</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>chemsense</td>
      <td>at1</td>
      <td>temperature</td>
      <td>-165.22</td>
      <td>142</td>
      <td>-1.164</td>
      <td>-1.46</td>
      <td>-0.95</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>99</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>chemsense</td>
      <td>at2</td>
      <td>temperature</td>
      <td>-90.47</td>
      <td>142</td>
      <td>-0.637</td>
      <td>-0.97</td>
      <td>-0.38</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>100</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>chemsense</td>
      <td>at3</td>
      <td>temperature</td>
      <td>-17.60</td>
      <td>142</td>
      <td>-0.124</td>
      <td>-0.49</td>
      <td>0.15</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>101</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>chemsense</td>
      <td>lps25h</td>
      <td>temperature</td>
      <td>392.73</td>
      <td>142</td>
      <td>2.766</td>
      <td>2.43</td>
      <td>3.02</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>102</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>lightsense</td>
      <td>hih6130</td>
      <td>temperature</td>
      <td>663.73</td>
      <td>142</td>
      <td>4.674</td>
      <td>4.50</td>
      <td>4.86</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>103</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>lightsense</td>
      <td>tmp421</td>
      <td>temperature</td>
      <td>271.96</td>
      <td>142</td>
      <td>1.915</td>
      <td>1.75</td>
      <td>2.12</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>104</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>metsense</td>
      <td>bmp180</td>
      <td>temperature</td>
      <td>1103.80</td>
      <td>142</td>
      <td>7.773</td>
      <td>7.40</td>
      <td>8.20</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>105</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>metsense</td>
      <td>htu21d</td>
      <td>temperature</td>
      <td>-189.98</td>
      <td>142</td>
      <td>-1.338</td>
      <td>-1.69</td>
      <td>-0.95</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>106</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>-256.60</td>
      <td>142</td>
      <td>-1.807</td>
      <td>-2.35</td>
      <td>-1.35</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>107</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06113107</td>
      <td>metsense</td>
      <td>tsys01</td>
      <td>temperature</td>
      <td>-192.52</td>
      <td>142</td>
      <td>-1.356</td>
      <td>-1.79</td>
      <td>-0.79</td>
      <td>AoT_Chicago</td>
      <td>072</td>
      <td>7801 S Lawndale Ave Chicago IL</td>
      <td>41.751142</td>
      <td>-87.71299</td>
      <td>AoT Chicago (S) [CA] {ComEd}</td>
      <td>2017/01/01 00:00:00</td>
      <td>None</td>
      <td>POINT (440722.179 4622392.015)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
  </tbody>
</table>
</div>



这里提取`subsystem`为`metsense`，`sensor`为`pr103j2`的采样数据用于分析。定义`__C`的子属性`aot`，用于存储传感器相关信息。


```python
__C.aot=AttrDict() 
__C.aot.subsystem="metsense" 
__C.aot.sensor="pr103j2" #"tsys01"（46351条） "tmp112"（41326条） "pr103j2"（85584条） "htu21d"（45864条） "bmp180"（测量数据不准确） 

aot_temperature_subsystemNsensor_gdf=aot_temperature_gdf[(aot_temperature_gdf.subsystem==args.aot.subsystem)&(aot_temperature_gdf.sensor==args.aot.sensor)]
print(f"aot_temperature_subsystemNsensor_gdfrows:{len(aot_temperature_subsystemNsensor_gdf)}")
gpd2postSQL(aot_temperature_subsystemNsensor_gdf,table_name="temperature_metsense_pr103j2",myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB) 
aot_temperature_subsystemNsensor_gdf.head(3)
```

    aot_temperature_subsystemNsensor_gdfrows:85584
    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is temperature_metsense_pr103j2.
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timestamp</th>
      <th>node_id</th>
      <th>subsystem</th>
      <th>sensor</th>
      <th>parameter</th>
      <th>value_hrf_sum</th>
      <th>value_hrf_count</th>
      <th>value_hrf_average</th>
      <th>value_hrf_min</th>
      <th>value_hrf_max</th>
      <th>project_id</th>
      <th>vsn</th>
      <th>address</th>
      <th>lat</th>
      <th>lon</th>
      <th>description</th>
      <th>start_timestamp</th>
      <th>end_timestamp</th>
      <th>geometry</th>
      <th>ts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e061183bf</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>-143.40</td>
      <td>143</td>
      <td>-1.003</td>
      <td>-1.25</td>
      <td>-0.65</td>
      <td>AoT_Chicago</td>
      <td>11A</td>
      <td>ComEd Training Center</td>
      <td>41.829806</td>
      <td>-87.659467</td>
      <td>AoT Chicago (S) [CP] {ComEd}</td>
      <td>2019/04/25 00:00:00</td>
      <td>None</td>
      <td>POINT (445239.085 4631090.243)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>6</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e06117b41</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>-188.90</td>
      <td>144</td>
      <td>-1.312</td>
      <td>-1.65</td>
      <td>-0.95</td>
      <td>AoT_Chicago</td>
      <td>0BA</td>
      <td>60th &amp; Michigan Ave Chicago IL</td>
      <td>41.785715</td>
      <td>-87.622214</td>
      <td>AoT Chicago (S) [CP]</td>
      <td>2019/05/16 00:00:00</td>
      <td>None</td>
      <td>POINT (448297.079 4626171.925)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
    <tr>
      <th>33</th>
      <td>2020/01/01 00:30:00</td>
      <td>001e0611462f</td>
      <td>metsense</td>
      <td>pr103j2</td>
      <td>temperature</td>
      <td>-622.25</td>
      <td>143</td>
      <td>-4.351</td>
      <td>-4.65</td>
      <td>-3.75</td>
      <td>AoT_Chicago</td>
      <td>081</td>
      <td>Wallace St &amp; Pershing Rd Chicago IL</td>
      <td>41.823527</td>
      <td>-87.641054</td>
      <td>AoT Chicago (S) [C]</td>
      <td>2018/02/27 00:00:00</td>
      <td>None</td>
      <td>POINT (446762.872 4630381.536)</td>
      <td>2020-01-01 00:30:00</td>
    </tr>
  </tbody>
</table>
</div>



首先尝试用`matplotlib`库打印时间序列数据，定义`time_series_plot()`函数。因为一起打印较大的数据量不易观察，因此提供`rolling_window`参数用于数据平滑，这里配置平滑参数为`24*7`。从打印结果来看各个节点因为所处环境不同，同一时间段温度存在差异，但整体数值分布符合冬冷夏暖的变化趋势。


```python
def time_series_plot(df_,datetime_column,val_column,group_column,span=None,rolling_window=None,figsize=(10,10),font_size=10,legend=True,**setting):
    '''
    打印所有列或给定列的时间序列数据。

    Parameters
    ----------
    df_ : DataFrame
        计算数据.
    datetime_column : string
        时间列.
    val_column : string
        数值列.
    group_column : string
        分组（分类）列.     
    span : list(string), optional
        打印时间区间，（表述时间的字符串）. The default is None.
    rolling_window : int, optional
        数据平滑. The default is None.
    figsize : tuple(int,float), optional
        图表大小. The default is (10,10).
    font_size : int or float, optional
        字体大小. The default is 10.
    legend : bool, optional
        是否打印图例. The default is True.
    **setting : kw-argument(string)
        包括xlabel，ylabel，title.

    Returns
    -------
    df_span : DataFrame
        提取时间区间内的数据行.
    '''
    import matplotlib.pyplot as plt
    from pylab import mpl
    import matplotlib.dates as md
    from matplotlib.dates import DayLocator, HourLocator, DateFormatter, drange
    
    plt.rc('axes', unicode_minus=False) # 解决图表负号不正确显示问题
    mpl.rcParams['font.sans-serif']=['SimHei'] # 解决中文字符乱码问题
    plt.figure()
    plt.rcParams.update({'font.size':font_size}) # must set in top    
    
    setting_dict={"xlabel":"X",
                  "ylabel":"Y",
                  "title":None,
                  "xticks_rotation":0
                 }
    setting_dict.update(setting)   
    fig, ax=plt.subplots(figsize=figsize)
    
    df=df_.copy(deep=True)
    df.sort_values(by=[datetime_column],inplace=True)
    df.set_index(datetime_column,inplace=True)    
    
    if span:
        df_span=df[span[0]:span[1]]    
    else:
        df_span=df   
    
    df_selection=df_span[[val_column,group_column]]
    df_selection_group=df_selection.groupby(group_column)
    labels=[]
    for label,g in df_selection_group:  
        labels.append(label)
        g.drop([group_column],axis=1,inplace=True)
        if rolling_window:
            df_span_rolling=g.rolling(rolling_window).mean()     
            df_span_rolling.plot(ax=ax,label=label,legend=legend) 
        else:
            g.plot(ax=ax,label=label,legend=legend) 
            
    # https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set.html    
    ax.set(xlabel=setting_dict["xlabel"],
           ylabel=setting_dict["ylabel"],
           title=setting_dict["title"],
           )  
    if legend:
        ax.legend(labels[:3])
    plt.xticks(rotation=setting_dict["xticks_rotation"])
        
    return df_span
```


```python
_=time_series_plot(aot_temperature_subsystemNsensor_gdf,'ts',"value_hrf_average","node_id",rolling_window=24*7,xlabel="时间",ylabel="温度( °)",figsize=(20,8),font_size=15,legend=True,xticks_rotation=90)
```


    <Figure size 640x480 with 0 Axes>



<img src="./imgs/2_7_2/output_12_1.png" height='auto' width='auto' title="caDesign">    


上述图表仅显示了3个图例用于说明，虽然能够以颜色区分不同节点测量值，但是对于较多的节点数量，并不易于用颜色区分查看各条测量值属于哪一个节点，因此可以借助`Plotly`库提供的交互方式查看数据。同样平滑数据减少干扰，定义函数`df_group_rolling_window()`实现，用`plotly.express.line()`方法打印，当鼠标置于图上某一曲线时，会弹出信息框，其中包括节点ID信息，从而方便直观的查看数据属于哪个节点，及对应的具体时间和温度值为多少。


```python
def df_group_rolling_window(df_,datetime_column,val_column,group_column,rolling_window=24):
    '''
    指定时间列、数值列和分组列，按分组列对数值列执行给定跨度（rolling_window）的数据平滑

    Parameters
    ----------
    df_ : DataFrame
        包含时间列、数值列和分组列的数据.
    datetime_column : string
        时间列.
    val_column : string
        数值列.
    group_column : string
        分组列.
    rolling_window : int, optional
        数据平滑跨度. The default is 24.

    Returns
    -------
    df_selection_group_rolling_resetIdx : DataFrame
        仅保留时间列、数值列和分组列，数据平滑后的数据.

    '''    
    df=df_.copy(deep=True)
    df.sort_values(by=[datetime_column],inplace=True)
    df.set_index(datetime_column,inplace=True)         
    df_selection=df[[val_column,group_column]]
    df_selection_group_rolling=df_selection.groupby(group_column)[val_column].rolling(rolling_window).mean()
    df_selection_group_rolling_resetIdx=df_selection_group_rolling.reset_index()

    return df_selection_group_rolling_resetIdx
    
df_selection_group_rolling_resetIdx=df_group_rolling_window(aot_temperature_subsystemNsensor_gdf,'ts',"value_hrf_average","node_id",rolling_window=24*7)    
df_selection_group_rolling_resetIdx.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>node_id</th>
      <th>ts</th>
      <th>value_hrf_average</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>001e0610ba46</td>
      <td>2020-01-01 00:30:00</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>001e0610ba46</td>
      <td>2020-01-01 01:30:00</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>001e0610ba46</td>
      <td>2020-01-01 02:30:00</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
import plotly.express as px
fig=px.line(df_selection_group_rolling_resetIdx, x="ts", y="value_hrf_average", color='node_id')
fig.update_layout(
    autosize=True,
    # width=1000,
    height=500,
    margin=dict(
        l=50,
        r=50,
        b=50,
        t=50,
        pad=4
    ),
    paper_bgcolor="white",
)
fig.show()
```

<img src="./imgs/2_7_2/output_15_1.png" height='auto' width='auto' title="caDesign">



上述交互图表的方法需要平滑数据，避免不同节点测量值间的干扰，但是平滑后的数据无法查看原始时间精度值的变化，通常只能查看年度、月度或周，较长时间段的变化趋势，因此定义下述`time_series_plotly_range_slider_plot()`函数，使用`Plotly`库提供的窗口滑块缩放X轴向（时间轴向）功能，可以自由调节显示的时间区段，能够查看到最小时间精度（1小时）数值变化情况；也可以显示整个时间跨度，查看整体曲线变化趋势。


```python
def time_series_plotly_range_slider_plot(df_,datetime_column,val_column,group_column,**setting):
    '''
    含时间列，数值列和分组列，按分组打印时间序列数值数据。含显示窗口滑块

    Parameters
    ----------
    df_ : DataFrame
        含时间列，数值列和分组列的数据.
    datetime_column : string
        时间列.
    val_column : string
        数值列.
    group_column : string
        分组列.
    **setting : kw-argument(string)
        包括参数及默认值：
        setting_dict={"margin_l":50,
              "margin_r":50,
              "margin_b":50,
              "margin_t":50,
              "margin_pad":4,
              "paper_bgcolor":"white",
              "fig_height":None,
              "fig_width":None,
              "fig_autosize":True,
              "title_text":""

    Returns
    -------
    None.

    '''    
    import plotly.graph_objects as go
    import pandas as pd
    import numpy as np
    
    setting_dict={"margin_l":50,
                  "margin_r":50,
                  "margin_b":50,
                  "margin_t":50,
                  "margin_pad":4,
                  "paper_bgcolor":"white",
                  "fig_height":None,
                  "fig_width":None,
                  "fig_autosize":True,
                  "title_text":""
                 }
    setting_dict.update(setting)  
    
    fig = go.Figure()
    df_group=df_.groupby(group_column)
    for label,df in df_group:        
        fig.add_trace(go.Scatter(x=df[datetime_column],y=df[val_column],name=label))
        
    fig.update_layout(
        title_text=setting_dict["title_text"],
        autosize=setting_dict["fig_autosize"],
        width=setting_dict["fig_width"],
        height=setting_dict["fig_height"],
        margin=dict(
            l=setting_dict["margin_l"],
            r=setting_dict["margin_r"],
            b=setting_dict["margin_b"],
            t=setting_dict["margin_t"],
            pad=setting_dict["margin_pad"]),
            paper_bgcolor=setting_dict["paper_bgcolor"],
        )
    
    # Add range slider
    fig.update_layout(
        xaxis=dict(
            rangeselector=dict(
                buttons=list([
                    dict(count=1,
                         label="1m",
                         step="month",
                         stepmode="backward"),
                    dict(count=6,
                         label="6m",
                         step="month",
                         stepmode="backward"),
                    dict(count=1,
                         label="YTD",
                         step="year",
                         stepmode="todate"),
                    dict(count=1,
                         label="1y",
                         step="year",
                         stepmode="backward"),
                    dict(step="all")
                ])
            ),
            rangeslider=dict(
                visible=True
            ),
            type="date"
        )
    )        

    fig.show()    
```


```python
import plotly.io as pio
pio.renderers.default="jupyterlab" #包括"browser"，"jupyterlab"，"notebook"...等
time_series_plotly_range_slider_plot(aot_temperature_subsystemNsensor_gdf,"ts", "value_hrf_average", 'node_id',fig_height=700)
```


<img src="./imgs/2_7_2/output_18_0.png" height='auto' width='auto' title="caDesign">    


将在“城市环境传感器AoT（SAGE）数据预处理”一节中定义的`gantt_chart_H()`函数置于模块`util_misc`中调用，打印温度传感器为“pr103j2”所获取的测量值在各个节点上的测量情况，包含“pr103j2”传感器的节点有37个，但是各节点获取的测量数据时间轴向上分布各异，可以发现节点'001e0610f05c'、'001e06113107'具有较连续的测量值，其次为'001e0611462f'和'001e061183bf'等。


```python
from util_misc import gantt_chart_H

aot_temperature_subsystemNsensor_gdf=postSQL2gpd(table_name="temperature_metsense_pr103j2",geom_col=args.db.GC,myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB)
_=gantt_chart_H(aot_temperature_subsystemNsensor_gdf,"node_id","ts")
```

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning: Did not recognize type 'geometry' of column 'geometry'
      pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])
    

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is temperature_metsense_pr103j2.
    category_field number:37
    category_field:
    ['001e061183bf' '001e06117b41' '001e0611462f' '001e06118182'
     '001e06117b44' '001e0610ee43' '001e06113a24' '001e06118295'
     '001e061182a3' '001e0610fb4c' '001e061182a7' '001e06113107'
     '001e061183f5' '001e06113ad8' '001e06118501' '001e0610ba46'
     '001e0610e538' '001e0610f05c' '001e0611804d' '001e061183f3'
     '001e061181e8' '001e061182a2' '001e0610ee36' '001e06112e77'
     '001e0611856d' '001e0611850f' '001e0610e532' '001e0610bc10'
     '001e061183eb' '001e061184a3' '001e06118433' '001e061146ba'
     '001e061146cb' '001e06113ace' '001e06113acb' '001e0610f703'
     '001e0611441e']
    

    100%|██████████| 37/37 [00:00<00:00, 71.44it/s]
    

<img src="./imgs/2_7_2/2_7_2_01.png" height="auto" width="auto" title="caDesign">

根据时间序列数据提供的`node_id`字段，读取AoT数据预处理存入数据库的节点空间分布信息表`AoT_nodes`，在地图上显示包含有“pr103j2”传感器测量值的节点（标识有节点ID文字的点）。也配置有变量`nodes4search`，可以用于标识需要特定查看的节点，以黄底红字加粗显示。下图特定节点为具有良好连续性测量值的节点。


```python
AoT_nodes_gdf=postSQL2gpd(table_name="AoT_nodes",**args.db.db_info)
subsystemNsensor_nodeIDs=aot_temperature_subsystemNsensor_gdf.node_id.unique()
AoT_nodes_gdf["mask_subsystemNsensor"]=AoT_nodes_gdf.node_id.apply(lambda row:1 if row in subsystemNsensor_nodeIDs else 0)
AoT_nodes_gdf.head(3)
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is AoT_nodes.
    

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning:
    
    Did not recognize type 'geometry' of column 'geometry'
    
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>node_id</th>
      <th>project_id</th>
      <th>vsn</th>
      <th>address</th>
      <th>lat</th>
      <th>lon</th>
      <th>description</th>
      <th>start_timestamp</th>
      <th>end_timestamp</th>
      <th>geometry</th>
      <th>mask_subsystemNsensor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>001e0610ba46</td>
      <td>AoT_Chicago</td>
      <td>004</td>
      <td>State St &amp; Jackson Blvd Chicago IL</td>
      <td>41.878377</td>
      <td>-87.627678</td>
      <td>AoT Chicago (S) [C]</td>
      <td>2017/10/09 00:00:00</td>
      <td>None</td>
      <td>POINT (447918.217 4636463.149)</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>001e0610ba3b</td>
      <td>AoT_Chicago</td>
      <td>006</td>
      <td>18th St &amp; Lake Shore Dr Chicago IL</td>
      <td>41.858136</td>
      <td>-87.616055</td>
      <td>AoT Chicago (S)</td>
      <td>2017/08/08 00:00:00</td>
      <td>None</td>
      <td>POINT (448866.515 4634208.863)</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>001e0610f02f</td>
      <td>AoT_Chicago</td>
      <td>00A</td>
      <td>Lake Shore Drive &amp; Fullerton Ave Chicago IL</td>
      <td>41.926261</td>
      <td>-87.630758</td>
      <td>AoT Chicago (S) [CA]</td>
      <td>2018/05/07 00:00:00</td>
      <td>None</td>
      <td>POINT (447701.759 4641781.517)</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
import matplotlib.pyplot as plt
fig, ax=plt.subplots(figsize=(10,15))
Chicago_community_areas=postSQL2gpd(table_name='Chicago_community_areas',**args.db.db_info)  
Chicago_community_areas.plot(ax=ax,color='white', edgecolor='gray')
AoT_nodes_gdf.plot(column='mask_subsystemNsensor',ax=ax,markersize=30,cmap="jet")

nodes4search=['001e06113107','001e0610f05c','001e0611462f','001e061183bf']
for x, y, label in zip(AoT_nodes_gdf.geometry.x, AoT_nodes_gdf.geometry.y, AoT_nodes_gdf.node_id):
    if label in subsystemNsensor_nodeIDs:
        if label in nodes4search:
            ax.annotate(f"+{label}", xy=(x, y), xytext=(3, 3), textcoords="offset points",fontsize=10,color="r",bbox=dict(boxstyle='round,pad=0.2', fc='yellow', alpha=0.3))
        else:
            ax.annotate(label, xy=(x, y), xytext=(3, 3), textcoords="offset points",fontsize=7)
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is Chicago_community_areas.
    


<img src="./imgs/2_7_2/output_24_1.png" height='auto' width='auto' title="caDesign">    



### 2.7.2.2 白噪声检验、平稳性检验和周期性模式判断

#### 1）白噪声检验
如果序列值彼此之间没有任何相关性，过去的行为并不影响将来的行为趋势，则该序列为随机序列，即为白噪声序列。白噪声序列因为数值为随机，通常不具有分析的价值，因此对时间序列数据往往要进行白噪声检验来确定待分析序列是否适合用于进一步的分析，例如时间序列建模，空间相关性等。[statsmodels](https://www.statsmodels.org/stable/index.html)<sup>①</sup>库提供的`acorr_ljungbox`方法包含BP检验（Box-Pierce test）和LB检验（Ljung-Box test）来判断一个序列是否为白噪声，两种假设检验的思路基本一致，如果序列前若干项相关系数都为零，那么检验统计量渐进服从于卡方分布，要是统计量的值在右端拒绝域内则可以拒绝原假设，判定该序列并非白噪声。

获取的温度传感器时间序列数据，通过图表打印查看各节点数值变化，能够发现测量值具有一定规律性，因此进一步通过[`statsmodels.stats.diagnostic.acorr_ljungbox`](https://www.statsmodels.org/dev/generated/statsmodels.stats.diagnostic.acorr_ljungbox.html)方法计算确定。配置`corr_ljungbox`输入参数`boxpierce=True`，除计算`Ljung-Box test`外，也计算`Box-Pierce test `，判断返回的`lb_pvalue`和`bp_pvalue`是否大于给定的显著性水平（默认配置为0.05），如果均大于无法拒绝原假设，则认为该数据为白噪声，即纯粹的随机数据。

为了方便对各个节点分别执行白噪声检验，对预处理的温度时间序列数据根据指定的分组列（`node_id`），数值列（`value_hrf_average`），和用于索引的时间列（`ts`）执行`pandas`库提供的`pivot`方法实现转置，将节点作为列名，时间作为索引值，如果对应时间行无数据则为`NaN`。


```python
aot_temperature_subsystemNsensor_pivot=aot_temperature_subsystemNsensor_gdf.pivot(values="value_hrf_average",columns="node_id",index="ts")

from util_misc import print_html
print_html(aot_temperature_subsystemNsensor_pivot)
```




<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>node_id</th>
      <th>001e0610ba46</th>
      <th>001e0610bc10</th>
      <th>001e0610e532</th>
      <th>001e0610e538</th>
      <th>001e0610ee36</th>
      <th>001e0610ee43</th>
      <th>001e0610f05c</th>
      <th>001e0610f703</th>
      <th>001e0610fb4c</th>
      <th>001e06112e77</th>
      <th>001e06113107</th>
      <th>001e06113a24</th>
      <th>001e06113acb</th>
      <th>001e06113ace</th>
      <th>001e06113ad8</th>
      <th>001e0611441e</th>
      <th>001e0611462f</th>
      <th>001e061146ba</th>
      <th>001e061146cb</th>
      <th>001e06117b41</th>
      <th>001e06117b44</th>
      <th>001e0611804d</th>
      <th>001e06118182</th>
      <th>001e061181e8</th>
      <th>001e06118295</th>
      <th>001e061182a2</th>
      <th>001e061182a3</th>
      <th>001e061182a7</th>
      <th>001e061183bf</th>
      <th>001e061183eb</th>
      <th>001e061183f3</th>
      <th>001e061183f5</th>
      <th>001e06118433</th>
      <th>001e061184a3</th>
      <th>001e06118501</th>
      <th>001e0611850f</th>
      <th>001e0611856d</th>
    </tr>
    <tr>
      <th>ts</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2020-01-01 00:30:00</th>
      <td>0.593</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-3.228</td>
      <td>-0.367</td>
      <td>-0.923</td>
      <td>-1.535</td>
      <td>NaN</td>
      <td>-0.891</td>
      <td>-1.932</td>
      <td>-1.807</td>
      <td>-0.806</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.59</td>
      <td>NaN</td>
      <td>-4.351</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-1.312</td>
      <td>2.666</td>
      <td>-1.326</td>
      <td>-0.273</td>
      <td>-1.377</td>
      <td>0.380</td>
      <td>-1.325</td>
      <td>-0.784</td>
      <td>5.335</td>
      <td>-1.003</td>
      <td>NaN</td>
      <td>-1.642</td>
      <td>-1.601</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.245</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2020-01-01 01:30:00</th>
      <td>0.455</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-2.850</td>
      <td>0.057</td>
      <td>-0.858</td>
      <td>-1.278</td>
      <td>NaN</td>
      <td>-0.902</td>
      <td>-1.642</td>
      <td>-1.470</td>
      <td>-0.526</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-4.169</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.926</td>
      <td>2.300</td>
      <td>-1.138</td>
      <td>-0.014</td>
      <td>-1.094</td>
      <td>0.386</td>
      <td>-1.138</td>
      <td>-0.515</td>
      <td>5.617</td>
      <td>-0.814</td>
      <td>NaN</td>
      <td>-1.389</td>
      <td>-1.249</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.117</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2020-01-01 02:30:00</th>
      <td>0.325</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-2.724</td>
      <td>0.091</td>
      <td>-0.685</td>
      <td>-1.280</td>
      <td>NaN</td>
      <td>-0.855</td>
      <td>-1.608</td>
      <td>-1.510</td>
      <td>-0.385</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.80</td>
      <td>NaN</td>
      <td>-4.095</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.901</td>
      <td>0.034</td>
      <td>-1.060</td>
      <td>0.232</td>
      <td>-1.121</td>
      <td>0.619</td>
      <td>-1.058</td>
      <td>-0.456</td>
      <td>5.651</td>
      <td>-0.758</td>
      <td>NaN</td>
      <td>-1.208</td>
      <td>-1.085</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.297</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2020-01-01 03:30:00</th>
      <td>0.538</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-3.001</td>
      <td>0.191</td>
      <td>-0.658</td>
      <td>-1.294</td>
      <td>NaN</td>
      <td>-0.521</td>
      <td>-1.589</td>
      <td>-1.660</td>
      <td>-0.516</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-4.107</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-1.050</td>
      <td>-0.050</td>
      <td>-1.011</td>
      <td>0.293</td>
      <td>-1.155</td>
      <td>1.397</td>
      <td>-1.009</td>
      <td>-0.492</td>
      <td>5.750</td>
      <td>-0.685</td>
      <td>NaN</td>
      <td>-1.366</td>
      <td>-1.182</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.199</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2020-01-01 04:30:00</th>
      <td>0.246</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-2.932</td>
      <td>0.886</td>
      <td>-0.409</td>
      <td>-1.451</td>
      <td>NaN</td>
      <td>-0.801</td>
      <td>-1.552</td>
      <td>-1.620</td>
      <td>-0.094</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-3.961</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>-0.871</td>
      <td>-0.096</td>
      <td>-0.910</td>
      <td>0.484</td>
      <td>-0.990</td>
      <td>1.386</td>
      <td>-0.859</td>
      <td>-0.449</td>
      <td>NaN</td>
      <td>-0.613</td>
      <td>NaN</td>
      <td>-1.313</td>
      <td>-1.197</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>0.294</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>



白噪声检验定义的函数`white_noise_Ljung_box_pierc()`调用定义的函数`white_noise_testing()`，返回值包括BP检验和LB检验结果，并根据显著性水平参数`alpha`返回是否为白噪声的判断。


```python
def white_noise_testing(df,value_column,lags=[6,12]):
    '''
    白噪声检验(纯随机性检验)，statsmodels.stats.diagnostic.acorr_ljungbox方法计算，包括Ljung-Box test和Box-Pierce test

    Parameters
    ----------
    df : DataFrame
        包含检测列的DataFrame格式数据.
    value_column : string
        待检测列名.
    lags : int, optional
        延迟数. The default is [6,12].

    Returns
    -------
    stat_pvalue : dict
        返回Ljung-Box test和Box-Pierce统计值，及p_value值.

    '''
    import statsmodels.stats.diagnostic as diag
    
    df_dropped=df[value_column].dropna()
    stat_pvalue=diag.acorr_ljungbox(df_dropped, lags=lags, boxpierce=True, model_df=0, period=None, return_df=None)
    return stat_pvalue  

def white_noise_Ljung_box_pierce(df,lags=[6,12],alpha=0.05):
    '''
    白噪声批量检验(纯随机性检验)，statsmodels.stats.diagnostic.acorr_ljungbox方法计算，包括Ljung-Box test和Box-Pierce test。并根据计算p-value值是否大于显著性水平（0.05或0.01），判断是否为白噪声

    Parameters
    ----------
    df: DataFrame
        待检验的数据，检验内容为所有列.
    lags : int, optional
        延迟数. The default is [6,12].
    alpha : float, optional
        显著性水平. The default is 0.05.

    Returns
    -------
    stat_pvalue_dict : dict
        包括Ljung-Box test和Box-Pierce test的统计值和p-value.
    is_white_nose : dict
        各个节点（node）是否为白噪音.

    '''
    from tqdm import tqdm

    columns=df.columns
    stat_pvalue_dict={}
    is_white_nose={}
    for c in tqdm(columns):            
        try:
            stat_pvalue=white_noise_testing(df,c,lags=lags)
            lb_pvalue=stat_pvalue[1]
            bp_pvalue=stat_pvalue[3]            
            stat_pvalue_dict[c]={"stat":{"lb_stat":stat_pvalue[0],"bp_stat":stat_pvalue[2]},"p-value":{"lb_pvalue":lb_pvalue,"bp_pvalue":bp_pvalue}}
            is_white_nose[c]=dict(zip(["lag_{}".format(i) for i in lags],[True if i>alpha and j>alpha else False for i,j in zip(lb_pvalue,bp_pvalue)]))
        except:
            print("{}-error!".format(c))           
    return stat_pvalue_dict,is_white_nose
```


```python
import pandas as pd
temperature_stat_pvalue_dict,temperature_is_white_nose=white_noise_Ljung_box_pierce(aot_temperature_subsystemNsensor_pivot,lags=[12,24,24*7])

node_sampe='001e0610ba46'
print(temperature_stat_pvalue_dict[node_sampe],'\n',temperature_is_white_nose[node_sampe])
temperature_is_white_noise_df=pd.DataFrame.from_dict(temperature_is_white_nose,orient='index')
temperature_is_white_noise_df
```

    100%|██████████| 37/37 [00:00<00:00, 287.61it/s]

    001e0610e532-error!
    001e0610f703-error!
    001e06113ace-error!
    001e061146ba-error!
    001e0611856d-error!
    {'stat': {'lb_stat': array([ 30413.76341513,  48294.64370466, 121744.96311353]), 'bp_stat': array([ 30343.54687994,  48118.79112619, 119570.72878674])}, 'p-value': {'lb_pvalue': array([0., 0., 0.]), 'bp_pvalue': array([0., 0., 0.])}} 
     {'lag_12': False, 'lag_24': False, 'lag_168': False}
    

    
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>lag_12</th>
      <th>lag_24</th>
      <th>lag_168</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>001e0610ba46</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610bc10</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610e538</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610ee36</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610ee43</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610f05c</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610fb4c</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06112e77</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113107</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113a24</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113acb</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113ad8</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611441e</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611462f</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061146cb</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06117b41</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06117b44</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611804d</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118182</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061181e8</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118295</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061182a2</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061182a3</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061182a7</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183bf</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183eb</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183f3</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183f5</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118433</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061184a3</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118501</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611850f</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



从上述分析结果来看，参与检验的37个节点，无效节点5个，有效节点32个。这32个节点的白噪声检验，在延迟数（`lags`）配置上包括3个量，为12（小时）,24（小时）和168（小时），对应半天、一天和7周时间，从返回结果可以确定，所有节点温度测量值均不是白噪声，可用于进一步的分析，获得有价值的研究结论。

#### 2）平稳性检验

如果要对时间序列建立预测模型，例如ARMA（autoregressive moving average）或ARIMA（autoregressive integrated moving average），需要时间序列数据具有平稳性（意味均值和方差保持不变）。通过检验温度传感器时间序列数据的平稳性，也可以确定温度测量值的变化趋势，是否数值稳定在一个固定区间内，还是会有剧烈的随机波动。计算使用[`statsmodels.tsa.stattools.adfuller`](https://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html)方法，如`adfuller（ADF）`返回的`p-value`值小于给定的显著性水平（默认配置为0.05），则数据平稳；否则无法拒绝原假设，数据不平稳。

平稳性检验定义的函数`stationary_stat()`调用定义的函数`stationary_adfulle`，返回值是根据配置的`alpha`显著性水平参数确定各列（节点）时间序列值是否平稳。


```python
def stationary_adfuller(df,value_column,autolag=None,alpha=0.05,print_detail=False):    
    '''
    计算时间序列的平稳性（statsmodels的adfuller方法）

    Parameters
    ----------
    df : DataFrame
        包含计算列的DataFrame格式数据.
    value_column : string
        待计算的列名.
    autolag : string, optional
        {“AIC”, “BIC”, “t-stat”, None}，具体参考 https://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html. The default is None.
    alpha : float, optional
        显著性水平(p-value). The default is 0.05.
    print_detail : bool, optional
        是否打印统计细节信息. The default is False.

    Returns
    -------
    is_stationary : dict
        节点名：是否平稳布尔值.

    '''
    from statsmodels.tsa.stattools import adfuller 
    
    df_drop=df[value_column].dropna()
    adfuller_test=adfuller(df_drop,autolag=autolag) # https://www.statsmodels.org/devel/generated/statsmodels.tsa.stattools.adfuller.html
    is_stationary=True if adfuller_test[1]<=alpha else False
    if print_detail:
        print('ADF statistic: %f' % adfuller_test[0])
        print('p-value: %f' % adfuller_test[1])
        print('critical values:')
        for key, value in adfuller_test[4].items():
            print('\t%s: %.3f' % (key, value))        
    return is_stationary

def stationary_stat(df_,autolag=None,alpha=0.05,print_detail=False,diff_periods=None):
    '''
    批量计算所有节点的平稳性

    Parameters
    ----------
    df_: DataFrame
        待检验的数据，检验内容为所有列.    
    autolag : string, optional
        {“AIC”, “BIC”, “t-stat”, None}. The default is None.
    alpha : float, optional
        显著性水平(p-value). The default is 0.05.
    print_detail : bool, optional
        是否打印统计细节信息. The default is False.

    Returns
    -------
    is_stationary_dict : dict(node:bool)
        返回各个节点是否平稳的布尔值，为True则平稳.

    '''
    from tqdm import tqdm

    df=df_.copy(deep=True)
    is_stationary_dict={}
    columns=df.columns
    valid_columns=[]

    if diff_periods:
        df=df.diff(diff_periods)

    for c in tqdm(columns):
        try:
            is_stationary=stationary_adfuller(df,c,autolag=autolag,alpha=alpha,print_detail=print_detail)
            is_stationary_dict[c]=is_stationary
            valid_columns.append(c)
        except:
            print("sample size is too short to calculate.")

    print("is_stationary number={} in {} of valid nodes.".format(list(is_stationary_dict.values()).count(True),len(valid_columns)))
    return is_stationary_dict
```


```python
temperature_is_stationary_dict=stationary_stat(aot_temperature_subsystemNsensor_pivot)
temperature_is_stationary_df=pd.DataFrame.from_dict(temperature_is_stationary_dict,orient='index',columns=["temperature_is_stationary"])
temperature_is_stationary_df[temperature_is_stationary_df["temperature_is_stationary"]==False]
```

    100%|██████████| 37/37 [00:00<00:00, 197.33it/s]

    is_stationary number=23 in 37 of valid nodes.
    

    
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>temperature_is_stationary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>001e0610e532</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610e538</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0610f703</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113ace</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061146ba</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061146cb</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118182</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061181e8</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061182a7</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183bf</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061183eb</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06118433</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e061184a3</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611856d</th>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



从上述结果得知，对于温度测量值各节点具有平稳性的有23个，而不平稳的有14个，这与时间序列图表打印结果符合，从图表中也可以发现有些节点测量值波动较大且不稳定。下述实验则指定了参数`diff_periods`为1，对时间序列执行一阶差分，计算一阶差分后的平稳性得知，不平稳的节点3个，平稳的节点34个。

对于获取的各类具有一定趋势的线性时间序列数据，有时数据并不平稳，但是又需要该数据进行后续分析使用只能在平稳性数据下才可使用的估计和检验方法，这时通常对不平稳的数据做一阶差分或多阶差分，即用后期数据减去前一期数据的结果，通过平稳性检验，原不具有平稳性的数据如果通过差分具有了平稳性，则可认为该时间数据“已经为具有平稳性”，消除了原数据的一些波动，使其趋于平稳。（一阶）差分的意义是为了消除时间序列数据中包含的随机性趋势，以令世界序列数据趋于平稳<sup>[1]431</sup>。从一阶差分后平稳性检验结果来看，由原来不平稳节点数14个减少至3个，有11个节点由不平稳转换为平稳数据。


```python
temperature_is_stationary_dict=stationary_stat(aot_temperature_subsystemNsensor_pivot,diff_periods=1)
temperature_is_stationary_df=pd.DataFrame.from_dict(temperature_is_stationary_dict,orient='index',columns=["temperature_is_stationary"])
temperature_is_stationary_df[temperature_is_stationary_df["temperature_is_stationary"]==False]
```

    100%|██████████| 37/37 [00:00<00:00, 202.76it/s]

    is_stationary number=34 in 37 of valid nodes.
    

    
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>temperature_is_stationary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>001e0610f703</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e06113ace</th>
      <td>False</td>
    </tr>
    <tr>
      <th>001e0611856d</th>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>



#### 3）周期性模式判断
使用自相关系数和偏自相关系数来检验时间序列数据与给定延迟数/滞后数（lag）错位自身的时间序列数据之间是否具有相关性，使用`statsmodel`库提供的`acf`和`pacf`计算，寻找时间序列数据重复模式，例如是否具有周期性。通过`statsmodel`库提供的`plot_acf`和`plot_pacf`图表打印时间序列数据，可以观察到时间序列数据的周期性。

温度测量值的平稳性检验中有部分数据数值变化较大，通过自相关系数计算和图表打印，部分节点不容易发现周期性的模式，因此同时对一阶差分后的时序测量值进行自相关系数计算，结果图表较之未差分前，可清晰判断具有周期性模式，周期约为24小时（天）。

* ACF和PACF

自相关系数（autocorrelation function，ACF），是将一列数据按照滞后数提取新一列数据，计算原数据和新数据之间的相关性，是数据与自身延迟的相关，是它们之间时间滞后的函数。ACF用于寻找一列数据的重复模式，例如被噪声掩盖的周期性信号等。

偏自相关系数（Partial autocorrelation function, PACF），在时间序列分析中，静止的时间序列与其自身滞后值的部分相关性（移除了中间变量的间接影响）。对于时间序列$\{ x_{t} \}$，$\{ x_{t} \}$与$\{ x_{t-k} \}$的偏自相关系数是指去掉$ x_{t-1}, x_{t-2}, \ldots , x_{t-k+1}$的间接影响后，$\{ x_{t} \}$与$\{ x_{t-k} \}$的简单相关系数。


```python
def autocorrelation_time_series(df, value_column,nlags=None,plot=False,bins_list=[-1,-0.75,-0.5,-0.25,0,0.25,0.5,0.75,1],title="ACF",xticks_step=6,save_path=None,plot_show=False): 
    '''
    计算DataFrame给定列的自相关系数并打印图表，及统计区间频数

    Parameters
    ----------
    df : DataFrame
        含计算列的DataFrame格式数据.
    value_column : string
        待计算列名.
    nlags : int, optional
        滞后（延迟）数. The default is None.
    plot : bool, optional
        是否打印图表. The default is False.
    bins_list : list(float), optional
        分类区间. The default is [-1,-0.75,-0.5,-0.25,0,0.25,0.5,0.75,1].

    Returns
    -------
    acf : list(float)
        各个延迟数下的自相关系数.
    categories_counts : pandas.core.series.Series (int)
        自相关系数区间频数统计.

    '''
    import matplotlib.pyplot as plt
    from statsmodels import api as sm
    import pandas as pd
    import os
    
    value_series=df[value_column]
    value_series.dropna(inplace=True)
    # get the autocorrelation coefficient
    if nlags is not None:
        acf=sm.tsa.acf(value_series, nlags=nlags)
    else:
        acf=sm.tsa.acf(value_series, nlags=len(value_series))   
        
    bins_tuples=[(bins_list[i],bins_list[i+1]) for i in range(len(bins_list)-1)]  
    bins=pd.IntervalIndex.from_tuples(bins_tuples)
    categories_counts=pd.cut(acf, bins).value_counts()   
        
    if plot:        
        fig=plt.figure(figsize=(12,8))
        ax=fig.add_subplot(111)
        plt.rc('axes', unicode_minus=False)
        if nlags is not None:
            fig=sm.graphics.tsa.plot_acf(value_series, lags=nlags,ax=ax,title=title)
        else:
            fig=sm.graphics.tsa.plot_acf(value_series, lags=len(value_series)-1,ax=ax,title=title)
        ax.xaxis.set_ticks_position('bottom') 
        fig.tight_layout()
        
        old_xticks=ax.get_xticks()
        xticks_step=xticks_step
        new_xticks=list(range(0,int(old_xticks[-1]),xticks_step))
        ax.set_xticks(new_xticks)
        if save_path:
            plt.savefig(os.path.join(save_path,"{}.jpg".format(title)))
        if plot_show:
            plt.show()
        plt.close('all')
    return acf,categories_counts

def partial_autocorrelation_time_series(df, value_column,nlags=None,plot=False,bins_list=[-1,-0.75,-0.5,-0.25,0,0.25,0.5,0.75,1],title="PACF",xticks_step=6,save_path=None,plot_show=False): 
    '''
    计算DataFrame给定列的偏自相关系数并打印图表，及统计区间频数

    Parameters
    ----------
    df : DataFrame
       含计算列的DataFrame格式数据.
    value_column : string
        待计算列名.
    nlags : int, optional
        滞后（延迟）数. The default is None.
    plot : bool, optional
        是否打印图表. The default is False.
    bins_list : list(float), optional
        分类区间. The default is [-1,-0.75,-0.5,-0.25,0,0.25,0.5,0.75,1].

    Returns
    -------
    pacf : list(float)
        各个延迟数下的偏自相关系数.
    categories_counts : pandas.core.series.Series (int)
        偏自相关系数区间频数统计.

    '''
    import matplotlib.pyplot as plt
    from statsmodels import api as sm
    import pandas as pd
    import os
    
    value_series=df[value_column]
    value_series.dropna(inplace=True)
    # get the autocorrelation coefficient
    if nlags is not None:
        pacf=sm.tsa.pacf(value_series, nlags=nlag,method='ywm')
    else:
        pacf=sm.tsa.pacf(value_series, nlags=len(value_series),method='ywm')   
        
    bins_tuples=[(bins_list[i],bins_list[i+1]) for i in range(len(bins_list)-1)]  
    bins=pd.IntervalIndex.from_tuples(bins_tuples)
    categories_counts=pd.cut(pacf, bins).value_counts()          
        
    if plot:
        fig=plt.figure(figsize=(12,8))
        ax=fig.add_subplot(111)
        plt.rc('axes', unicode_minus=False)
        if nlags is not None:
            fig=sm.graphics.tsa.plot_pacf(value_series, lags=nlags,ax=ax,title=title,method='ywm')
        else:
            fig=sm.graphics.tsa.plot_pacf(value_series, lags=len(value_series)-1,ax=ax,title=title,method='ywm')
        ax.xaxis.set_ticks_position('bottom') 
        fig.tight_layout()
        
        old_xticks=ax.get_xticks()
        xticks_step=xticks_step
        new_xticks=list(range(0,int(old_xticks[-1]),xticks_step))
        ax.set_xticks(new_xticks)   
        if save_path:
            plt.savefig(os.path.join(save_path,"{}.jpg".format(title)))    
        if plot_show:
            plt.show()
        plt.close('all')
    return pacf,categories_counts

def acf_pacf_counter(df_,nlags=7,plot=False,save_path_acf=None,save_path_pacf=None,diff_periods=None,plot_show=False):
    '''
    所有节点（nodes）自相关autocorrelation和偏自相关partial autocorrelation计算及频数统计

    Parameters
    ----------
    df_: DataFrame
        待检验的数据，检验内容为所有列.      
    nlags : int, optional
        延迟数. The default is 7.
    plot : bool, optional
        是否打印图表,True为打印. The default is False.

    Returns
    -------
    acf_counter_dict : dict
        返回自相关系数字典（node:acf）.
    pacf_counter_dict : dict
        返回偏自相关字典（node:pacf）.

    '''

    df=df_.copy(deep=True)
    columns=df.columns
    acf_counter_dict={}
    pacf_counter_dict={}
    acf_insufficient_num=0
    pacf_insufficient_num=0  
    if diff_periods:
        df=df.diff(diff_periods)
    for column in columns:
        try:
            acf,acf_categories_counts=autocorrelation_time_series(df,column,plot=plot,nlags=nlags,title="acf_{}".format(column),save_path=save_path_acf,plot_show=plot_show)
            acf_counter_dict[column]=acf_categories_counts  
        except:
            acf_insufficient_num+=1
            print("acf_{}-Insufficient sample size!".format(column))               

        try:   
            pacf,pacf_categories_counts=partial_autocorrelation_time_series(df,column,plot=plot,nlags=nlags,title="pacf_{}".format(column),save_path=save_path_pacf,plot_show=plot_show) 
            pacf_counter_dict[column]=pacf_categories_counts
        except:
            pacf_insufficient_num+=1
            print("pacf_{}-Insufficient sample size!".format(column)) 

    acf_counter_sum=pd.DataFrame(acf_counter_dict.values()).sum(axis=0)  
    pacf_counter_sum=pd.DataFrame(pacf_counter_dict.values()).sum(axis=0)
    print("_"*50)
    print("acf_valid column number={};pacf_valid columnnumber={}".format(len(columns)-acf_insufficient_num,len(columns)-pacf_insufficient_num))
    print("_"*50)
    print("acf_counter_sum={},\n,pacf_counter_sum={};".format(acf_counter_sum,pacf_counter_sum))
    return acf_counter_dict,pacf_counter_dict
```


```python
save_path_acf='./graph/temperature_acf'
save_path_pacf='./graph/temperature_pacf'
temperature_acf_counter_dict,temperature_pacf_counter_dict=acf_pacf_counter(aot_temperature_subsystemNsensor_pivot,nlags=24*7,plot=True,save_path_acf=save_path_acf,save_path_pacf=save_path_pacf,diff_periods=1)
```

    pacf_001e0610ba46-Insufficient sample size!
    pacf_001e0610bc10-Insufficient sample size!
    acf_001e0610e532-Insufficient sample size!
    pacf_001e0610e532-Insufficient sample size!
    pacf_001e0610e538-Insufficient sample size!
    pacf_001e0610ee36-Insufficient sample size!
    pacf_001e0610ee43-Insufficient sample size!
    pacf_001e0610f05c-Insufficient sample size!
    acf_001e0610f703-Insufficient sample size!
    pacf_001e0610f703-Insufficient sample size!
    pacf_001e0610fb4c-Insufficient sample size!
    pacf_001e06112e77-Insufficient sample size!
    pacf_001e06113107-Insufficient sample size!
    pacf_001e06113a24-Insufficient sample size!
    pacf_001e06113acb-Insufficient sample size!
    acf_001e06113ace-Insufficient sample size!
    pacf_001e06113ace-Insufficient sample size!
    pacf_001e06113ad8-Insufficient sample size!
    pacf_001e0611441e-Insufficient sample size!
    pacf_001e0611462f-Insufficient sample size!
    acf_001e061146ba-Insufficient sample size!
    pacf_001e061146ba-Insufficient sample size!
    pacf_001e061146cb-Insufficient sample size!
    pacf_001e06117b41-Insufficient sample size!
    pacf_001e06117b44-Insufficient sample size!
    pacf_001e0611804d-Insufficient sample size!
    pacf_001e06118182-Insufficient sample size!
    pacf_001e061181e8-Insufficient sample size!
    pacf_001e06118295-Insufficient sample size!
    pacf_001e061182a2-Insufficient sample size!
    pacf_001e061182a3-Insufficient sample size!
    pacf_001e061182a7-Insufficient sample size!
    pacf_001e061183bf-Insufficient sample size!
    pacf_001e061183eb-Insufficient sample size!
    pacf_001e061183f3-Insufficient sample size!
    pacf_001e061183f5-Insufficient sample size!
    pacf_001e06118433-Insufficient sample size!
    pacf_001e061184a3-Insufficient sample size!
    pacf_001e06118501-Insufficient sample size!
    pacf_001e0611850f-Insufficient sample size!
    acf_001e0611856d-Insufficient sample size!
    pacf_001e0611856d-Insufficient sample size!
    __________________________________________________
    acf_valid column number=32;pacf_valid columnnumber=0
    __________________________________________________
    acf_counter_sum=(-1.0, -0.75]       0
    (-0.75, -0.5]       0
    (-0.5, -0.25]       0
    (-0.25, 0.0]     3073
    (0.0, 0.25]      2168
    (0.25, 0.5]       128
    (0.5, 0.75]         7
    (0.75, 1.0]        32
    dtype: int64,
    ,pacf_counter_sum=Series([], dtype: float64);
    


* 温度测量值自相关系数 (ACF) 一阶差分 lag=24×7

<img src="./imgs/2_7_2/2_7_2_02.png" height="auto" width="auto" title="caDesign">

* 温度测量值偏自相关系数(PACF) 一阶差分 lag=24×7

<img src="./imgs/2_7_2/2_7_2_03.png" height="auto" width="auto" title="caDesign">

---

注释（Notes）：

① statsmodels，是一个Python模块，为许多不同统计模型的估计提供了类和函数，进行统计测试和统计推断。每个估计器都有一个广泛的结果统计列表，与现有的统计包进行测试，确保它们的正确性（<https://www.statsmodels.org/stable/index.html>）。

参考文献（References）:

[1] 詹姆斯·H·斯托克; 马克·W·沃森. 沈根祥,孙燕等译. 计量经济学[M]格致出版社_上海三联书店_上海人民出版社: 上海, 2012.04 (第三版).
