> Created on Tue Dec 20 09:55:44 2022  @author: Richie Bao-caDesign设计(cadesign.cn)

## 2.7.6 不平等性和空间隔离

### 2.7.6.1 数据预处理

土地利用来源于芝加哥大都会规划署（Chicago Metropolitan Agency for Planning, CMAP），为[2015年更新数据](https://www.cmap.illinois.gov/data/land-use/inventory)<sup>①</sup>，由规划署提供的土地使用清单类别<sup>[1]</sup>，包括一级分类和二级分类。每五年更新一次的区域土地利用信息层数据由德克萨斯州中北部政府委员会（North Central Texas Council of Governments, NCTCOG）的信息部门（Information Services department，RIS）负责开发。

| 一级分类                                   | 二级分类                                                                    |
|----------------------------------------|-------------------------------------------------------------------------|
| 住宅（RESIDENTIAL）                        | █ 单户住宅（Single_Family_Residential）                                       |
|                                        | █ 独栋单户住宅（Single_Family_Detached）                                        |
|                                        | █ 连排单户住宅（Single_Family_Attached）                                        |
|                                        | █ 多户住宅（Multi_Family）                                                    |
|                                        | █ 托车移动住宅（Mobile_Home_Parks_and_Trailer_Courts）                          |
|                                        | █ 相关住宅用地（Associated_Residential_Land）                                   |
|                                        | █ 住宅开发区内公共开放空间（Common_Open_Space_in_a_Residential_Development）          |
| 商业（COMMERCIAL）                         | █ 主要零售服务（Primarily_Retail_Service）                                      |
|                                        | █ 购物广场（Shopping_Malls）                                                  |
|                                        | █ 区域社区零售中心（Regional_Community_Retail_Centers）                           |
|                                        | █ 单一大型零售点（Single_Large_Site_Retail）                                     |
|                                        | █ 城市混合用地（Urban_Mix）                                                     |
|                                        | █ 含住宅的城市混合用地（Urban_Mix_w_Residential_Component）                         |
|                                        | █ 办公（Office）                                                            |
|                                        | █ 文化娱乐（Cultural_Entertainment）                                          |
|                                        | █ 酒店旅馆（Hotel_Motel）                                                     |
| 机构（INSTITUTIONAL）                      | █ 医疗设施（Medical_Facilities）                                              |
|                                        | █ K_12教育设施（K_12_Educational_Facilities）/含幼儿园，小学和中学                      |
|                                        | █ 大学教育设施（Post_Secondary_Educational_Facilities）                         |
|                                        | █ 政府行政和服务（Government_Administration_and_Services）                       |
|                                        | █ 监狱和惩教设施（Prison_and_Correctional_Facilities）                           |
|                                        | █ 宗教设施（Religious_Facilities）                                            |
|                                        | █ 墓地（Cemeteries）                                                        |
|                                        | █ 其他机构（Other_Institutional）                                             |
|                                        | █ 国家实验室（National_Laboratory）                                            |
| 工业（INDUSTRIAL）                         | █ 矿物提取（Mineral_Extraction）                                              |
|                                        | █ 一般工业（General_Industrial）                                              |
|                                        | █ 通用电气工业（Industrial_G_E）                                                |
|                                        | █ 制造加工（Manufacturing_Processing）                                        |
|                                        | █ 仓储配送（Warehousing_Distribution）                                        |
|                                        | █ 不确定用地（Flex_or_Indeterminate）                                          |
|                                        | █ 贮存（Storage）                                                           |
| 交通、通讯、公共事业和垃圾处理（TRANS COMM UTIL WASTE） | █ 运输通行权（Transportation_Right_of_Way）                                    |
|                                        | █ 铁路（Rail_ROW）                                                          |
|                                        | █ 高速公路（Roadway）                                                         |
|                                        | █ 其他具有相关设施的线性交通（Other_Linear_Transportation_with_Associated_Facilities） |
|                                        | █ 航空运输（Aircraft_Transportation）                                         |
|                                        | █ 独立停车场（Independent_Automobile_Parking）                                 |
|                                        | █ 通讯（Communication）                                                     |
|                                        | █ 公用事业和废物处理设施（Utilities_and_Waste_Facilities）                           |
|                                        | █ 公用事业通行权（Utility_Right_of_Way）                                         |
|                                        | █ 废水处理设施（Wastewater_Treatment_Facility）                                 |
|                                        | █ 垃圾填埋场（Landfill）                                                       |
|                                        | █ 其它公用设施废物（Other_Utility_Waste）                                         |
|                                        | █ 雨水管理（Stormwater_Management）                                           |
|                                        | █ 联运设施（Intermodal_Facility）                                             |
| 农业（AGRICULTURE）                        | █ 农业（AGRICULTURE）                                                       |
| 开放空间（OPEN SPACE）                       | █ 开放空间主要娱乐设施（Open_Space_Primarily_Recreation）/以城市公园为主                   |
|                                        | █ 高尔夫球场（Golf_Course）                                                    |
|                                        | █ 开放空间主要保护区（Open_Space_Primarily_Conservation）                          |
|                                        | █ 非公共开放空间（Non_Public_Open_Space）                                        |
|                                        | █ 步道或绿道（Trail_or_Greenway）                                              |
| 空置（VACANT UNDER CONSTRUCTION）          | █ 空置未开发土地（Vacant_Undeveloped_Land）                                      |
|                                        | █ 空置住宅用地（Vacant_Residential_Land）                                       |
|                                        | █ 空置商业用地（Vacant_Commercial_Land）                                        |
|                                        | █ 空置工业用地（Vacant_Industrial_Land）                                        |
|                                        | █ 其它空置（Other_Vacant）                                                    |
| 在建（Under_Construction）                 | █ 在建住宅（Under_Construction_Residential）                                  |
|                                        | █ 在建商业（Under_Construction_Commercial）                                   |
|                                        | █ 在建工业（Under_Construction_Industrial）                                   |
|                                        | █ 其他或未知在建（Under_Construction_Other_or_Unknown）                          |
| 水体（WATER）                              | █ 水体（Water）                                                             |
| 非包裹区域（NON PARCEL AREAS）                | █ 非包裹区域（NON_PARCEL_AREAS）/以道路为主                                         |
| 未分类（NOT CLASSIFIED）                    | █ 未分类（Not_Classifiable）                                                 |


下载的土地利用数据为矢量SHP格式，大小约900MB。使用土地利用数据的目的为样方统计用于后续分析，因此需要将其转化为栅格数据，建立连续多个Polygon样方进行区域统计，获得各个样方中各土地利用类型的栅格单元数量。土地利用地图数据打印时，通常需要对不同土地利用类型赋予不同的颜色方便观察，因此也需要建立颜色的映射表。为了方便数据的管理和在QGIS等地理信息平台中加载数据，本次实验通过[pgAdmin](https://www.pgadmin.org/)<sup>②</sup>工具建立PostgreSQL数据库，将主要的数据写入到数据库中，方便统一管理后续调用。

参数管理使用`AttrDict()`方法（具体查看“Cityscapes数据集——参数管理”一节）。`db`子属性存储数据库信息；`gi`子属性存储地理坐标投影信息；`data`子属性存储数据文件路径。


```python
from database import postSQL2gpd,gpd2postSQL
from util_misc import AttrDict
__C=AttrDict() 
args=__C

__C.db=AttrDict() 
__C.db.UN='postgres'
__C.db.PW='123456'
__C.db.DB='inequalityNsegregation'
__C.db.GC='geometry' 
__C.db.db_info=dict(geom_col=args.db.GC,myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB)

__C.gi=AttrDict()
__C.gi.Chicago_epsg=32616
__C.gi.epsg_wgs84=4326

__C.data=AttrDict()
__C.data.landuse='G:\data\landuse_Chicago\LUI15_shapefile_v1' # 芝加哥2015年土地利用SHP格式文件
__C.data.landuse_LB='E:\data\Chicago_landuse\Chicago_landuse_LB\landuse_LB_uncropped.shp' # 土地利用分类整数编码后的文件
__C.data.landuse_tif='E:\data\Chicago_landuse\landuse.tif' #  转化为栅格的土地利用文件
__C.data.Chicago_boundaries_city='./data/Chicago_boundaries_city/Chicago_boundaries_city.shp' # 芝加哥城边界SHP格式文件
```

#### 1）土地利用数据读取和编码

`GeoPandas`库提供了`read_file`方法读取SHP、GPKG和GeoJson等数据格式文件，且提供了`clip`方法裁切地理信息数据，为了方便数据操作，进行功能的整合，定义`shp2gdf()`函数执行SHP格式文件的读取、裁切等数据处理流程。返回的GeoDataFrame格式数据投影，如果不进行裁切则与读取的数据投影同；如果进行裁切，则与裁切对象的投影同。


```python
def shp2gdf(fn,boundary=None,encoding='utf-8'):    
    '''
    转换.shp地理信息数据为GeoDataFrame(geopandas)数据格式，可以配置投影

    Parameters
    ----------
    fn : string
        SHP文件路径.
    boundary : .shp, optional
        配置裁切边界. The default is None.
    encoding : string, optional
        配置编码. The default is 'utf-8'.

    Returns
    -------
    GeoDataFrame
        读取SHP格式文件为GeoDataFrame格式返回.

    '''
    import geopandas as gpd
    from tqdm import tqdm
    tqdm.pandas()  
    
    shp_gdf=gpd.read_file(fn,encoding=encoding)    
    if boundary is not None:        
        shp_gdf['mask']=shp_gdf.geometry.progress_apply(lambda row:row.is_valid)
        shp_gdf=shp_gdf[shp_gdf['mask']==True]
        shp_clip_gdf=gpd.clip(shp_gdf.to_crs(boundary.crs),boundary)    
        return shp_clip_gdf
    else:
        return shp_gdf
```


```python
landuse_gdf=shp2gdf(args.data.landuse)
landuse_gdf.to_crs(args.gi.Chicago_epsg,inplace=True)
landuse_CH_gdf=landuse_gdf.copy(deep=True)
```

读取的数据中`LANDUSE`列提供了土地利用分类的编码，为了对位名称，根据规划署提供的土地使用清单类别建立映射字典，由土地利用类型编号为键，值为一个列表，表示为'landuse_CH_mapping','landuse_parentClass_mapping','landuse_parentClass_mapping_2','landuse_EN_mapping'4个值，对应土地利用二级分类中文名、一级分类中文名、用于地图打印调整的一级分类中文名和英文名。将字典转换为DataFrame格式数据，根据需要提取列，例如`landuse_CH_mapping`为二级分类映射字典；`landuse_parentClass_mapping`为一级分类映射字典。


```python
landuse_mapping={             
                '1000':['城市化区域','城市化区域','城市化区域','URBANIZED'],# 'URBANIZED',空值，父类
                '1110':['单户住宅','住宅','住宅','Single_Family_Residential'], # 'Single_Family_Residential',(SFR)空值，父类
                '1111':['独栋单户住宅','住宅','住宅','Single_Family_Detached'],# 'Single_Family_Detached',58787 rows
                '1112':['连排单户住宅','住宅','住宅','Single_Family_Attached'], # 'Single_Family_Attached',3874 rows
                '1130':['多户住宅','住宅','住宅','Multi_Family'], # 'Multi_Family',58256 rows
                '1140':['托车移动住宅','住宅','住宅','Mobile_Home_Parks_and_Trailer_Courts'],# 'Mobile_Home_Parks_and_Trailer_Courts',2 rows
                '1150':['相关住宅用地','住宅','住宅','Associated_Residential_Land'],# 'Associated_Residential_Land',空值
                '1151':['住宅开发区内公共开放空间','住宅','住宅','Common_Open_Space_in_a_Residential_Development'],# 'Common_Open_Space_in_a_Residential_Development',571 rows
                '1200':['商业','商业','商业','COMMERCIAL'], # 'COMMERCIAL',空值，父类
                '1210':['主要零售服务','商业','商业','Primarily_Retail_Service'],# 'Primarily_Retail_Service',空值，父类
                '1211':['购物广场','商业','商业','Shopping_Malls'],# 'Shopping_Malls',3 rows
                '1212':['区域社区零售中心','商业','商业','Regional_Community_Retail_Centers'],# 'Regional_Community_Retail_Centers',78 rows
                '1214':['单一大型零售点','商业','商业','Single_Large_Site_Retail'],# 'Single_Large_Site_Retail',31 rows
                '1215':['城市混合用地','商业','商业','Urban_Mix'],# 'Urban_Mix',10889 rows
                '1216':['含住宅的城市混合用地','商业','商业','Urban_Mix_w_Residential_Component'],# 'Urban_Mix_w_Residential_Component',城市混合用地
                '1220':['办公','商业','商业','Office'],# 'Office',610 rows
                '1240':['文化娱乐','商业','商业','Cultural_Entertainment'],# 'Cultural_Entertainment',276 rows
                '1250':['酒店旅馆','商业','商业','Hotel_Motel'],# 'Hotel_Motel',166 rows
                '1300':['机构','机构','机构','INSTITUTIONAL'],# 'INSTITUTIONAL',空值，父类
                '1310':['医疗设施','机构','机构','Medical_Facilities'],# 'Medical_Facilities',319 rows
                '1320':['教育设施','机构','机构','Educational_Facilities'],# 'Educational_Facilities',空值，父类
                '1321':['K_12教育设施','机构','机构','K_12_Educational_Facilities'],# 'K_12_Educational_Facilities',幼稚园、小学和中学教育合在一起的统称,1356 rows
                '1322':['大学教育设施','机构','机构','Post_Secondary_Educational_Facilities'],# 'Post_Secondary_Educational_Facilities',296 rows 
                '1330':['政府行政和服务','机构','机构','Government_Administration_and_Services'],# 'Government_Administration_and_Services',522 rows
                '1340':['监狱和惩教设施','机构','机构','Prison_and_Correctional_Facilities'],# 'Prison_and_Correctional_Facilities',8 rows 
                '1350':['宗教设施','机构','机构','Religious_Facilities'],# 'Religious_Facilities',2799 rows 
                '1360':['墓地','机构','机构','Cemeteries'],# 'Cemeteries',36 rows
                '1370':['其他机构','机构','机构','Other_Institutional'],# 'Other_Institutional',348 rows 
                '1380':['国家实验室','机构','机构','National_Laboratory'],# 'National_Laboratory',空值(未裁切文件含值)
                '1400':['工业','工业','工业','INDUSTRIAL'],# 'INDUSTRIAL',空值，父类
                '1410':['矿物提取','工业','工业','Mineral_Extraction'],# 'Mineral_Extraction',5 rows 
                '1420':['一般工业','工业','工业','General_Industrial'],# 'General_Industrial',2746 rows
                '1430':['通用电气工业','工业','工业','Industrial_G_E'],# 'Industrial_G_E',General Electric(GE),空值，父类
                '1431':['制造加工','工业','工业','Manufacturing_Processing'],# 'Manufacturing_Processing',253 rows
                '1432':['仓储配送','工业','工业','Warehousing_Distribution'],# 'Warehousing_Distribution',104 rows, A storage warehouse is preferred for industrial or commercial purposes. 
                '1433':['不确定用地','工业','工业','Flex_or_Indeterminate'],# 'Flex_or_Indeterminate',128 rows 
                '1450':['贮存','工业','工业','Storage'],# 'Storage',165 rows, A storage facility is used for personal and business needs.
                '1500':['转运与垃圾管理','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','TRANS_COMM_UTIL_WASTE'],# 'TRANS_COMM_UTIL_WASTE',空值，父类
                '1510':['运输通行权','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Transportation_Right_of_Way'],# 'Transportation_Right_of_Way',空值
                '1511':['铁路','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Rail_ROW'],# 'Rail_ROW',1725 rows 
                '1512':['高速公路','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Roadway'],# 'Roadway',3225 rows 
                '1520':['其他具有相关设施的线性交通','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Other_Linear_Transportation_with_Associated_Facilities'],# 'Other_Linear_Transportation_with_Associated_Facilities',438 rows
                '1530':['航空运输','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Aircraft_Transportation'],# 'Aircraft_Transportation',88 rows
                '1540':['独立停车场','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Independent_Automobile_Parking'],# 'Independent_Automobile_Parking',260 rows 
                '1550':['通讯','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Communication'],# 'Communication',203 rows
                '1560':['公用事业和废物处理设施','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Utilities_and_Waste_Facilities'],# 'Utilities_and_Waste_Facilities',空值，父类
                '1561':['公用事业通行权','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Utility_Right_of_Way'],# 'Utility_Right_of_Way',106 rows
                '1562':['废水处理设施','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Wastewater_Treatment_Facility'],# 'Wastewater_Treatment_Facility',8 rows 
                '1563':['垃圾填埋场','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Landfill'],# 'Landfill',107 rows
                '1564':['其它公用设施废物','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Other_Utility_Waste'],# 'Other_Utility_Waste',177 rows
                '1565':['雨水管理','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Stormwater_Management'],# 'Stormwater_Management',11 rows
                '1570':['联运设施','交通_通讯_公共事业和垃圾处理','交通_通讯_公共事业和垃圾处理','Intermodal_Facility'],# 'Intermodal_Facility',72 rows
                '2000':['农业','农业','其它','AGRICULTURE'],# 'AGRICULTURE',18 rows
                '3000':['开放空间','开放空间','开放空间','OPEN_SPACE'],# 'OPEN_SPACE',空值，父类
                '3100':['开放空间主要娱乐设施','开放空间','开放空间','Open_Space_Primarily_Recreation'],# 'Open_Space_Primarily_Recreation',978 rows，公园
                '3200':['高尔夫球场','开放空间','开放空间','Golf_Course'],# 'Golf_Course',19 rows
                '3300':['开放空间主要保护区','开放空间','开放空间','Open_Space_Primarily_Conservation'],#' Open_Space_Primarily_Conservation',163 rows
                '3400':['非公共开放空间','开放空间','开放空间','Non_Public_Open_Space'],# 'Non_Public_Open_Space',3 rows
                '3500':['步道或绿道','开放空间','开放空间','Trail_or_Greenway'],# 'Trail_or_Greenway',31 rows
                '4000':['空置在建','空置','其它','VACANT_UNDER_CONSTRUCTION'],# 'VACANT_UNDER_CONSTRUCTION',空值，父类
                '4100':['空置未开发土地','空置','其它','Vacant_Undeveloped_Land'],# 'Vacant_Undeveloped_Land',空值
                '4110':['空置住宅用地','空置','其它','Vacant_Residential_Land'],# 'Vacant_Residential_Land',18095 rows
                '4120':['空置商业用地','空置','其它','Vacant_Commercial_Land'],# 'Vacant_Commercial_Land',3811 rows
                '4130':['空置工业用地','空置','其它','Vacant_Industrial_Land'],# 'Vacant_Industrial_Land',1155 rows
                '4140':['其它空置','空置','其它','Other_Vacant'],# 'Other_Vacant',1126 rows 
                '4200':['在建','在建','其它','Under_Construction'],# 'Under_Construction',空值，父类
                '4210':['在建住宅','在建','其它','Under_Construction_Residential'],# 'Under_Construction_Residential',192 rows
                '4220':['在建商业','在建','其它','Under_Construction_Commercial'],# 'Under_Construction_Commercial',35 rows
                '4230':['在建工业','在建','其它','Under_Construction_Industrial'],# 'Under_Construction_Industrial',4 rows 
                '4240':['其他或未知在建','在建','其它','Under_Construction_Other_or_Unknown'],# 'Under_Construction_Other_or_Unknown',
                '5000':['水体','水体','水体','Water'],# 'Water',172 rows
                '6000':['非包裹区域','非包裹区域','非包裹区域','NON_PARCEL_AREAS'],# 'NON_PARCEL_AREAS',2167 rows，道路为主
                '9999':['未分类','未分类','其它','Not_Classifiable'],# 'Not_Classifiable',  58 rows     
                }
```


```python
import pandas as pd
landuse_mapping_df=pd.DataFrame.from_dict(landuse_mapping,orient='index',columns=['landuse_CH_mapping','landuse_parentClass_mapping','landuse_parentClass_mapping_2','landuse_EN_mapping'])
# landuse_mapping_df.reset_index(names=['ID'],inplace=True)
landuse_mapping_df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>landuse_CH_mapping</th>
      <th>landuse_parentClass_mapping</th>
      <th>landuse_parentClass_mapping_2</th>
      <th>landuse_EN_mapping</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1000</th>
      <td>城市化区域</td>
      <td>城市化区域</td>
      <td>城市化区域</td>
      <td>URBANIZED</td>
    </tr>
    <tr>
      <th>1110</th>
      <td>单户住宅</td>
      <td>住宅</td>
      <td>住宅</td>
      <td>Single_Family_Residential</td>
    </tr>
    <tr>
      <th>1111</th>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>住宅</td>
      <td>Single_Family_Detached</td>
    </tr>
    <tr>
      <th>1112</th>
      <td>连排单户住宅</td>
      <td>住宅</td>
      <td>住宅</td>
      <td>Single_Family_Attached</td>
    </tr>
    <tr>
      <th>1130</th>
      <td>多户住宅</td>
      <td>住宅</td>
      <td>住宅</td>
      <td>Multi_Family</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>4230</th>
      <td>在建工业</td>
      <td>在建</td>
      <td>其它</td>
      <td>Under_Construction_Industrial</td>
    </tr>
    <tr>
      <th>4240</th>
      <td>其他或未知在建</td>
      <td>在建</td>
      <td>其它</td>
      <td>Under_Construction_Other_or_Unknown</td>
    </tr>
    <tr>
      <th>5000</th>
      <td>水体</td>
      <td>水体</td>
      <td>水体</td>
      <td>Water</td>
    </tr>
    <tr>
      <th>6000</th>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
      <td>NON_PARCEL_AREAS</td>
    </tr>
    <tr>
      <th>9999</th>
      <td>未分类</td>
      <td>未分类</td>
      <td>其它</td>
      <td>Not_Classifiable</td>
    </tr>
  </tbody>
</table>
<p>73 rows × 4 columns</p>
</div>




```python
landuse_CH_mapping=landuse_mapping_df.landuse_CH_mapping.to_dict()
landuse_parentClass_mapping=landuse_mapping_df.landuse_parentClass_mapping.to_dict()
```

将一二级土地利用分类名对位到`landuse_CH_gdf`数据中。


```python
landuse_CH_gdf['CHname']=landuse_CH_gdf.LANDUSE.apply(lambda row:landuse_CH_mapping[row])    
landuse_CH_gdf['parentClass']=landuse_CH_gdf.LANDUSE.apply(lambda row:landuse_parentClass_mapping[row]) 
landuse_CH_gdf
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>FIRST_COUN</th>
      <th>LANDUSE</th>
      <th>LANDUSE2</th>
      <th>OS_MGMT</th>
      <th>FAC_NAME</th>
      <th>PLATTED</th>
      <th>MODIFIER</th>
      <th>Shape_Leng</th>
      <th>Shape_Area</th>
      <th>geometry</th>
      <th>CHname</th>
      <th>parentClass</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>517.742137</td>
      <td>16718.995065</td>
      <td>POLYGON ((405755.086 4666594.715, 405736.553 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>1</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>477.507596</td>
      <td>11320.358746</td>
      <td>POLYGON ((406011.595 4666666.401, 406000.000 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>2</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>484.025949</td>
      <td>9845.643361</td>
      <td>POLYGON ((406660.786 4666744.982, 406602.816 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>3</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>700.439764</td>
      <td>17077.187161</td>
      <td>POLYGON ((406481.048 4666788.526, 406429.637 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>4</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>340.958375</td>
      <td>4876.261817</td>
      <td>POLYGON ((406280.699 4666876.317, 406239.891 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>535173</th>
      <td>197</td>
      <td>6000</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>269.275557</td>
      <td>3326.588780</td>
      <td>POLYGON ((412872.480 4619999.996, 412836.225 4...</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
    <tr>
      <th>535174</th>
      <td>197</td>
      <td>6000</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>61.452204</td>
      <td>40.424097</td>
      <td>POLYGON ((412435.632 4620000.000, 412426.321 4...</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
    <tr>
      <th>535175</th>
      <td>197</td>
      <td>6000</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>9155.705032</td>
      <td>271973.258341</td>
      <td>POLYGON ((413999.999 4619999.999, 413889.511 4...</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
    <tr>
      <th>535176</th>
      <td>197</td>
      <td>6000</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>3895.597432</td>
      <td>129057.116542</td>
      <td>POLYGON ((413439.307 4620000.000, 413419.194 4...</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
    <tr>
      <th>535177</th>
      <td>197</td>
      <td>6000</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>3315.837148</td>
      <td>16338.850243</td>
      <td>POLYGON ((414022.299 4620000.000, 413999.999 4...</td>
      <td>非包裹区域</td>
      <td>非包裹区域</td>
    </tr>
  </tbody>
</table>
<p>535178 rows × 12 columns</p>
</div>



将读取并加入一二级土地利用分类名的土地利用数据写入到数据中。


```python
gpd2postSQL(landuse_CH_gdf,'landuse_CH_uncropped',**args.db.db_info)  
```

    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is landuse_CH_uncropped.
    

读取存入到数据库的土地利用数据。


```python
landuse_CH_uncropped_gdf=postSQL2gpd(table_name='landuse_CH_uncropped',**args.db.db_info)    
```

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning: Did not recognize type 'geometry' of column 'geometry'
      pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])
    

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is landuse_CH_uncropped.
    

* 编码土地利用类型

使用`scikit-learn`库提供的`LabelEncoder`方法编码土地利用类型。定义`gdf_label_encoder()`函数可以直接操作DataFrame格式数据列，并把编码结果作为新列加入。


```python
def gdf_label_encoder(gdf,columns):
    '''
    给定(Geo)DataFrame数据，指定一个或多个列，转换为整数值编码，增加新列标识符为LB_

    Parameters
    ----------
    gdf : (Geo)DataFrame
        待处理的数据.
    columns : List(String)
        列名列表.

    Returns
    -------
    gdf : (Geo)DataFrame
        返回含编码列的数据.
    lb_mapping_dic : Dict
        编码映射字典.

    '''
    from sklearn.preprocessing import LabelEncoder
    
    lb_mapping_dic={}
    for col in columns:
        lb_make=LabelEncoder()
        gdf['LB_'+col]=lb_make.fit_transform(gdf[col])
        lb_mapping=dict(zip(lb_make.classes_, lb_make.transform(lb_make.classes_)))
        lb_mapping_dic[col]=lb_mapping
    return gdf,lb_mapping_dic

landuse_LB_uncropped_gdf,landuse_LB_uncropped_mapping=gdf_label_encoder(landuse_CH_uncropped_gdf,columns=['LANDUSE'])
landuse_LB_uncropped_gdf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>FIRST_COUN</th>
      <th>LANDUSE</th>
      <th>LANDUSE2</th>
      <th>OS_MGMT</th>
      <th>FAC_NAME</th>
      <th>PLATTED</th>
      <th>MODIFIER</th>
      <th>Shape_Leng</th>
      <th>Shape_Area</th>
      <th>geometry</th>
      <th>CHname</th>
      <th>parentClass</th>
      <th>LB_LANDUSE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>517.742137</td>
      <td>16718.995065</td>
      <td>POLYGON ((405755.359 4666594.654, 405736.826 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>477.507596</td>
      <td>11320.358746</td>
      <td>POLYGON ((406011.869 4666666.341, 406000.274 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>484.025949</td>
      <td>9845.643361</td>
      <td>POLYGON ((406661.062 4666744.922, 406603.092 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>700.439764</td>
      <td>17077.187161</td>
      <td>POLYGON ((406481.324 4666788.466, 406429.912 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>031</td>
      <td>1111</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>340.958375</td>
      <td>4876.261817</td>
      <td>POLYGON ((406280.974 4666876.257, 406240.166 4...</td>
      <td>独栋单户住宅</td>
      <td>住宅</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



对`LANDUSE`列土地利用类型编号编码，通过`landuse_CH_mappin`映射字典也建立编码和土地利用类型名称的字典映射。


```python
landuse_LB_uncropped_mapping_chname={landuse_CH_mapping[k]:v for k,v in landuse_LB_uncropped_mapping['LANDUSE'].items()}
landuse_LB_uncropped_mapping.update({'CHname':landuse_LB_uncropped_mapping_chname})
landuse_LB_uncropped_mapping
print(landuse_LB_uncropped_mapping)
```

    {'LANDUSE': {'1111': 0, '1112': 1, '1130': 2, '1140': 3, '1151': 4, '1211': 5, '1212': 6, '1214': 7, '1215': 8, '1216': 9, '1220': 10, '1240': 11, '1250': 12, '1310': 13, '1321': 14, '1322': 15, '1330': 16, '1340': 17, '1350': 18, '1360': 19, '1370': 20, '1380': 21, '1410': 22, '1420': 23, '1431': 24, '1432': 25, '1433': 26, '1450': 27, '1511': 28, '1512': 29, '1520': 30, '1530': 31, '1540': 32, '1550': 33, '1561': 34, '1562': 35, '1563': 36, '1564': 37, '1565': 38, '1570': 39, '2000': 40, '3100': 41, '3200': 42, '3300': 43, '3400': 44, '3500': 45, '4110': 46, '4120': 47, '4130': 48, '4140': 49, '4210': 50, '4220': 51, '4230': 52, '4240': 53, '5000': 54, '6000': 55, '9999': 56}, 'CHname': {'独栋单户住宅': 0, '连排单户住宅': 1, '多户住宅': 2, '托车移动住宅': 3, '住宅开发区内公共开放空间': 4, '购物广场': 5, '区域社区零售中心': 6, '单一大型零售点': 7, '城市混合用地': 8, '含住宅的城市混合用地': 9, '办公': 10, '文化娱乐': 11, '酒店旅馆': 12, '医疗设施': 13, 'K_12教育设施': 14, '大学教育设施': 15, '政府行政和服务': 16, '监狱和惩教设施': 17, '宗教设施': 18, '墓地': 19, '其他机构': 20, '国家实验室': 21, '矿物提取': 22, '一般工业': 23, '制造加工': 24, '仓储配送': 25, '不确定用地': 26, '贮存': 27, '铁路': 28, '高速公路': 29, '其他具有相关设施的线性交通': 30, '航空运输': 31, '独立停车场': 32, '通讯': 33, '公用事业通行权': 34, '废水处理设施': 35, '垃圾填埋场': 36, '其它公用设施废物': 37, '雨水管理': 38, '联运设施': 39, '农业': 40, '开放空间主要娱乐设施': 41, '高尔夫球场': 42, '开放空间主要保护区': 43, '非公共开放空间': 44, '步道或绿道': 45, '空置住宅用地': 46, '空置商业用地': 47, '空置工业用地': 48, '其它空置': 49, '在建住宅': 50, '在建商业': 51, '在建工业': 52, '其他或未知在建': 53, '水体': 54, '非包裹区域': 55, '未分类': 56}}
    

将土地利用类型编码映射字典写入到`PostgreSQL`数据库，先将嵌套字典转化为DataFrame格式数据，然后用`pandas`提供的`to_sql`方法写入。定义`df2postSQL()`函数将DataFrame类型数据写入至数据库；定义`postSQL2df()`函数从数据库读取表为DataFrame格式数据。


```python
def df2postSQL(df,table_name,if_exists='replace',**kwargs):
    '''
    将DataFrame格式数据写入PostgreSQL数据库

    Parameters
    ----------
    df : DataFrame
        DataFrame格式数据.
    table_name : string
        写入数据库中的表名.
    if_exists : string, optional
        包括{‘fail’, ‘replace’, ‘append’}. The default is 'replace'.
    **kwargs : kwargs
        接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）.

    Returns
    -------
    None.

    '''    
    from sqlalchemy import create_engine
    # The URI should start with postgresql:// instead of postgres://. SQLAlchemy used to accept both, but has removed support for the postgres name.
    engine=create_engine("postgresql://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    conn=engine.connect()
    df.to_sql(table_name, con=conn, if_exists=if_exists,index=False)    
    # gdf.to_postgis(table_name, con=engine, if_exists='replace', index=False,)  
    print("_"*50)    
    print('The GeoDataFrame has been written to the PostgreSQL database.The table name is {}.'.format(table_name))     
```


```python
import pandas as pd

landuse_LB_uncropped_mapping_reverse={k:{v_:k_ for k_,v_ in v.items()} for k,v in landuse_LB_uncropped_mapping.items()}
landuse_LB_uncropped_mapping_df=pd.DataFrame.from_dict(landuse_LB_uncropped_mapping_reverse)
landuse_LB_uncropped_mapping_df.reset_index(names=['label_encoder'],inplace=True)
df2postSQL(landuse_LB_uncropped_mapping_df,'landuse_lb',**args.db.db_info)  
```

    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is landuse_lb.
    


```python
def postSQL2df(table_name,**kwargs):    
    '''
    读取PostgreSQL数据库中的表为DataFrame格式数据

    Parameters
    ----------
    table_name : string
        待读取数据库中的表名.
    **kwargs : kwargs
        连接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）.

    Returns
    -------
    df : DataFrame
        从PostgreSQL中读取数据为DataFrame格式返回.
        
    '''
    from sqlalchemy import create_engine
    import pandas as pd   
    
    engine=create_engine("postgresql://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    conn=engine.connect()
    df=pd.read_sql('SELECT * FROM {}'.format(table_name), conn)

    print("_"*50)
    print('The data has been read from PostgreSQL database. The table name is {}.'.format(table_name))    
    return df 
```


```python
landuse_LB_uncropped_mapping_df=postSQL2df('landuse_lb',**args.db.db_info)
landuse_LB_uncropped_mapping_df.head()
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is landuse_lb.
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>label_encoder</th>
      <th>LANDUSE</th>
      <th>CHname</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1111</td>
      <td>独栋单户住宅</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1112</td>
      <td>连排单户住宅</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>1130</td>
      <td>多户住宅</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>1140</td>
      <td>托车移动住宅</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>1151</td>
      <td>住宅开发区内公共开放空间</td>
    </tr>
  </tbody>
</table>
</div>



#### 2）矢量SHP格式土地利用数据转栅格（raster）

矢量转栅格函数定义时是读入SHP格式文件，转换后直接将栅格写入到指定路径下，因此将预处理后的的GeoDataFrame格式土地利用数据先写入到本地指定路径磁盘中，存储为SHP格式文件。可以直接查看(Geo)DataFrame数据的列名，该列名就为SHP格式数据表（table）的字段（field）名，但是如果希望直接获取给定路径SHP文件的字段名，则定义`vectorLayer_attributeNames()`函数，可以直接返回字段名查看，方便矢量转栅格时，确定转换的字段。


```python
landuse_LB_uncropped_gdf.to_file(args.data.landuse_LB)
```

    C:\Users\richi\AppData\Local\Temp\ipykernel_39104\2380882267.py:1: UserWarning: Column names longer than 10 characters will be truncated when saved to ESRI Shapefile.
      landuse_LB_uncropped_gdf.to_file(args.data.landuse_LB)
    


```python
def vectorLayer_attributeNames(shp_fn):
    '''
    返回SHP文件的字段（属性）名

    Parameters
    ----------
    shp_fn : string
        shp格式文件路径.

    Returns
    -------
    final_attribs : list(string)
        包含的字段名.

    '''
    from osgeo import ogr
    
    source_ds=ogr.Open(shp_fn)
    lyr=source_ds.GetLayer()
    all_attribs=[attrib.name for attrib in lyr.schema]
    final_attribs=[attribs for attribs in all_attribs if attribs not in ['list of attributes to exclude']]
    
    return final_attribs
```


```python
landuse_attribs=vectorLayer_attributeNames(args.data.landuse_LB)
landuse_attribs
```




    ['FIRST_COUN',
     'LANDUSE',
     'LANDUSE2',
     'OS_MGMT',
     'FAC_NAME',
     'PLATTED',
     'MODIFIER',
     'Shape_Leng',
     'Shape_Area',
     'CHname',
     'parentClas',
     'LB_LANDUSE',
     'LB_CHname']



矢量转栅格主要调用`GDAL`、`OGR`底层库（相对`GeoPandas`、`rasterio`等库）提供的方法，主程序为`create_multiband_raster()`函数，可为参数`attribs`提供一个到多个字段名，对应转换为单波段或多波段栅格。然后逐字段的进行计算，先调用`rasterize()`函数将SHP单个字段转换为单波段栅格数据，再用`img_to_array()`函数提取单波段栅格数据的值，并将值追加到一个空列表`img_array_list`中，当循环完所有字段，将`img_array_list`列表转换为数组，最后调用`array_to_tif()`函数转化为单波段（如果只给了一个字段）或多波段（如果给了多个字段）栅格，并存储到指定文件路径下（文件名通常以.tif为后缀）。


```python
def rasterize(shp, attrib_name,cellSize=500,dtype='int32'):
    '''
    转换单个vector（polygon或points）shp格式数据为栅格数据

    Parameters
    ----------
    shp : String
        shp格式对象文件路径.
    attrib_name : String
        字段（属性）名.
    cellSize : numerical, optional
        栅格单元大小. The default is 500.
    dtype : String, optional
        数据类型，对应dtype_mapping = {'byte': gdal.GDT_Byte, 'uint8': gdal.GDT_Byte, 'uint16': gdal.GDT_UInt16, 'int8': gdal.GDT_Byte, 'int16': gdal.GDT_Int16, 'int32': gdal.GDT_Int32, 'uint32': gdal.GDT_UInt32, 'float32': gdal.GDT_Float32}. The default is 'int32'.

    Returns
    -------
    temp_out : TIFF
        栅格临时文件.

    '''
    import gdal
    import gdalnumeric as gdn
    import ogr
    import numpy as np
    import tempfile 
    
    # 定义空值（没有数据）的栅格数值 Define NoData value of new raster
    NoData_value=-9999
    
    # 打开.shp点数据，并返回地理区域范围 Open the data source and read in the extent
    source_ds=ogr.Open(shp)
    source_layer=source_ds.GetLayer()
    x_min, x_max, y_min, y_max=source_layer.GetExtent()
    
    # 使用GDAL库建立栅格 Create the destination data source
    x_res=int((x_max - x_min) / cellSize)
    y_res=int((y_max - y_min) / cellSize)    
      
    # create empty raster (.tif) as temporary file and set its projection and extent to
    # that of the reference raster
    temp_out = tempfile.NamedTemporaryFile(suffix='.tif').name
    memory_driver = gdal.GetDriverByName('GTiff')
    dtype_mapping = {'byte': gdal.GDT_Byte, 'uint8': gdal.GDT_Byte, 'uint16': gdal.GDT_UInt16, 'int8': gdal.GDT_Byte, 'int16': gdal.GDT_Int16, 'int32': gdal.GDT_Int32, 'uint32': gdal.GDT_UInt32, 'float32': gdal.GDT_Float32}
    out_raster_ds = memory_driver.Create(temp_out, x_res, y_res, 1,dtype_mapping[dtype]) # gdal.GDT_Float64;gdal.GDT_Byte
    out_raster_ds.SetGeoTransform((x_min, cellSize, 0, y_max, 0, -cellSize))
    outband=out_raster_ds.GetRasterBand(1)
    outband.SetNoDataValue(NoData_value)

    # open shapefile vector layer to retrieve and burn attribute into the empty raster
    gdal.RasterizeLayer(out_raster_ds, [1], source_layer, options=["ATTRIBUTE="+attrib_name])
    return temp_out 

def img_to_array(input_file, dim_ordering="channel_last", dtype="float32"):
    '''
    将栅格文件各层栅格值转换为（numpy）数组

    Parameters
    ----------
    input_file : TIFF
        栅格文件.
    dim_ordering : String, optional
        调整波段位置. The default is "channel_last".
    dtype : Strng, optional
        栅格存储数据类型. The default is "float32".

    Returns
    -------
    arr : numpy.ndarray
        各层的栅格单元值.

    '''
    import gdal
    import numpy as np
    import gdalnumeric as gdn
    # open input raster, retrieve bands and convert to image array
    file = gdal.Open(input_file)
    bands = [file.GetRasterBand(i) for i in range(1, file.RasterCount +1)]
    arr = np.array([gdn.BandReadAsArray(band) for band in bands]).astype(dtype)
    
    # reoder dimensions so that channels/bands are last
    if dim_ordering=="channel_last": arr = np.transpose(arr, [1,2,0])
    return arr 

def array_to_tif(array,inVector,dst_filename,cellSize=500):
    '''
    将数组（含多个波段值）写入栅格文件

    Parameters
    ----------
    array : numpy.ndarray
        数组形式各层的栅格单元值.
    inVector : String
        shp格式对象文件路径.
    dst_filename : String
        待保存的栅格文件路径.
    cellSize : numerical, optional
        栅格单元大小. The default is 500.

    Returns
    -------
    None.

    '''
    import gdal
    import ogr
    import os

    # if os.path.exists(dst_filename):
    #     os.remove(dst_filename)
    #     print("The file has been deleted successfully")
    # else:
    #     print("The file does not exist!")    
    
    NoData_value=-9999
    source_ds=ogr.Open(inVector)
    source_layer=source_ds.GetLayer()
    x_min, x_max, y_min, y_max=source_layer.GetExtent()
    x_res=int((x_max - x_min) / cellSize)
    y_res=int((y_max - y_min) / cellSize)      
    proj=source_layer.GetSpatialRef().ExportToWkt()
    
    # create empty raster (.tif) to which array will be written
    bands = array.shape[2]
    dtype = str(array.dtype)
    dtype_mapping = {'byte': gdal.GDT_Byte, 'uint8': gdal.GDT_Byte, 'uint16': gdal.GDT_UInt16, 'int8': gdal.GDT_Byte, 'int16': gdal.GDT_Int16, 'int32': gdal.GDT_Int32, 'uint32': gdal.GDT_UInt32, 'float32': gdal.GDT_Float32}
    driver = gdal.GetDriverByName('GTiff')
    output = driver.Create(dst_filename, x_res, y_res, bands, dtype_mapping[dtype])
    # set output image extent and projection
    output.SetGeoTransform((x_min, cellSize, 0, y_max, 0, -cellSize))
    output.SetProjection(proj)
    
    # write image array into empty raster
    for i in range(bands): output.GetRasterBand(i+1).WriteArray(array[:, :, i])
    output.FlushCache() 

def create_multiband_raster(attribs,inVector,dst_filename,cellSize=500,dtype='int32'):
    '''
    vector(SHP,.shp)格式文件转栅格，主程序
    ref_Rasterize: How to create multiband raster from vector attributes using python https://tkawuah.github.io/Blog1.html

    Parameters
    ----------
    attribs : List(String)
        待存储的.shp属性值列表.
    inVector : .shp
        .shp格式文件路径.
    dst_filename : Stirng-TIFF(.tiff)
        栅格保存路径名，通常以.tif为后缀名.
    cellSize : numercial, optional
        栅格单元大小. The default is 500.
    dtype : String, optional
        栅格单元存储数据的类型。dtype_mapping = {'byte': gdal.GDT_Byte, 'uint8': gdal.GDT_Byte, 'uint16': gdal.GDT_UInt16, 'int8': gdal.GDT_Byte, 'int16': gdal.GDT_Int16, 'int32': gdal.GDT_Int32, 'uint32': gdal.GDT_UInt32, 'float32': gdal.GDT_Float32}. The default is 'int32'.

    Returns
    -------
    None.

    '''
    import numpy as np
    
    img_array_list=[]
    for i in attribs:    
        fx=rasterize(inVector, i,cellSize=cellSize,dtype=dtype)
        fx_array=img_to_array(fx,dtype=dtype)
        img_array_list.append(fx_array)          

    fx_multi=np.concatenate(img_array_list, axis=-1)
    array_to_tif(fx_multi,inVector,dst_filename,cellSize=cellSize)  
    print('The raster was written successfully!')
```


```python
landuse_attribs_selection=['lB_LANDUSE']
create_multiband_raster(landuse_attribs_selection,args.data.landuse_LB,args.data.landuse_tif,cellSize=5)    
```

    The raster was written successfully!
    

用`rasterio`库打开栅格文件，用`EarthPy`库的`earthpy.plot.plot_bands`方法打印单波段地图。


```python
import rasterio as rio
with rio.open(args.data.landuse_tif) as src:    
    landuse_array=src.read()
```


```python
import earthpy.plot as ep
import copy
landuse_array_copy=copy.deepcopy(landuse_array,)
landuse_array_copy[landuse_array_copy==-9999]=-1
ep.plot_bands(landuse_array_copy,figsize=(10, 15),cmap='twilight');
```

<img src="./imgs/2_7_6/output_34_0.png" height='auto' width='auto' title="caDesign">
    



#### 3）土地利用地图打印

在2.7.4一节解释MCD12Q1_v006 土地覆盖类型数据集时，通过`cmap_patch_build()`函数构建颜色的`cmap`、`norm`和`patches`变量，按栅格单元值对应给定的颜色，打印栅格地图。本次则直接打印GeoDataFrame格式地图数据，且将二级土地利用分类按照一级分类分配的色系赋予颜色。定义`colorsGrouped_cmapBased()`函数用于生成分组的颜色字典。


```python
landuse_parentClass_mapping_2=landuse_mapping_df.landuse_parentClass_mapping_2.to_dict()

landuse_parentClass_mapping_inverse={}
for k, v in landuse_parentClass_mapping_2.items():
    landuse_parentClass_mapping_inverse[v]=landuse_parentClass_mapping_inverse.get(v, [])+[k]   
print(landuse_parentClass_mapping_inverse)  
```

    {'城市化区域': ['1000'], '住宅': ['1110', '1111', '1112', '1130', '1140', '1150', '1151'], '商业': ['1200', '1210', '1211', '1212', '1214', '1215', '1216', '1220', '1240', '1250'], '机构': ['1300', '1310', '1320', '1321', '1322', '1330', '1340', '1350', '1360', '1370', '1380'], '工业': ['1400', '1410', '1420', '1430', '1431', '1432', '1433', '1450'], '交通_通讯_公共事业和垃圾处理': ['1500', '1510', '1511', '1512', '1520', '1530', '1540', '1550', '1560', '1561', '1562', '1563', '1564', '1565', '1570'], '其它': ['2000', '4000', '4100', '4110', '4120', '4130', '4140', '4200', '4210', '4220', '4230', '4240', '9999'], '开放空间': ['3000', '3100', '3200', '3300', '3400', '3500'], '水体': ['5000'], '非包裹区域': ['6000']}
    


```python
def colorsGrouped_cmapBased(palettes,group_dict):
    '''
    指定分组的cmap色系，根据分组字典生成分组颜色

    Parameters
    ----------
    palettes : dict
        指定分组色系，例如{'住宅':"YlOrBr", 
                          商业':"Reds"}.
    group_dict : dict
        指定分组字典，例如{'住宅': ['1110', '1111', '1112', '1130', '1140', '1150', '1151'], 
                         '商业': ['1200', '1210', '1211', '1212', '1214', '1215', '1216', '1220', '1240', '1250']}.

    Returns
    -------
    L2_pal_hex_dict : dict
        分组成员16进制颜色列表.

    '''
    import seaborn as sns
    
    L2_pal_hex_dict={}
    for L1,pal in palettes.items():
        L2=group_dict[L1]
        pal=sns.color_palette(palettes[L1],len(L2))
        pal_hex=pal.as_hex()
        L1_L2_pal_hex=dict(zip(L2,pal_hex))
        L2_pal_hex_dict.update(L1_L2_pal_hex)       
        
    return L2_pal_hex_dict    
    
palettes={'住宅':"YlOrBr", 
          '商业':"Reds",
          '机构':"GnBu", 
          '工业':"Purples", 
          '交通_通讯_公共事业和垃圾处理':"Greys",
          '其它':"PuBuGn", 
          '开放空间':"YlGn", 
          '非包裹区域':"gray",
          '水体':'Blues'}

L2_pal_hex_dict=colorsGrouped_cmapBased(palettes,landuse_parentClass_mapping_inverse)
print(L2_pal_hex_dict)
```

    {'1110': '#fff7bc', '1111': '#fee390', '1112': '#fec34f', '1130': '#fe9829', '1140': '#eb6f14', '1150': '#cb4b02', '1151': '#983404', '1200': '#fee6da', '1210': '#fdd0bc', '1211': '#fcb499', '1212': '#fc9576', '1214': '#fb7858', '1215': '#f7593f', '1216': '#ec382b', '1220': '#d11e1f', '1240': '#b61319', '1250': '#940b13', '1300': '#e8f6e2', '1310': '#daf0d4', '1320': '#ccebc5', '1321': '#b4e2ba', '1322': '#99d7ba', '1330': '#7accc4', '1340': '#5dbbce', '1350': '#42a6cc', '1360': '#2a8bbe', '1370': '#1373b2', '1380': '#085a9d', '1400': '#f1eff6', '1410': '#dfdfed', '1420': '#c6c7e1', '1430': '#acaad1', '1431': '#908dc2', '1432': '#796eb2', '1433': '#65479e', '1450': '#51228d', '1500': '#f7f7f7', '1510': '#f0f0f0', '1511': '#e4e4e4', '1512': '#d9d9d9', '1520': '#cbcbcb', '1530': '#bdbdbd', '1540': '#a9a9a9', '1550': '#959595', '1560': '#848484', '1561': '#727272', '1562': '#626262', '1563': '#515151', '1564': '#3a3a3a', '1565': '#242424', '1570': '#111111', '2000': '#f4ebf5', '4000': '#e8e0ef', '4100': '#d9d6e9', '4110': '#c4cbe3', '4120': '#acc0dd', '4130': '#8cb5d6', '4140': '#66a9cf', '4200': '#4b9ac6', '4210': '#2e8eb8', '4220': '#11859a', '4230': '#027b7b', '4240': '#016f5f', '9999': '#015b4a', '3000': '#f3fab6', '3100': '#ccea9d', '3200': '#97d385', '3300': '#58b669', '3400': '#2c8f4b', '3500': '#056c39', '6000': '#808080', '5000': '#6aaed6'}
    

为了定位芝加哥城位置，读取芝加哥城市边界，该数据来源于[Chicago Data Portal，CDP](https://data.cityofchicago.org/)<sup>③</sup>。将分组颜色字典`L2_pal_hex_dict`按照土地利用类型编号追加到`lu4plot`列中，用`GeoDataFrame.plot`方法直接打印地图。


```python
import geopandas as gpd
Chicago_boundary_gdf=gpd.read_file(args.data.Chicago_boundaries_city)
Chicago_boundary_gdf.to_crs(lu4plot.crs,inplace=True)
```


```python
lu4plot=landuse_CH_uncropped_gdf.copy(deep=True)
lu4plot['colors']=lu4plot.LANDUSE.apply(lambda row:L2_pal_hex_dict[row])
```


```python
from matplotlib_scalebar.scalebar import ScaleBar
import matplotlib.pyplot as plt

ax=lu4plot.plot(color=lu4plot['colors'],figsize=(20, 50),legend=True)
Chicago_boundary_gdf.plot(color='none',edgecolor='k',linewidth=2,ax=ax,linestyle='-')
ax.add_artist(ScaleBar(1))  
ax.set_axis_off()
plt.tight_layout()
plt.show()
```

<img src="./imgs/2_7_6/output_41_0.png" height='auto' width='auto' title="caDesign">
    


上述地图并未打印图例，为了方便图例的排布，定义`plot_colortable_updated()`函数单独打印图例。该函数迁移更新于`matplotlib`库提供的案例，为了方便参数调整，将主要的参数作为关键字参数传入更新。


```python
def plot_colortable_updated(colors,sort_colors=True,emptycols=0,**args):
    '''
    绘制一个matplotlib支持命名颜色的列表，迁移更新于matplotlib库“List of named colors”，https://matplotlib.org/3.1.1/gallery/color/named_colors.html
    查看2.7.4章 plot_colortable()函数，为该函数的升级版本

    Parameters
    ----------
    colors : dict
        键为图例名，值为16进制颜色.
    sort_colors :  bool, optional
        是否排序颜色. The default is True.
    emptycols : int, optional
        调整列数量，避免列中出现空值. The default is 0.
    **args : kargs
        图表打印参数调整，默认为：
                        setting=dict(
                                    cell_width = 212,
                                    cell_height = 22,
                                    swatch_width = 48,
                                    margin = 12,
                                    topmargin = 40,
                                    title='Base Colors',
                                    fig_width_fine_tuning=0,
                                    fig_height_fine_tuning=0,
                                    ).

    Returns
    -------
    fig : matplotlib.figure.Figure
        matplotlib图表.
    
    '''
    from matplotlib.patches import Rectangle
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors
    import matplotlib as mpl    
    import numpy as np

    mpl.rcParams['font.sans-serif'] = ['SimHei']
    mpl.rcParams['font.serif'] = ['SimHei']     
    
    setting=dict(
                cell_width = 212,
                cell_height = 22,
                swatch_width = 48,
                margin = 12,
                topmargin = 40,
                title='Base Colors',
                fig_width_fine_tuning=0,
                fig_height_fine_tuning=0,
                )

    setting.update(args)
    cell_width=setting['cell_width']
    cell_height=setting['cell_height']
    swatch_width=setting['swatch_width']
    margin=setting['margin']
    topmargin=setting['topmargin']  
    fig_width_fine_tuning=setting['fig_width_fine_tuning']
    fig_height_fine_tuning=setting['fig_height_fine_tuning']
    
    # Sort colors by hue, saturation, value and name.
    if sort_colors is True:
        by_hsv = sorted((tuple(mcolors.rgb_to_hsv(mcolors.to_rgb(color))),
                         name)
                        for name, color in colors.items())
        names = [name for hsv, name in by_hsv]
    else:
        names = list(colors)

    n = len(names)
    ncols = 4 - emptycols
    nrows = n // ncols + int(n % ncols > 0)

    width = cell_width * 4 + 2 * margin+fig_width_fine_tuning
    height = cell_height * nrows + margin + topmargin+fig_height_fine_tuning
    dpi = 72

    fig, ax = plt.subplots(figsize=(width / dpi, height / dpi), dpi=dpi)
    fig.subplots_adjust(margin/width, margin/height,
                        (width-margin)/width, (height-topmargin)/height)
    ax.set_xlim(0, cell_width * 4)
    ax.set_ylim(cell_height * (nrows-0.5), -cell_height/2.)
    ax.yaxis.set_visible(False)
    ax.xaxis.set_visible(False)
    ax.set_axis_off()
    ax.set_title(setting['title'], fontsize=24, loc="left", pad=10)

    for i, name in enumerate(names):
        row = i % nrows
        col = i // nrows
        y = row * cell_height

        swatch_start_x = cell_width * col
        text_pos_x = cell_width * col + swatch_width + 7

        ax.text(text_pos_x, y, name, fontsize=14,
                horizontalalignment='left',
                verticalalignment='center')
        ax.add_patch(
            Rectangle(xy=(swatch_start_x, y-9), width=swatch_width,
                      height=18, facecolor=colors[name], edgecolor='0.7')
        )

    return fig
```

`plot_colortable_updated()`函数的`colors`参数为一个字典，键为图例名，值为图例的16进制颜色。


```python
L2_pal_hex_CH_dict={landuse_EN2CH_mapping[landuse_EN_mapping[k]]:v for k,v in L2_pal_hex_dict.items()}
print(L2_pal_hex_CH_dict)
```

    {'单户住宅': '#fff7bc', '独栋单户住宅': '#fee390', '连排单户住宅': '#fec34f', '多户住宅': '#fe9829', '托车移动住宅': '#eb6f14', '相关住宅用地': '#cb4b02', '住宅开发区内公共开放空间': '#983404', '商业': '#fee6da', '主要零售服务': '#fdd0bc', '购物广场': '#fcb499', '区域社区零售中心': '#fc9576', '单一大型零售点': '#fb7858', '城市混合用地': '#f7593f', '含住宅的城市混合用地': '#ec382b', '办公': '#d11e1f', '文化娱乐': '#b61319', '酒店旅馆': '#940b13', '机构': '#e8f6e2', '医疗设施': '#daf0d4', '教育设施': '#ccebc5', 'K_12教育设施': '#b4e2ba', '大学教育设施': '#99d7ba', '政府行政和服务': '#7accc4', '监狱和惩教设施': '#5dbbce', '宗教设施': '#42a6cc', '墓地': '#2a8bbe', '其他机构': '#1373b2', '国家实验室': '#085a9d', '工业': '#f1eff6', '矿物提取': '#dfdfed', '一般工业': '#c6c7e1', '通用电气工业': '#acaad1', '制造加工': '#908dc2', '仓储配送': '#796eb2', '不确定用地': '#65479e', '贮存': '#51228d', '转运与垃圾管理': '#f7f7f7', '运输通行权': '#f0f0f0', '铁路': '#e4e4e4', '高速公路': '#d9d9d9', '其他具有相关设施的线性交通': '#cbcbcb', '航空运输': '#bdbdbd', '独立停车场': '#a9a9a9', '通讯': '#959595', '公用事业和废物处理设施': '#848484', '公用事业通行权': '#727272', '废水处理设施': '#626262', '垃圾填埋场': '#515151', '其它公用设施废物': '#3a3a3a', '雨水管理': '#242424', '联运设施': '#111111', '农业': '#f4ebf5', '空置在建': '#e8e0ef', '空置未开发土地': '#d9d6e9', '空置住宅用地': '#c4cbe3', '空置商业用地': '#acc0dd', '空置工业用地': '#8cb5d6', '其它空置': '#66a9cf', '在建': '#4b9ac6', '在建住宅': '#2e8eb8', '在建商业': '#11859a', '在建工业': '#027b7b', '其他或未知在建': '#016f5f', '未分类': '#015b4a', '开放空间': '#f3fab6', '开放空间主要娱乐设施': '#ccea9d', '高尔夫球场': '#97d385', '开放空间主要保护区': '#58b669', '非公共开放空间': '#2c8f4b', '步道或绿道': '#056c39', '非包裹区域': '#808080', '水体': '#6aaed6'}
    


```python
fig=plot_colortable_updated(L2_pal_hex_CH_dict,sort_colors=False, emptycols=1,title='土地利用类型：',fig_width_fine_tuning=200)
```

<img src="./imgs/2_7_6/output_46_0.png" height='auto' width='auto' title="caDesign">
    


#### 4）样方（区域）统计

样方统计实现的方式是由给定的样方（Polygon对象）对栅格数据采样，因此需要首先构建用于采样的样方，定义`rec_quadrats_gdf()`函数实现网格式样方GeoDataFrame格式数据的构建。在QGIS平台或者在Google Earth下确定待分析区域的左下角和右上角坐标。投影坐标系使用wgs84，然后再根据需要转换为对应栅格的坐标系用于样方统计。后续分析需要不同样方组之间进行相关指数比较，因此定义两组样方，分别标识为`a`和`b`。


```python
def rec_quadrats_gdf(leftBottom_coordi,rightTop_coordi,h_distance,v_distance,crs=4326,to_crs=None):
    '''
    构建网格式样方

    Parameters
    ----------
    leftBottom_coordi : list(float)
        定位左下角坐标.
    rightTop_coordi : list(float)
        定位右上角坐标.
    h_distance : float
        单个样方宽度.
    v_distance : float
        单个样方长度.
    crs : int, optional
        投影编号. The default is 4326.
    to_crs : int, optional
        转换投影编号. The default is None.

    Returns
    -------
    grids_gdf : GeoDataFrame
        Polygon地理几何形式的GeoDataFrame格式样方数据.

    '''    
    import numpy as np
    from shapely.geometry import MultiLineString
    from shapely.ops import polygonize
    import geopandas as gpd
    
    x=np.arange(leftBottom_coordi[0], rightTop_coordi[0], h_distance)
    y=np.arange(leftBottom_coordi[1], rightTop_coordi[1], v_distance)
    hlines=[((x1, yi), (x2, yi)) for x1, x2 in zip(x[:-1], x[1:]) for yi in y]
    vlines=[((xi, y1), (xi, y2)) for y1, y2 in zip(y[:-1], y[1:]) for xi in x]
    grids=list(polygonize(MultiLineString(hlines + vlines)))
    
    grids_gdf=gpd.GeoDataFrame({'geometry':grids},crs=crs)
    if to_crs:
        grids_gdf.to_crs(to_crs,inplace=True)
        
    return grids_gdf

cell_size=0.02
pt_leftBottom_a=[-87.96487621023101,41.81454769756404]
pt_rightTop_a=[-87.81441541486787,41.96133871743053]    
quadrats_a_gdf=rec_quadrats_gdf(pt_leftBottom_a,pt_rightTop_a,cell_size,cell_size,args.gi.epsg_wgs84,args.gi.Chicago_epsg)
gpd2postSQL(quadrats_a_gdf,'quadrats_a',**args.db.db_info)  

quadrats_a_gdf.plot(cmap='tab20b')
```

    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is quadrats_a.
    




    <AxesSubplot: >



<img src="./imgs/2_7_6/output_48_2.png" height='auto' width='auto' title="caDesign">
    


建立`b`组样方。


```python
pt_leftBottom_b=[-87.79790142513288,41.81454769756404]
pt_rightTop_b=[-87.64744062976973,41.96133871743053]    
quadrats_b_gdf=rec_quadrats_gdf(pt_leftBottom_b,pt_rightTop_b,cell_size,cell_size,args.gi.epsg_wgs84,args.gi.Chicago_epsg)
gpd2postSQL(quadrats_b_gdf,'quadrats_b',**args.db.db_info) 
```

    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is quadrats_b.
    

为了核实构建的样方是否对位到栅格数据区域，叠加打印栅格数据和样方数据，从地图中确定构建的样方无误后再进行样方统计。


```python
ax=lu4plot.plot(color=lu4plot['colors'],figsize=(20/4, 50/4),legend=True)
quadrats_a_gdf.plot(color='none',edgecolor='k',linewidth=1,ax=ax,linestyle='--')
quadrats_b_gdf.plot(color='none',edgecolor='r',linewidth=1,ax=ax,linestyle='--')
ax.add_artist(ScaleBar(1))  
ax.set_axis_off()
plt.tight_layout()
plt.show()
```

<img src="./imgs/2_7_6/output_52_0.png" height='auto' width='auto' title="caDesign">
    



样方统计采用`rasterstats`库提供的`zonal_stats`方法实现，其统计量包括'count'单元数量, 'min'最小值, 'max'最大值, 'mean'均值, 'sum'单元值总和, 'std'标准差, 'median'中位数, 'majority'单元数量最多的分类, 'minority'单元数据最少的分类, 'unique'样方包含的分类数量, 'range'栅格单元数值区间, 'nodata'和'nan'为空值分类数的和。默认的`zonal_stats`方法并未给出样方类别的频数统计（各个类别的栅格单元数量），因此使用其提供的`add_stats`参数传入自定义的`frequency()`函数计算。


```python
def zonal_stats_raster(raster_fn,sampling_zone,band=1,stats=['majority'],add_stats=['frequency'],nodata=-9999):#
    '''
    区域统计，包括['count', 'min', 'max', 'mean', 'sum', 'std', 'median', 'majority', 'minority', 'unique', 'range', 'nodata', 'nan']，以及自定义的'frequency'，即频数统计

    Parameters
    ----------
    raster_fn : String
        待区域统计的栅格数据路径名.
    sampling_zone : GeoDataFrame
        用于栅格区域统计的polygon几何对象.
    band : int, optional
        数据波段. The default is 1.
    stats : List(String), optional
        默认统计的统计量名称. The default is ['majority'].
    add_stats :List(String) , optional
        自定义统计量名. The default is ['frequency'].

    Returns
    -------
    GeoDataFrame
        返回统计量值.

    '''
    import rasterio as rio
    import rasterstats as rst
    import pandas as pd
     
    sampling_zone_copy=sampling_zone.copy(deep=True)
    
    def frequency(x):
        data=x.data[~x.mask]
        return pd.value_counts(data)
    
    add_stats_dict={'frequency':frequency}
    with rio.open(raster_fn,'r') as src:
        band=src.read(band)
        sampling_zone_copy=sampling_zone_copy.to_crs(src.crs)
        zs_result=rst.zonal_stats(sampling_zone_copy,band,nodata=nodata,affine=src.transform,stats=stats,add_stats={i:add_stats_dict[i] for i in add_stats})
    
    for stat in stats:
        sampling_zone_copy[stat]=[dic[stat] for dic in zs_result]
    for stat in add_stats:
        if stat=='frequency':
            fre=pd.concat([dic[stat].to_frame().T for dic in zs_result])
            fre.rename(columns={col:"{}_{}".format(stat[:3],col) for col in fre.columns},inplace=True)
            fre.reset_index(inplace=True)  
    try:        
        zonal_stats_gdf=pd.concat([sampling_zone_copy,fre],axis=1)   
        
    except:
        zonal_stats_gdf=sampling_zone_copy
    return zonal_stats_gdf
    
landuse_zonal_stats_a_gdf=zonal_stats_raster(args.data.landuse_tif,quadrats_a_gdf,stats=['count'])    
```


```python
print(landuse_zonal_stats_a_gdf.columns.to_list())
landuse_zonal_stats_a_gdf.head()
```

    ['geometry', 'count', 'index', 'fre_0', 'fre_43', 'fre_55', 'fre_10', 'fre_46', 'fre_4', 'fre_14', 'fre_29', 'fre_2', 'fre_16', 'fre_1', 'fre_54', 'fre_8', 'fre_12', 'fre_47', 'fre_41', 'fre_5', 'fre_42', 'fre_34', 'fre_7', 'fre_6', 'fre_49', 'fre_37', 'fre_19', 'fre_23', 'fre_27', 'fre_11', 'fre_13', 'fre_24', 'fre_18', 'fre_20', 'fre_50', 'fre_35', 'fre_45', 'fre_28', 'fre_30', 'fre_33', 'fre_32', 'fre_9', 'fre_15', 'fre_38', 'fre_22', 'fre_26', 'fre_25', 'fre_48', 'fre_40', 'fre_56', 'fre_51', 'fre_53', 'fre_31', 'fre_39', 'fre_52', 'fre_36', 'fre_3', 'fre_44']
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>count</th>
      <th>index</th>
      <th>fre_0</th>
      <th>fre_43</th>
      <th>fre_55</th>
      <th>fre_10</th>
      <th>fre_46</th>
      <th>fre_4</th>
      <th>fre_14</th>
      <th>...</th>
      <th>fre_40</th>
      <th>fre_56</th>
      <th>fre_51</th>
      <th>fre_53</th>
      <th>fre_31</th>
      <th>fre_39</th>
      <th>fre_52</th>
      <th>fre_36</th>
      <th>fre_3</th>
      <th>fre_44</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((421520.398 4629617.466, 419859.219 4...</td>
      <td>147546</td>
      <td>0</td>
      <td>47103</td>
      <td>23532.0</td>
      <td>19612</td>
      <td>18269.0</td>
      <td>10250.0</td>
      <td>7814.0</td>
      <td>5845.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((421544.820 4631838.009, 419884.158 4...</td>
      <td>147500</td>
      <td>0</td>
      <td>18338</td>
      <td>NaN</td>
      <td>29150</td>
      <td>27149.0</td>
      <td>541.0</td>
      <td>8627.0</td>
      <td>1245.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((421569.252 4634058.559, 419909.107 4...</td>
      <td>147453</td>
      <td>0</td>
      <td>35973</td>
      <td>6802.0</td>
      <td>39109</td>
      <td>5126.0</td>
      <td>1261.0</td>
      <td>4477.0</td>
      <td>1366.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((421593.693 4636279.118, 419934.066 4...</td>
      <td>147408</td>
      <td>0</td>
      <td>72298</td>
      <td>4878.0</td>
      <td>32851</td>
      <td>728.0</td>
      <td>597.0</td>
      <td>192.0</td>
      <td>6550.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((421618.144 4638499.683, 419959.034 4...</td>
      <td>147363</td>
      <td>0</td>
      <td>74336</td>
      <td>2010.0</td>
      <td>29595</td>
      <td>489.0</td>
      <td>550.0</td>
      <td>NaN</td>
      <td>848.0</td>
      <td>...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 58 columns</p>
</div>



为了方便查看DataFrame中一列值对应的另一类值，定义匿名函数`colA2colB`，例如，为了知道`fre_41`列名对应的土地利用类型中文名是什么，传入`landuse_LB_uncropped_mapping_df`数据，两个列名，及编号列中的数值获得对应的分类名为`开放空间主要娱乐设施`。


```python
colA2colB=lambda gdf,colA,colB,v:gdf[gdf[colA]==v][colB]
colA2colB(landuse_LB_uncropped_mapping_df,'label_encoder','CHname',41)
```




    41    开放空间主要娱乐设施
    Name: CHname, dtype: object



不平等性和空间隔离分析主要分析开放空间在样方中的分布情况，因此按照'开放空间'的一级分类合并二级分类，包括'开放空间主要娱乐设施'、'高尔夫球场'、'开放空间主要保护区'、'非公共开放空间'和'步道或绿道'。同时，保存至数据库方便调用；并打印统计样方，查看统计结果。


```python
open_space_idxes=landuse_parentClass_mapping_inverse['开放空间']  
open_space_lbs=[landuse_LB_uncropped_mapping['LANDUSE'][i] for i in open_space_idxes if i in landuse_LB_uncropped_mapping['LANDUSE'].keys()]
open_space_cols=[f"fre_{i}" for i in open_space_lbs]
print(open_space_cols)
```

    ['fre_41', 'fre_42', 'fre_43', 'fre_44', 'fre_45']
    

开放空间包含的二级分类有5类，但是分析的样方组不一定包括所有二级分类，因此使用集合交集的方法移除未包含的类别。


```python
landuse_zonal_stats_a_columns=set(landuse_zonal_stats_a_gdf.columns.to_list())
open_space_cols_a=landuse_zonal_stats_a_columns.intersection(set(open_space_cols))
print(open_space_cols_a)

landuse_zonal_stats_a_gdf['open_space']=landuse_zonal_stats_a_gdf[open_space_cols_a].sum(axis=1)
gpd2postSQL(landuse_zonal_stats_a_gdf,'landuse_zonal_stats_a',**args.db.db_info)  
ax=landuse_zonal_stats_a_gdf.plot('open_space',k=5,scheme='Quantiles',legend=True,cmap='Reds')
leg=ax.get_legend()
leg.set_bbox_to_anchor((-0.4, 0.1, 0.2, 0.2))
```

    {'fre_44', 'fre_45', 'fre_41', 'fre_43', 'fre_42'}
    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is landuse_zonal_stats_a.
    

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\geopandas\geodataframe.py:1299: FutureWarning: Passing a set as an indexer is deprecated and will raise in a future version. Use a list instead.
      result = super(GeoDataFrame, self).__getitem__(key)
    

<img src="./imgs/2_7_6/output_61_2.png" height='auto' width='auto' title="caDesign">
    



```python
landuse_zonal_stats_b_gdf=zonal_stats_raster(args.data.landuse_tif,quadrats_b_gdf,stats=['count'])  
landuse_zonal_stats_b_columns=set(landuse_zonal_stats_b_gdf.columns.to_list())
open_space_cols_b=landuse_zonal_stats_b_columns.intersection(set(open_space_cols))
print(open_space_cols_b)

landuse_zonal_stats_b_gdf['open_space']=landuse_zonal_stats_b_gdf[list(open_space_cols_b)].sum(axis=1)
gpd2postSQL(landuse_zonal_stats_b_gdf,'landuse_zonal_stats_b',**args.db.db_info)  
ax=landuse_zonal_stats_b_gdf.plot('open_space',k=5,scheme='Quantiles',legend=True,cmap='Reds')
leg=ax.get_legend()
leg.set_bbox_to_anchor((-0.4, 0.1, 0.2, 0.2))
```

    {'fre_41', 'fre_42', 'fre_45'}
    __________________________________________________
    The GeoDataFrame has been written to the PostgreSQL database.The table name is landuse_zonal_stats_b.
    

<img src="./imgs/2_7_6/output_62_1.png" height='auto' width='auto' title="caDesign">
    



### 2.7.2.2 不平等性

基尼系数（Gini coefficient）是由意大利统计学家Corrado Gini于1912年提出， 作为社会收入不平等的一种测量方法<sup>[2]</sup>。基尼系数常与Max O. Lorenz于1905年提出的洛伦兹曲线（Lorenz curve）联系在一起。基尼系数是对分析对象一个不平等的衡量标准，定义为所有成对的个体在某种衡量标准下的绝对差异的均值，其公式为：$G= \frac{ \sum_{i=1}^n  \sum_{j=1}^n  |  x_{i}-   x_{j} | }{2 n^{2} \overline{x}  }=\frac{2}{ n^{2} \overline{x}  }  \sum_{i=1}^n i( x_{i}- \overline{x}  ) $ ，式中，$x$为观测值，$n$是观测值的数量，$\overline{x}$是观测值均值。当所有观测值均相等时，最小值为0，观察值之间的差异越大，值越趋近于1，理论上最大值为1。

洛伦兹曲线（Lorenz curve），为对观测值排序后，从低到高每$\frac{1}{n}$（$\infty >n> 1$）数量的观测值之和（累积和）占总观测值之和的比例所绘制的曲线。

下述`gini_coefficient()`函数用于计算基尼系数；`lorenz_curve()`函数用于计算和绘制洛伦兹曲线。


```python
landuse_zonal_stats_a_gdf=postSQL2gpd(table_name='landuse_zonal_stats_a',**args.db.db_info)    
landuse_zonal_stats_a_gdf.fillna(0,inplace=True)
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is landuse_zonal_stats_a.
    

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning: Did not recognize type 'geometry' of column 'geometry'
      pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])
    


```python
def gini_coefficient(arr_):
    '''
    计算基尼系数

    Parameters
    ----------
    arr_ : numpy.ndarray(1D)
        一维数组（观测值）.

    Returns
    -------
    float
        基尼系数.

    '''    
    import numpy as np
    
    arr=np.sort(arr_)
    count=arr.size
    coefficient=2/count
    indexes=np.arange(1, count + 1)
    weighted_sum=(indexes * arr).sum()
    total=arr.sum()
    constant=(count + 1) / count
    return coefficient * weighted_sum / total - constant

gini_os_custom=gini_coefficient(landuse_zonal_stats_a_gdf['open_space'])
print(gini_os_custom)
```

    0.5555786867146546
    


```python
def lorenz_curve(arr_,plot=True,figsize=(5,5)):
    '''
    绘制洛伦兹曲线

    Parameters
    ----------
    arr_ :  numpy.ndarray(1D)
        一维数组（观测值）.
    plot : TYPE, optional
        DESCRIPTION. The default is True.

    Returns
    -------
    lorenz_curve_vals : list(float)
        从低到高累积占比值.

    '''    
    import numpy as np
    import matplotlib.pyplot as plt
    
    # this divides the prefix sum by the total sum
    # this ensures all the values are between 0 and 1.0
    arr=np.sort(arr_)
    scaled_prefix_sum = arr.cumsum() / arr.sum()
    # this prepends the 0 value (because 0% of all people have 0% of all wealth)
    lorenz_curve_vals=np.insert(scaled_prefix_sum, 0, 0)
    
    if plot:        
        fig=plt.figure(figsize=figsize)
        plt.plot(np.linspace(0.0, 1.0, lorenz_curve_vals.size), lorenz_curve_vals)
        plt.plot([0,1], [0,1])
        plt.show()    
    return lorenz_curve_vals

lorenz_curve(landuse_zonal_stats_a_gdf['open_space']);
```

<img src="./imgs/2_7_6/output_66_0.png" height='auto' width='auto' title="caDesign">
    



`inequality`库提供了`inequality.gini.Gini`方法可以直接计算基尼系数，其计算结果同上述自定义函数计算结果。参考联合国开发计划署（United Nations Development Programme，UNDP）对收入分配基尼系数等级的划分，0.40是收入分配差距的“警戒线”，0.29小于0.40，表明各个样方开放空间的分布不平等性（不均衡性、不公平性）不明显，即具有一定的平等性。


```python
import inequality

gini_os=inequality.gini.Gini(landuse_zonal_stats_a_gdf['open_space'])
print(gini_os.g)
```

    0.5555786867146548
    

`inequality`库提供了`inequality.gini.Gini_Spatial`方法，在考虑空间权重条件下计算基尼系数，因为分析的各样方均匀排布，邻里单元的空间权重保持一致，因此从计算结果也可以发现，考虑空间权重后计算的基尼系数值同未考虑时计算的结果值。


```python
import libpysal.weights as LW
import numpy as np

np.random.seed(12345)
w=LW.Rook.from_dataframe(landuse_zonal_stats_a_gdf)
gini_os_w=inequality.gini.Gini_Spatial(landuse_zonal_stats_a_gdf['open_space'],w)
print(gini_os_w.g,gini_os_w.p_sim)
```

    0.5555786867146548 0.01
    

### 2.7.2.3 空间隔离<sup>[4]</sup>

#### 1) 空间隔离指数（ aspatial indexes）

* Dissimilarity

Dissimilarity指数由Duncan, O.和 B. Duncan (1955)提出，其公式为：$D = \sum_{i=1}^{I}\frac{n_{i.}\mid \tilde{s}_{ij}-\frac{n_{.j}}{n_{..}}\mid}{2n_{..}\frac{n_{.j}}{n_{..}}\left ( 1-\frac{n_{.j}}{n_{..}} \right )}，0 \leqslant D \leqslant 1$。从计算结果值可以得知有24%的开放空间必须置换到其它样方中才能达到完全平衡。


```python
landuse_zonal_stats_a_gdf[['open_space', 'count']]=landuse_zonal_stats_a_gdf[['open_space', 'count']].astype('int')
args_seg=[landuse_zonal_stats_a_gdf, 'open_space', 'count']
```


```python
import segregation.aspatial as sa
import tqdm as notebook_tqdm

dissim_idx=sa.Dissim(*args_seg)
print(dissim_idx.statistic)
```

    0.5194584397292389
    

 * Gini（变体）
    
基尼系数有十多种变体，`GiniSeg`方法计算的基尼系数公式为： $G=\sum_{i_1=1}^{I}\sum_{i_2=1}^{I}\frac{n_{i_1.}n_{i_2.}\mid \tilde{s}_{ij}^{i_1}-\tilde{s}_{ij}^{i_2}\mid}{2n_{..}^2\frac{n_{.j}}{n_{..}}\left ( 1-\frac{n_{.j}}{n_{..}} \right )}$。计算结果几近为0。


```python
giniSeg_idx=sa.GiniSeg(*args_seg)
print(giniSeg_idx.statistic)
```

    0.0078008151095141035
    

* Entropy  

Entropy（信息熵）指数计算公式为：$H = \sum_{i=1}^{I}\frac{n_{i.}\left ( E-E_i \right )}{En_{..}}$，式中，$E$为全局熵，公式为： $E = \frac{n_{.j}}{n_{..}} \ log\left ( \frac{1}{\frac{n_{.j}}{n_{..}}} \right )+\left ( 1-\frac{n_{.j}}{n_{..}} \right )log\left ( \frac{1}{1-\frac{n_{.j}}{n_{..}}} \right )$；$E_i$为空间单元熵，公式为： $E_i = \tilde{s}_ {ij} \ log\left ( \frac{1}{\tilde{s}_ {ij}} \right )+\left ( 1-\tilde{s}_ {ij} \right )log\left ( \frac{1}{1-\tilde{s}_ {ij}} \right )$。


```python
entropy_idx=sa.Entropy(*args_seg)
print(entropy_idx.statistic)
```

    0.12763678307822018
    

* Atkinson

Atkinson指数公式为： $A = 1 - \frac{\frac{n_{.j}}{n_{..}}}{1-\frac{n_{.j}}{n_{..}}}\left | \sum_{i=1}^{I}\left [ \frac{\left ( 1-\tilde{s}_{ij} \right )^{1-b}\tilde{s}_{ij}^bt_i}{\frac{n_{.j}}{n_{..}}n_{..}} \right ] \right |^{\frac{1}{1-b}}$，式中，$b$为一个形参，决定了如何对洛伦兹曲线的不同部分所带来的隔离增量进行加权。


```python
atkinson_idx=sa.Atkinson(*args_seg)
print(atkinson_idx.statistic)
```

    0.2652906513058595
    

* Concentration Profile

在*Measuring geographic segregation: a graph-based approach*一文中提到Concentration Profile 指数<sup>[5]</sup>，计算公式为： $R=\frac{\frac{n_{.j}}{n_{..}}-\left ( \int_{t=0}^{\frac{n_{.j}}{n_{..}}}\upsilon_tdt - \int_{t=\frac{n_{.j}}{n_{..}}}^{1}\upsilon_tdt \right )}{1-\frac{n_{.j}}{n_{..}}}$，式中，$\upsilon_t$为阈值比例，公式为：$\upsilon_t = \frac{\sum_{i=1}^{I}n_{ij}g(t,i)}{\sum_{i=1}^{I}n_{ij}}$，式中$g(t,i)$为一个逻辑函数，公式为：$  g(t,i) =  \begin{cases}    1 \mspace{10mu} if \ \frac{n_{ij}}{n_{i.}} \geqslant t \\    0 \mspace{10mu} \ otherwise.  \end{cases}$。

该指数提供了`plot`方法，可以打印图表查看估计值。


```python
ConProf_idx=sa.ConProf(*args_seg)
print(ConProf_idx.statistic)
ConProf_idx.plot()
```

    0.06110307400271944
    




    <matplotlib.collections.PathCollection at 0x2499313caf0>



<img src="./imgs/2_7_6/output_82_2.png" height='auto' width='auto' title="caDesign">
    


* Isolation

Isolation指数可以用于测量一个样方中所属一个类别的栅格单元，与另一个栅格单元属于同类别的概率，其公式为：$xPx=\sum_{i=1}^{I}\left ( \hat{s}_{ix} \right )\left ( \tilde{s}_{ix} \right )$。从下述计算结果可以说明同一样方中，同为开放空间类别的栅格单元的概率为21.41%。


```python
Isolation_idx=sa.Isolation(*args_seg)
print(Isolation_idx.statistic)
```

    0.08353886171624425
    

* Exposure 

Exposure指数与Isolation指数互补，可以用于测量一个样方中所属一个类别的栅格单元，与另一个栅格单元不属于同类别的概率，其公式为： $xPy=\sum_{i=1}^{I}\left ( \hat{s}_{iy} \right )\left ( \tilde{s}_{iy} \right )$。从计算结果可以得知，$Isolation+Exposure=0.7858889760253966+0.2141110239746033=1$


```python
Exposure_idx=sa.Exposure(os_sum_df, 'open_space', 'count')
print(Exposure_idx.statistic)
```

    0.7858889760253966
    

* Correlation Ratio 

Correlation Ratio 指数公式为： $V = Eta^2 = \frac{xPx - \frac{n_{.x}}{n_{..}}}{1 - \frac{n_{.x}}{n_{..}}}$。


```python
CorrelationR_idx=sa.CorrelationR(*args_seg)
print(CorrelationR_idx.statistic)
```

    0.05149295127792926
    

* Modified Dissimilarity 

根据*On measuring segregation in samples with small units*论文提出的方法对Dissimilarity指数修正<sup>[6]</sup>，修正条件公式为：$  Dct =  \begin{cases}    \frac{D-D^*}{1-D^*} \mspace{10mu} if \ D \geqslant D^* \\ \frac{D-D^*}{D^*} \mspace{10mu} if \ D < D^*  \end{cases}$。


```python
ModifiedDissim_idx=sa.ModifiedDissim(*args_seg,iterations=500)
print(ModifiedDissim_idx.statistic)
```

    0.4387485246174006
    

* Modified Gini 

与Modified Dissimilarity指数修正方法一样<sup>[6]</sup>，Modified Gini 指数的修正条件公式为： $  Gct =  \begin{cases}    \frac{G-G^*}{1-G^*} \mspace{10mu} if \ G \geqslant G^* \\    \frac{G-G^*}{G^*}\mspace{10mu} if \ G < G^*  \end{cases}$。


```python
ModifiedGiniSeg_idx=sa.ModifiedGiniSeg(*args_seg,iterations=500)
print(ModifiedGiniSeg_idx.statistic)
```

    0.006455065486869477
    

* Bias-Corrected Dissimilarity

Bias-Corrected Dissimilarity指数在*More reliable inference for the dissimilarity index of segregation*一文中提出<sup>[7]</sup>。


```python
BiasCorrectedDissim_idx=sa.BiasCorrectedDissim(*args_seg,B=500)
print(BiasCorrectedDissim_idx.statistic)
```

    0.4419327858776766
    

* Density-Corrected Dissimilarity

Density-Corrected Dissimilarity指数同样由*More reliable inference for the dissimilarity index of segregation*一文中提出<sup>[7]</sup>。


```python
DensityCorrectedDissim_idx=sa.DensityCorrectedDissim(*args_seg,xtol = 1e-5)
print(DensityCorrectedDissim_idx.statistic)
```

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\segregation\aspatial\aspatial_indexes.py:1899: OptimizeWarning: Unknown solver options: xtol
      res = minimize(fold_norm,
    

    0.0339710074036396
    

* Minimum-Maximum Index (MM) 

MM指数由*A surface‐based approach to measuring spatial segregation*一文提出，公式为：$MM = \frac{\sum_{i=1}^{n} max \left ( \hat{s}_{i1}, \hat{s}_{i2} \right ) - \sum_{i=1}^{n} min \left ( \hat{s}_{i1}, \hat{s}_{i2} \right )}{\sum_{i=1}^{n} max \left ( \hat{s}_{i1}, \hat{s}_{i2} \right )}$，式中下标$1,2$是两个相互排斥的群体，例如开放空间和非开放空间。


```python
MinMax_idx=sa.MinMax(*args_seg)
print(MinMax_idx.statistic)
```

    0.6129742318156732
    

#### 2) 组间比较与作用（决定）因素成分分解和贡献度

* 开放空间的构成比例

对样方组a和样方组b均计算开放空间栅格单元数`open_space`列占各自样方栅格单元总数`count`的构成比例，将比值写入`compo_os`列。并打印各组开放空间构成比例分布地图。


```python
landuse_zonal_stats_a_gdf=postSQL2gpd(table_name='landuse_zonal_stats_a',**args.db.db_info)    
landuse_zonal_stats_a_gdf.fillna(0,inplace=True)

landuse_zonal_stats_a_gdf['compo_os']=np.where(landuse_zonal_stats_a_gdf['count']==0, 0, landuse_zonal_stats_a_gdf['open_space'] / landuse_zonal_stats_a_gdf['count'])
landuse_zonal_stats_a_gdf.head()
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is landuse_zonal_stats_a.
    

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning: Did not recognize type 'geometry' of column 'geometry'
      pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>count</th>
      <th>index</th>
      <th>fre_0</th>
      <th>fre_43</th>
      <th>fre_55</th>
      <th>fre_10</th>
      <th>fre_46</th>
      <th>fre_4</th>
      <th>fre_14</th>
      <th>...</th>
      <th>fre_51</th>
      <th>fre_53</th>
      <th>fre_31</th>
      <th>fre_39</th>
      <th>fre_52</th>
      <th>fre_36</th>
      <th>fre_3</th>
      <th>fre_44</th>
      <th>open_space</th>
      <th>compo_os</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((421520.398 4629617.466, 419859.219 4...</td>
      <td>147546</td>
      <td>0</td>
      <td>47103</td>
      <td>23532.0</td>
      <td>19612</td>
      <td>18269.0</td>
      <td>10250.0</td>
      <td>7814.0</td>
      <td>5845.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>23667.0</td>
      <td>0.160404</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((421544.820 4631838.009, 419884.158 4...</td>
      <td>147500</td>
      <td>0</td>
      <td>18338</td>
      <td>0.0</td>
      <td>29150</td>
      <td>27149.0</td>
      <td>541.0</td>
      <td>8627.0</td>
      <td>1245.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>23656.0</td>
      <td>0.160380</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((421569.252 4634058.559, 419909.107 4...</td>
      <td>147453</td>
      <td>0</td>
      <td>35973</td>
      <td>6802.0</td>
      <td>39109</td>
      <td>5126.0</td>
      <td>1261.0</td>
      <td>4477.0</td>
      <td>1366.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>15376.0</td>
      <td>0.104277</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((421593.693 4636279.118, 419934.066 4...</td>
      <td>147408</td>
      <td>0</td>
      <td>72298</td>
      <td>4878.0</td>
      <td>32851</td>
      <td>728.0</td>
      <td>597.0</td>
      <td>192.0</td>
      <td>6550.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>10945.0</td>
      <td>0.074250</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((421618.144 4638499.683, 419959.034 4...</td>
      <td>147363</td>
      <td>0</td>
      <td>74336</td>
      <td>2010.0</td>
      <td>29595</td>
      <td>489.0</td>
      <td>550.0</td>
      <td>0.0</td>
      <td>848.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>12682.0</td>
      <td>0.086060</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 60 columns</p>
</div>




```python
landuse_zonal_stats_b_gdf=postSQL2gpd(table_name='landuse_zonal_stats_b',**args.db.db_info)    
landuse_zonal_stats_b_gdf.fillna(0,inplace=True)

landuse_zonal_stats_b_gdf['compo_os']=np.where(landuse_zonal_stats_b_gdf['count'] == 0, 0, landuse_zonal_stats_b_gdf['open_space'] / landuse_zonal_stats_b_gdf['count'])
```

    __________________________________________________
    The data has been read from PostgreSQL database. The table name is landuse_zonal_stats_b.
    

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\pandas\io\sql.py:580: SAWarning: Did not recognize type 'geometry' of column 'geometry'
      pandas_sql.meta.reflect(bind=pandas_sql.connectable, only=[sql])
    


```python
fig, (ax1, ax2)=plt.subplots(ncols=2, figsize=(10, 5),)
landuse_zonal_stats_a_gdf.plot(column='compo_os', cmap='OrRd', legend=True,ax=ax1)
landuse_zonal_stats_b_gdf.plot(column='compo_os', cmap='OrRd', legend=True,ax=ax2)
plt.show()
```

<img src="./imgs/2_7_6/output_102_0.png" height='auto' width='auto' title="caDesign">
    

* 作用因素成分分解和贡献度

根据*Comparative Spatial Segregation Analytics*研究论文<sup>[9]</sup>，作者采用了Shapley分解（Shapley decomposition）方法<sup>[10]</sup>研究组间隔离差异，公式为：$ΔG = G( S_{1} ,  A_{1} ) − G( S_{2} ,  A_{2})$，结合属性分量（attribute componnet， $C_{A} $)和空间分量（spatial component， $C_{s}$）贡献度，公式为：$F(S, A) =  C_{S}  +C_{A}  = ΔG $，式中，

$C_{S}= \frac{1}{2}  [G( S_{1}, A_{1}  )-G( S_{2}, A_{1}  )+G( S_{1}, A_{2} )-G( S_{2}, A_{2} )]$

$C_{A}= \frac{1}{2}  [G( S_{1}, A_{1}  )-G( S_{1}, A_{2}  )+G( S_{2}, A_{1} )-G( S_{2}, A_{2} )]$。

对于空间分量$C_{s}$，获取两个估计，第一个估计是保持a组属性分量$ A_{1} $不变，而空间分量为a组和b组的空间分量$S_{1}$和$S_{2}$产生的差异；第二个估计保持b组属性分量$ A_{2}$不变，空间分量也为a组和b组的空间分量$S_{1}$和$S_{2}$产生的差异，最后的空间分量被视为这两个估计的均值。在每一估计中都会产生一个反设事实（空间分量2个，属性分量2个），与其真实观测到的隔离系数相对照。对于空间分量，第一个估计的反设事实为$G( S_{2}, A_{1})$，为组a保持属性分量不变而将空间分量替换为组b的空间分量。这个反设事实的隔离指数与真实a组的$G( S_{1}, A_{1} )$隔离指数之间的差异归因于空间分量的变化，因为空间分量是两组间唯一变化的部分；第二个估计的反设事实为$G( S_{1}, A_{2} )$，为组b保持属性分量不变而将空间分量替换为组a的空间分量。这个反设事实的隔离指数与真实b组的$G( S_{2}, A_{2} )$隔离指数之间的差异同样归因于空间分量的变化。

同样对于属性分量$C_{A}$也有两个估计，是保持空间分量而变化不同组的属性分量。即保持各组的空间分量不变而将属性分替换为另一组的属性分类，从而在各个估计中，空间分量是不变量，组间隔离指数的差异归因于属性分量的变化。


对于*Comparative Spatial Segregation Analytics*提出的组间隔离差异分量贡献度，`segregation`库提供了`DecomposeSegregation`方法方便直接计算，该方法提供的`counterfactual_approach`参数有3种方法，包括"composition", "share", "dual_composition"，是用于生成“counterfactual（反设事实）”对象的方式。

__counterfactual_approach="composition"__

以Gini隔离指数为例，a组值为0.661，b组值为0.564，二者存在0.097的差异，那么两组之间的这个差异受到空间结构和属性组成的影响分别是多少？从计算结果得知，空间结构的影响几近为0，而属性组成，即土地利用类型的分布起到主导作用，值约为0.097，这与两组Gini隔离指数差值基本同。

> 对于"share", "dual_composition"的解释可以阅读[decomposition_wrapper_example](http://pysal.org/notebooks/explore/segregation/decomposition_wrapper_example.html)<sup>④</sup>。


```python
import segregation.aspatial as sa
from tqdm import tqdm

G_a=sa.GiniSeg(landuse_zonal_stats_a_gdf, 'open_space', 'count')
G_b=sa.GiniSeg(landuse_zonal_stats_b_gdf, 'open_space', 'count')
print(f"G_a={G_a.statistic},\nG_b={G_b.statistic},\nG_a-G_b={G_a.statistic-G_b.statistic}")
```

    G_a=0.6619845430595112,
    G_b=0.5649299326429257,
    G_a-G_b=0.09705461041658547
    

对于`DecomposeSegregation`方法的理解可以通过`help(DecomposeSegregation)`查看。


```python
from segregation.decomposition import DecomposeSegregation
help(DecomposeSegregation)
```

    Help on class DecomposeSegregation in module segregation.decomposition.decompose_segregation:
    
    class DecomposeSegregation(builtins.object)
     |  DecomposeSegregation(index1, index2, counterfactual_approach='composition')
     |  
     |  Decompose segregation differences into spatial and attribute components.
     |  
     |  Given two segregation indices of the same type, use Shapley decomposition
     |  to measure whether the differences between index measures arise from
     |  differences in spatial structure or population structure
     |  
     |  Parameters
     |  ----------
     |  index1 : segregation.SegIndex class
     |      First SegIndex class to compare.
     |  index2 : segregation.SegIndex class
     |      Second SegIndex class to compare.
     |  counterfactual_approach : str, one of
     |                            ["composition", "share", "dual_composition"]
     |      The technique used to generate the counterfactual population
     |      distributions.
     |  
     |  Attributes
     |  ----------
     |  
     |  c_s : float
     |      Shapley's Spatial Component of the decomposition
     |  
     |  c_a : float
     |      Shapley's Attribute Component of the decomposition
     |  
     |  Methods
     |  ----------
     |  
     |  plot : Visualize features of the Decomposition performed
     |      plot_type : str, one of ['cdfs', 'maps']
     |  
     |      'cdfs' : visualize the cumulative distribution functions of the compositions/shares
     |      'maps' : visualize the spatial distributions for original data and counterfactuals generated and Shapley's components (only available for GeoDataFrames)
     |  
     |  Examples
     |  --------
     |  Several examples can be found at https://github.com/pysal/segregation/blob/master/notebooks/decomposition_wrapper_example.ipynb.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, index1, index2, counterfactual_approach='composition')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  plot(self, plot_type='cdfs')
     |      Plot the Segregation Decomposition Profile
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    

`counterfactual_approach`参数默认为`composition`方式。


```python
DS_composition=DecomposeSegregation(G_a, G_b)
print(f"Spatial component: {DS_composition.c_s}\nattribute component: {DS_composition.c_a}")
```

    Spatial component: 8.982971253457261e-06
    attribute component: 0.09704562744533202
    

`DecomposeSegregation`方法的返回值具有`plot`打印图表方法，提供的`plot_type`参数包括`cdfs`和`maps`，其中`cdfs`为各组成（compositions）或份额（share）的累积量分布，本例为开放空间的栅格单元数（compositions）或者其占对应组开放空间总栅格单元数的比例（share）
；`maps`为原始数据的空间分布（同上文中的开放空间构成比例），以及`counterfactuals`反设事实的开放空间构成比例分布。


```python
DS_composition.plot(plot_type='cdfs')
```

<img src="./imgs/2_7_6/output_110_0.png" height='auto' width='auto' title="caDesign">
    



```python
DS_composition.plot(plot_type='maps')
```

<img src="./imgs/2_7_6/output_111_0.png" height='auto' width='auto' title="caDesign">
    


#### 3) 空间隔离指数推断

空间隔离指数返回的类通常具有`statistic`属性，但是没有p-values值，不能进行统计推断确定指数返回值是否具有统计学意义，而`segregation.inference`模块提供了统计显著性检验的两种方法，一种是对单值的检验，为`SingleValueTest`；另一种是对二值的检验，为`TwoValueTest`。检验方法接收的参数为空间隔离指数返回的指数类，并由`null_approach`参数确定无效假设的类型，由`iterations_under_null`参数确定在无效假设下迭代的次数。需要注意，检验方法对`null_approach`参数提供了多个无效假设类型，不同类型选择直接影响统计推断的结果。

* 非空间单指数统计显著性

以Dissimilarity指数为例，计算结果约为0.519。定义无效假设类型为`evenness`，即假设每一空间单元从固定总体的某类对象中抽取元素的全局概率相同（二项分布）。以无效假设数据计算Dissimilarity指数为`iterations_under_null`给定的1000次，打印分布，发现0.519位于右侧，远偏离无效假设分布区域，且p-value值为0，因此拒绝原假设，Dissimilarity指数表明样方组区域各个样方之间存在开放空间明显隔离现象，部分样方有较多的开放空间栅格单元，但部分则很少或没有，且样方之间开放空间的栅格单元连通较少。


```python
dissim_idx=sa.Dissim(*args_seg)
print(dissim_idx.statistic)
```

    0.5194584397292389
    


```python
from segregation.inference import SingleValueTest, TwoValueTest

infer_D_eve=SingleValueTest(dissim_idx, iterations_under_null=1000, null_approach="evenness", two_tailed=True)
print(f"The mean value of the distribution={infer_D_eve.est_sim.mean()}\np-value={infer_D_eve.p_value}")
infer_D_eve.plot()
```

    Processed 1000 iterations out of 1000: 100%|██████████| 1000/1000 [00:03<00:00, 263.03it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    

    The mean value of the distribution=0.002802174544920078
    p-value=0.0
    




    <AxesSubplot: title={'center': 'Dissim (Value = 0.519)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_114_3.png" height='auto' width='auto' title="caDesign">
    


* 空间单指数统计显著性

__Relative Concentration__

`RelativeConcentration`指数为一个空间指数（受空间结构影响），因此无效假设类型选择为`permutation`，即在空间上随机分配单元，且保持原始值不变。计算无效假设的`RelativeConcentration`指数，打印分布，其p-value值为0.05，表明`RelativeConcentration`指数统计显著性不明显。但是，如果将无效假设类型选择为`even_permutation`，综合`evenness`和`permutation`类型，则计算结果具有统计显著性。


```python
from segregation.spatial import RelativeConcentration
RCO=RelativeConcentration(*args_seg)
RCO.statistic
```




    -0.12219593013769346




```python
infer_RCO_per=SingleValueTest(RCO, iterations_under_null=1000, null_approach="permutation", two_tailed=True)
print(f"p-value={infer_RCO_per.p_value}")
infer_RCO_per.plot()
```

    Processed 1000 iterations out of 1000: 100%|██████████| 1000/1000 [00:06<00:00, 165.50it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    

    p-value=0.054
    




    <AxesSubplot: title={'center': 'RelativeConcentration (Value = -0.122)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_117_3.png" height='auto' width='auto' title="caDesign">
    



```python
infer_RCO_eve_per=SingleValueTest(RCO, iterations_under_null = 1000, null_approach = "even_permutation", two_tailed = True)
infer_RCO_eve_per.plot()
```

    Processed 1000 iterations out of 1000: 100%|██████████| 1000/1000 [00:06<00:00, 146.16it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    




    <AxesSubplot: title={'center': 'RelativeConcentration (Value = -0.122)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_118_2.png" height='auto' width='auto' title="caDesign">
    



__Relative Centralization__

同样检验`Relative Centralization `指数，无效假设类型为`permutation`。因为结果值-0.376位于分布左侧末尾，表明开放空间分布的集中化方面有明显的副作用（负值），即开放空间栅格单元分布通常偏离样方组的中心区域。


```python
from segregation.spatial import RelativeCentralization
RCE=RelativeCentralization(*args_seg)
print(f"RCE={RCE.statistic}")
infer_RCE_per=SingleValueTest(RCE, iterations_under_null=1000, null_approach="permutation", two_tailed=True)
infer_RCE_per.plot()
```

    RCE=-0.3768144764624637
    

    Processed 1000 iterations out of 1000: 100%|██████████| 1000/1000 [00:14<00:00, 70.54it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    




    <AxesSubplot: title={'center': 'RelativeCentralization (Value = -0.377)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_120_3.png" height='auto' width='auto' title="caDesign">
    



* 非空间双指数（二值）统计显著性

二值方法基本同单值方法，但需要传入两组同一隔离指数计算的返回类，例如传入样方组a和b计算的Gini系数。


```python
compare_G_fit=TwoValueTest(G_a, G_b, iterations_under_null=1000, null_approach="random_label")
compare_G_fit.plot()
```

    Processed 1000 iterations out of 1000: 100%|██████████| 1000/1000 [00:10<00:00, 94.37it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    




    <AxesSubplot: title={'center': 'GiniSeg (Diff. value = 0.097)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_122_2.png" height='auto' width='auto' title="caDesign">
    


* 空间双指数（二值）统计显著性

二值方法同样使用于空间指数。


```python
from segregation.spatial import SpatialDissim
SD_a=SpatialDissim(landuse_zonal_stats_a_gdf, 'open_space', 'count')
SD_b=SpatialDissim(landuse_zonal_stats_b_gdf, 'open_space', 'count')

compare_SD_fit=TwoValueTest(SD_a, SD_b, iterations_under_null = 500, null_approach = "counterfactual_composition")
compare_SD_fit.plot()
```

    Processed 500 iterations out of 500: 100%|██████████| 500/500 [00:11<00:00, 43.53it/s]
    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\seaborn\distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
      warnings.warn(msg, FutureWarning)
    




    <AxesSubplot: title={'center': 'SpatialDissim (Diff. value = -0.009)'}, ylabel='Density'>



<img src="./imgs/2_7_6/output_124_2.png" height='auto' width='auto' title="caDesign">
    


#### 4) 局部空间隔离指数

`segregation.local`模块提供有多个局部空间隔离指数，包括有`MultiLocationQuotient`为Location Quotient (LQ), `MultiLocalDiversity`为Local Diversity, `MultiLocalEntropy`为Local Entropy, `MultiLocalSimpsonInteraction`为Local Simpson Interaction, `MultiLocalSimpsonConcentration`为Local Simpson Concentration , `LocalRelativeCentralization`为Local Centralization等。


```python
from segregation.local import MultiLocationQuotient, MultiLocalDiversity, MultiLocalEntropy, MultiLocalSimpsonInteraction, MultiLocalSimpsonConcentration, LocalRelativeCentralization

groups_list=['fre_41','fre_42','fre_43','fre_44','fre_45'] # '开放空间主要娱乐设施': 41, '高尔夫球场': 42, '开放空间主要保护区': 43, '非公共开放空间': 44, '步道或绿道':45
M_location_quotient=MultiLocationQuotient(landuse_zonal_stats_a_gdf, groups_list)
print(M_location_quotient.statistics.shape)
M_location_quotient.statistics[:3,:]
```

    (49, 5)
    




    array([[0.04016389, 0.        , 1.65965646, 0.        , 0.        ],
           [5.19992145, 1.0597044 , 0.        , 0.        , 0.        ],
           [3.00953483, 0.52763894, 0.73840704, 0.        , 0.        ]])




```python
for i in range(len(groups_list)):
    landuse_zonal_stats_a_gdf['LQ_' + groups_list[i]]=M_location_quotient.statistics[:,i]
landuse_zonal_stats_a_gdf.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>count</th>
      <th>index</th>
      <th>fre_0</th>
      <th>fre_43</th>
      <th>fre_55</th>
      <th>fre_10</th>
      <th>fre_46</th>
      <th>fre_4</th>
      <th>fre_14</th>
      <th>...</th>
      <th>fre_36</th>
      <th>fre_3</th>
      <th>fre_44</th>
      <th>open_space</th>
      <th>compo_os</th>
      <th>LQ_fre_41</th>
      <th>LQ_fre_42</th>
      <th>LQ_fre_43</th>
      <th>LQ_fre_44</th>
      <th>LQ_fre_45</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((421520.398 4629617.466, 419859.219 4...</td>
      <td>147546</td>
      <td>0</td>
      <td>47103</td>
      <td>23532.0</td>
      <td>19612</td>
      <td>18269.0</td>
      <td>10250.0</td>
      <td>7814.0</td>
      <td>5845.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>23667</td>
      <td>0.160404</td>
      <td>0.040164</td>
      <td>0.000000</td>
      <td>1.659656</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((421544.820 4631838.009, 419884.158 4...</td>
      <td>147500</td>
      <td>0</td>
      <td>18338</td>
      <td>0.0</td>
      <td>29150</td>
      <td>27149.0</td>
      <td>541.0</td>
      <td>8627.0</td>
      <td>1245.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>23656</td>
      <td>0.160380</td>
      <td>5.199921</td>
      <td>1.059704</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((421569.252 4634058.559, 419909.107 4...</td>
      <td>147453</td>
      <td>0</td>
      <td>35973</td>
      <td>6802.0</td>
      <td>39109</td>
      <td>5126.0</td>
      <td>1261.0</td>
      <td>4477.0</td>
      <td>1366.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>15376</td>
      <td>0.104277</td>
      <td>3.009535</td>
      <td>0.527639</td>
      <td>0.738407</td>
      <td>0.0</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((421593.693 4636279.118, 419934.066 4...</td>
      <td>147408</td>
      <td>0</td>
      <td>72298</td>
      <td>4878.0</td>
      <td>32851</td>
      <td>728.0</td>
      <td>597.0</td>
      <td>192.0</td>
      <td>6550.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>10945</td>
      <td>0.074250</td>
      <td>1.945410</td>
      <td>0.109595</td>
      <td>0.743924</td>
      <td>0.0</td>
      <td>20.750819</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((421618.144 4638499.683, 419959.034 4...</td>
      <td>147363</td>
      <td>0</td>
      <td>74336</td>
      <td>2010.0</td>
      <td>29595</td>
      <td>489.0</td>
      <td>550.0</td>
      <td>0.0</td>
      <td>848.0</td>
      <td>...</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>12682</td>
      <td>0.086060</td>
      <td>5.620948</td>
      <td>0.000000</td>
      <td>0.264552</td>
      <td>0.0</td>
      <td>3.572606</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 65 columns</p>
</div>




```python
def gdf_layoutPlot_simple(gdf,cols,fig_cols,figsize=(10,10)):
    '''
    同时打印GeoDataFrame多个列于子图

    Parameters
    ----------
    gdf : GeoDataFrame
        GeoDataFrame格式数据.
    cols : list(string)
        待打印的列名列表.
    fig_cols : int
        打印子图列数.
    figsize : tuple(int), optional
        图表大小. The default is (10,10).

    Returns
    -------
    None.

    '''    
    import math
    import matplotlib.pyplot as plt
    
    fig_rows=math.ceil(len(cols)/fig_cols)
    fig,axes=plt.subplots(fig_rows,fig_cols,sharex=True,sharey=True,figsize=figsize)  
    ax=axes.flatten() 
    for i in range(len(cols)):
        gdf.plot(column=cols[i],cmap='inferno_r',legend=True,ax=ax[i])
        ax[i].set_title(cols[i])
        ax[i].set_xticks([])
        ax[i].set_yticks([])
        ax[i].set_facecolor('white')   
    
gdf_layoutPlot_simple(landuse_zonal_stats_a_gdf,groups_list,3,figsize=(20,10))    
```

<img src="./imgs/2_7_6/output_128_0.png" height='auto' width='auto' title="caDesign">
    



```python
M_local_diversity=MultiLocalDiversity(landuse_zonal_stats_a_gdf, groups_list)
M_local_entropy=MultiLocalEntropy(landuse_zonal_stats_a_gdf, groups_list)
M_local_simpson_intersaction=MultiLocalSimpsonInteraction(landuse_zonal_stats_a_gdf, groups_list)
M_local_simpson_concentration=MultiLocalSimpsonConcentration(landuse_zonal_stats_a_gdf, groups_list)
local_centralization=LocalRelativeCentralization(landuse_zonal_stats_a_gdf, 'open_space', 'count')

M_local_idxes={"M_local_diversity":M_local_diversity.statistics,
               "M_local_entropy":M_local_entropy.statistics,
               "M_local_simpson_intersaction":M_local_simpson_intersaction.statistics,
               "M_local_simpson_concentration":M_local_simpson_concentration.statistics,
               "local_centralization":local_centralization.statistics}
for k,v in M_local_idxes.items():
    landuse_zonal_stats_a_gdf[k]=v
    
landuse_zonal_stats_a_gdf.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>count</th>
      <th>index</th>
      <th>fre_0</th>
      <th>fre_43</th>
      <th>fre_55</th>
      <th>fre_10</th>
      <th>fre_46</th>
      <th>fre_4</th>
      <th>fre_14</th>
      <th>...</th>
      <th>LQ_fre_41</th>
      <th>LQ_fre_42</th>
      <th>LQ_fre_43</th>
      <th>LQ_fre_44</th>
      <th>LQ_fre_45</th>
      <th>M_local_diversity</th>
      <th>M_local_entropy</th>
      <th>M_local_simpson_intersaction</th>
      <th>M_local_simpson_concentration</th>
      <th>local_centralization</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((421520.398 4629617.466, 419859.219 4...</td>
      <td>147546</td>
      <td>0</td>
      <td>47103</td>
      <td>23532.0</td>
      <td>19612</td>
      <td>18269.0</td>
      <td>10250.0</td>
      <td>7814.0</td>
      <td>5845.0</td>
      <td>...</td>
      <td>0.040164</td>
      <td>0.000000</td>
      <td>1.659656</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.035159</td>
      <td>0.021845</td>
      <td>0.011343</td>
      <td>0.988657</td>
      <td>-0.289302</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((421544.820 4631838.009, 419884.158 4...</td>
      <td>147500</td>
      <td>0</td>
      <td>18338</td>
      <td>0.0</td>
      <td>29150</td>
      <td>27149.0</td>
      <td>541.0</td>
      <td>8627.0</td>
      <td>1245.0</td>
      <td>...</td>
      <td>5.199921</td>
      <td>1.059704</td>
      <td>0.000000</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.574618</td>
      <td>0.357030</td>
      <td>0.386234</td>
      <td>0.613766</td>
      <td>0.065970</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((421569.252 4634058.559, 419909.107 4...</td>
      <td>147453</td>
      <td>0</td>
      <td>35973</td>
      <td>6802.0</td>
      <td>39109</td>
      <td>5126.0</td>
      <td>1261.0</td>
      <td>4477.0</td>
      <td>1366.0</td>
      <td>...</td>
      <td>3.009535</td>
      <td>0.527639</td>
      <td>0.738407</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.989541</td>
      <td>0.614836</td>
      <td>0.604662</td>
      <td>0.395338</td>
      <td>-0.306343</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 70 columns</p>
</div>




```python
gdf_layoutPlot_simple(landuse_zonal_stats_a_gdf,list(M_local_idxes.keys()),3,figsize=(20,10))    
```

<img src="./imgs/2_7_6/output_130_0.png" height='auto' width='auto' title="caDesign">
    



#### 5) 多类空间隔离指数

`segregation.aspatial`模块提供有多类空间隔离指数，包括有`MultiDissim`为Multigroup Dissimilarity Index，`MultiGiniSeg`为Multigroup Gini Index，`MultiNormalizedExposure`为Multigroup Normalized Exposure Index，`MultiInformationTheory`为Multigroup Information Theory Index，`MultiRelativeDiversity`为Multigroup Relative Diversity Index，`MultiSquaredCoefficientVariation`为Multigroup Squared Coefficient of Variation Index，`MultiDiversity`为Multigroup Diversity Index，`SimpsonsConcentration`为Simpson's Concentration Index (lambda)，`SimpsonsInteraction`为Simpson's Interaction Index (I)，`MultiDivergence`为Multigroup Divergence Index等。


```python
import segregation.aspatial as sa

M_dissimilarity=sa.MultiDissim(landuse_zonal_stats_a_gdf, groups_list)
M_gini=sa.MultiGiniSeg(landuse_zonal_stats_a_gdf, groups_list)
M_normalized_exposure=sa.MultiNormalizedExposure(landuse_zonal_stats_a_gdf, groups_list)
M_information_theory=sa.MultiInformationTheory(landuse_zonal_stats_a_gdf, groups_list)
M_relative_diversity=sa.MultiRelativeDiversity(landuse_zonal_stats_a_gdf, groups_list)
M_squared_coefficient_of_variation=sa.MultiSquaredCoefficientVariation(landuse_zonal_stats_a_gdf, groups_list)
M_diversity=sa.MultiDiversity(landuse_zonal_stats_a_gdf, groups_list)
M_simpsons_concentration=sa.SimpsonsConcentration(landuse_zonal_stats_a_gdf, groups_list)
M_simpsons_interaction=sa.SimpsonsInteraction(landuse_zonal_stats_a_gdf, groups_list)
M_divergence=sa.MultiDivergence(landuse_zonal_stats_a_gdf, groups_list)

M_aspatial_idxes={"M_dissimilarity":M_dissimilarity.statistic,
                  "M_gini":M_gini.statistic,
                  "M_normalized_exposure":M_normalized_exposure.statistic,
                  "M_information_theory":M_information_theory.statistic,
                  "M_relative_diversity":M_relative_diversity.statistic,
                  "M_squared_coefficient_of_variation":M_squared_coefficient_of_variation.statistic,
                  "M_diversity":M_diversity.statistic,
                  "M_simpsons_concentration":M_simpsons_concentration.statistic,
                  "M_simpsons_interaction":M_simpsons_interaction.statistic,
                  "M_divergence":M_divergence.statistic}

print(M_aspatial_idxes)
```

    {'M_dissimilarity': 0.6732150430715581, 'M_gini': 0.8434789124832778, 'M_normalized_exposure': 0.5278542428716425, 'M_information_theory': 0.5498565988739315, 'M_relative_diversity': 0.5191008310172185, 'M_squared_coefficient_of_variation': 0.32708599440620156, 'M_diversity': 0.9830556615079412, 'M_simpsons_concentration': 0.44012719596442745, 'M_simpsons_interaction': 0.5598728040355725, 'M_divergence': 0.5405396425405196}
    

---

注释（Notes）：

① 芝加哥土地利用2015年更新数据（已更新至2018年）， （<https://www.cmap.illinois.gov/data/land-use/inventory>）。

② pgAdmin，为最流行和功能丰富的`PostgreSQL`开源管理和开发平台（<https://www.pgadmin.org/>）。

③ Chicago Data Portal，CDP，为芝加哥城开放数据门户，可免费下载数据用于相关分析，其中许多数据集每天至少更新一次或数次（<https://data.cityofchicago.org/>）。

④ decomposition_wrapper_example，（<http://pysal.org/notebooks/explore/segregation/decomposition_wrapper_example.html>）。

参考文献（References）:

[1] Chicago Metropolitan Agency for Planning. Chicago Metropolitan Agency for Planning 2015 Parcel-Based Land Use Inventory Categories  September 2020, https://www.cmap.illinois.gov/data/land-use/inventory.

[2] Gini C. "Variabilitá e mutabilita" 1912 reprinted in Memorie di metodologica statistica (Ed. Pizetti E, Salvemini, T). Rome: Libreria Eredi Virgilio Veschi 1955.

[3] Lorenz MO. Methods for measuring the concentration of wealth. Journal of the American Statistical Association 1905;9:209-219.

[4] PySAL Notebooks. Segregation, <http://pysal.org/notebooks/explore/segregation/intro.html>.

[5] Hong, Seong-Yun, and Yukio Sadahiro. "Measuring geographic segregation: a graph-based approach." Journal of Geographical Systems 16.2 (2014): 211-231. 

[6] Carrington, W. J., Troske, K. R., 1997. On measuring segregation in samples with small units. Journal of Business & Economic Statistics 15 (4), 402–409.

[7] Allen, R., Burgess, S., Davidson, R., Windmeijer, F., 2015. More reliable inference for the dissimilarity index of segregation. The econometrics journal 18 (1), 40–66. 

[8] O'Sullivan, David, and David WS Wong. "A surface‐based approach to measuring spatial segregation." Geographical Analysis 39.2 (2007): 147-168.

[9] Rey, S. J., Cortes, R. & Knaap, E. Comparative Spatial Segregation Analytics. Spat Demogr 9, 31–56 (2021).

[10] Shorrocks, A. F. (2013). Decomposition procedures for distributional analysis: A unified framework based on the Shapley value. The Journal of Economic Inequality, 11(1), 99–126.
