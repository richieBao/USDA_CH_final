> Created on Sat Nov 12 16:10:54 2022  @author: Richie Bao-caDesign设计(cadesign.cn)

## 2.7.3 空间自相关分析



### 2.7.3.1 数据准备——公共健康数据

对数据考虑使用空间相关分析前，通常需要初步判断测量值是否可能具有空间相关性，这不仅在于数据内容，也在于测量点或区域的分布尺度，例如污染气体浓度通常在局部区域（扩散范围）内起作用，此时扩散范围内的多个测量点可能是空间相关的，但是超出了这个扩散范围的多个测量点之间可能就不具有空间相关性，例如，对于AoT测量数据，因为测量节点位于芝加哥全城，点间密度稀疏，因此计算获得的全局和局部空间自相关指数均表明已有测量节点之间在气体浓度这一测量内容上空间相关性不明显。在相关性分析和建立回归模型时均使用到[芝加哥公共健康数据](https://data.cityofchicago.org/Health-Human-Services/Public-Health-Statistics-Selected-public-health-in/iqnk-2tcu)<sup>①</sup>，初步判断测量内容可能存在空间相关性，因此重新下载最新数据（更新日期为：2022-02-04），用于空间自相关分析。

公共健康数据不包含地理空间信息，但是含有`Community Area`和`Community Area Name`关键字段。从[Chicago Data Portal](https://data.cityofchicago.org/)<sup>②</sup>下载的“Boundaries - Community Areas (current) ”社区范围数据含有地理空间信息（GeoJSON的`geometry`字段或SHP/Shapefile，KML等格式数据），并含有`area_numbe`关键字段，对应公共健康数据的`Community Area`字段，`community`对应`Community Area Name`，只是名称字段需要注意大小写，因此合并数据时，使用`area_numbe`和对应的`Community Area`关键字段。为方便包含有属性的DataFrame格式数据合并包含有地理空间信息的GeoDataFrame格式数据，定义`df_linking_geometry()`函数。

参数定义和参数值的存储使用`AttrDict`类方法（查看“Cityscapes数据集——参数管理”一节）。定义的子属性包括`db`用于存储数据库相关参数值；`gi`用于存储epsg地理空间投影信息；`data`用于存储待读取的数据文件路径。

* 定义参数和参数值


```python
from database import postSQL2gpd,gpd2postSQL
from util_misc import AttrDict
__C=AttrDict() 
args=__C

__C.db=AttrDict() 
__C.db.UN='postgres'
__C.db.PW='123456'
__C.db.DB='AoT_20220831'
__C.db.GC='geometry' 
__C.db.db_info=dict(geom_col=args.db.GC,myusername=args.db.UN,mypassword=args.db.PW,mydatabase=args.db.DB)

__C.gi=AttrDict()
__C.gi.Chicago_epsg=32616
__C.gi.epsg_wgs84=4326

__C.data=AttrDict()
__C.data.public_health_statistics="./data/Public_Health_Statistics_Selected_public_health_indicators_by_Chicago_community_area_Historical_202202.csv"
__C.data.community_areas="./data/ChicagoCommunityAreas/ChicagoCommunityAreas.shp"
```

* 读取属性数据——公共健康数据


```python
import pandas as pd
import geopandas as gpd

pubicHealth_Statistic_df=pd.read_csv(args.data.public_health_statistics)
pubicHealth_Statistic_df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Birth Rate</th>
      <th>General Fertility Rate</th>
      <th>Low Birth Weight</th>
      <th>Prenatal Care Beginning in First Trimester</th>
      <th>Preterm Births</th>
      <th>Teen Birth Rate</th>
      <th>Assault (Homicide)</th>
      <th>Breast cancer in females</th>
      <th>...</th>
      <th>Childhood Lead Poisoning</th>
      <th>Gonorrhea in Females</th>
      <th>Gonorrhea in Males</th>
      <th>Tuberculosis</th>
      <th>Below Poverty Level</th>
      <th>Crowded Housing</th>
      <th>Dependency</th>
      <th>No High School Diploma</th>
      <th>Per Capita Income</th>
      <th>Unemployment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>16.4</td>
      <td>62.0</td>
      <td>11.0</td>
      <td>73.0</td>
      <td>11.2</td>
      <td>40.8</td>
      <td>7.7</td>
      <td>23.3</td>
      <td>...</td>
      <td>0.5</td>
      <td>322.5</td>
      <td>423.3</td>
      <td>11.4</td>
      <td>22.7</td>
      <td>7.9</td>
      <td>28.8</td>
      <td>18.1</td>
      <td>23714</td>
      <td>7.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>West Ridge</td>
      <td>17.3</td>
      <td>83.3</td>
      <td>8.1</td>
      <td>71.1</td>
      <td>8.3</td>
      <td>29.9</td>
      <td>5.8</td>
      <td>20.2</td>
      <td>...</td>
      <td>1.0</td>
      <td>141.0</td>
      <td>205.7</td>
      <td>8.9</td>
      <td>15.1</td>
      <td>7.0</td>
      <td>38.3</td>
      <td>19.6</td>
      <td>21375</td>
      <td>7.9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Uptown</td>
      <td>13.1</td>
      <td>50.5</td>
      <td>8.3</td>
      <td>77.7</td>
      <td>10.3</td>
      <td>35.1</td>
      <td>5.4</td>
      <td>21.3</td>
      <td>...</td>
      <td>0.5</td>
      <td>170.8</td>
      <td>468.7</td>
      <td>13.6</td>
      <td>22.7</td>
      <td>4.6</td>
      <td>22.2</td>
      <td>13.6</td>
      <td>32355</td>
      <td>7.7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>17.1</td>
      <td>61.0</td>
      <td>8.1</td>
      <td>80.5</td>
      <td>9.7</td>
      <td>38.4</td>
      <td>5.0</td>
      <td>21.7</td>
      <td>...</td>
      <td>0.4</td>
      <td>98.8</td>
      <td>195.5</td>
      <td>8.5</td>
      <td>9.5</td>
      <td>3.1</td>
      <td>25.6</td>
      <td>12.5</td>
      <td>35503</td>
      <td>6.8</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>North Center</td>
      <td>22.4</td>
      <td>76.2</td>
      <td>9.1</td>
      <td>80.4</td>
      <td>9.8</td>
      <td>8.4</td>
      <td>1.0</td>
      <td>16.6</td>
      <td>...</td>
      <td>0.9</td>
      <td>85.4</td>
      <td>188.6</td>
      <td>1.9</td>
      <td>7.1</td>
      <td>0.2</td>
      <td>25.5</td>
      <td>5.4</td>
      <td>51615</td>
      <td>4.5</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>72</th>
      <td>73</td>
      <td>Washington Heights</td>
      <td>12.0</td>
      <td>61.0</td>
      <td>19.6</td>
      <td>75.4</td>
      <td>16.2</td>
      <td>65.0</td>
      <td>38.0</td>
      <td>47.9</td>
      <td>...</td>
      <td>1.5</td>
      <td>1298.2</td>
      <td>1274.2</td>
      <td>3.0</td>
      <td>15.7</td>
      <td>1.1</td>
      <td>42.4</td>
      <td>15.6</td>
      <td>19709</td>
      <td>18.3</td>
    </tr>
    <tr>
      <th>73</th>
      <td>74</td>
      <td>Mount Greenwood</td>
      <td>12.5</td>
      <td>59.0</td>
      <td>8.4</td>
      <td>94.5</td>
      <td>15.1</td>
      <td>7.7</td>
      <td>2.2</td>
      <td>34.6</td>
      <td>...</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>.</td>
      <td>0.0</td>
      <td>3.1</td>
      <td>1.1</td>
      <td>37.0</td>
      <td>4.5</td>
      <td>34221</td>
      <td>6.9</td>
    </tr>
    <tr>
      <th>74</th>
      <td>75</td>
      <td>Morgan Park</td>
      <td>13.2</td>
      <td>67.5</td>
      <td>10.6</td>
      <td>74.5</td>
      <td>12.3</td>
      <td>46.7</td>
      <td>19.9</td>
      <td>32.4</td>
      <td>...</td>
      <td>1.3</td>
      <td>800.5</td>
      <td>741.1</td>
      <td>2.6</td>
      <td>13.7</td>
      <td>0.8</td>
      <td>39.4</td>
      <td>10.9</td>
      <td>26185</td>
      <td>14.9</td>
    </tr>
    <tr>
      <th>75</th>
      <td>76</td>
      <td>O'Hare</td>
      <td>15.8</td>
      <td>70.0</td>
      <td>3.5</td>
      <td>82.0</td>
      <td>5.0</td>
      <td>15.9</td>
      <td>5.6</td>
      <td>20.5</td>
      <td>...</td>
      <td>0.5</td>
      <td>NaN</td>
      <td>.</td>
      <td>6.3</td>
      <td>9.5</td>
      <td>1.9</td>
      <td>26.5</td>
      <td>11.0</td>
      <td>29402</td>
      <td>4.7</td>
    </tr>
    <tr>
      <th>76</th>
      <td>77</td>
      <td>Edgewater</td>
      <td>12.1</td>
      <td>48.1</td>
      <td>7.5</td>
      <td>76.1</td>
      <td>7.4</td>
      <td>15.1</td>
      <td>5.8</td>
      <td>18.5</td>
      <td>...</td>
      <td>0.9</td>
      <td>120.1</td>
      <td>427.5</td>
      <td>10.5</td>
      <td>16.6</td>
      <td>3.9</td>
      <td>23.4</td>
      <td>9.0</td>
      <td>33364</td>
      <td>9.0</td>
    </tr>
  </tbody>
</table>
<p>77 rows × 29 columns</p>
</div>



* 读取含有地理空间信息的数数据————社区范围数据


```python
community_area_gdf=gpd.read_file(args.data.community_areas)
community_area_gdf.area_numbe=community_area_gdf.area_numbe.astype("int64")
community_area_gdf.sort_values(by=["area_numbe"],inplace=True)
community_area_gdf
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>area</th>
      <th>area_num_1</th>
      <th>area_numbe</th>
      <th>comarea</th>
      <th>comarea_id</th>
      <th>community</th>
      <th>perimeter</th>
      <th>shape_area</th>
      <th>shape_len</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>9</th>
      <td>0.0</td>
      <td>1</td>
      <td>1</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>ROGERS PARK</td>
      <td>0.0</td>
      <td>5.125990e+07</td>
      <td>34052.397576</td>
      <td>POLYGON ((-87.65456 41.99817, -87.65574 41.998...</td>
    </tr>
    <tr>
      <th>19</th>
      <td>0.0</td>
      <td>2</td>
      <td>2</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>WEST RIDGE</td>
      <td>0.0</td>
      <td>9.842909e+07</td>
      <td>43020.689458</td>
      <td>POLYGON ((-87.68465 42.01948, -87.68464 42.019...</td>
    </tr>
    <tr>
      <th>30</th>
      <td>0.0</td>
      <td>3</td>
      <td>3</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>UPTOWN</td>
      <td>0.0</td>
      <td>6.509564e+07</td>
      <td>46972.794555</td>
      <td>POLYGON ((-87.64102 41.95480, -87.64400 41.954...</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.0</td>
      <td>4</td>
      <td>4</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>LINCOLN SQUARE</td>
      <td>0.0</td>
      <td>7.135233e+07</td>
      <td>36624.603085</td>
      <td>POLYGON ((-87.67441 41.97610, -87.67440 41.976...</td>
    </tr>
    <tr>
      <th>47</th>
      <td>0.0</td>
      <td>5</td>
      <td>5</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>NORTH CENTER</td>
      <td>0.0</td>
      <td>5.705417e+07</td>
      <td>31391.669754</td>
      <td>POLYGON ((-87.67336 41.93234, -87.67342 41.932...</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>71</th>
      <td>0.0</td>
      <td>73</td>
      <td>73</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>WASHINGTON HEIGHTS</td>
      <td>0.0</td>
      <td>7.963575e+07</td>
      <td>42222.598163</td>
      <td>POLYGON ((-87.63373 41.72885, -87.63369 41.726...</td>
    </tr>
    <tr>
      <th>72</th>
      <td>0.0</td>
      <td>74</td>
      <td>74</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>MOUNT GREENWOOD</td>
      <td>0.0</td>
      <td>7.558429e+07</td>
      <td>48665.130539</td>
      <td>POLYGON ((-87.69646 41.70714, -87.69644 41.706...</td>
    </tr>
    <tr>
      <th>73</th>
      <td>0.0</td>
      <td>75</td>
      <td>75</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>MORGAN PARK</td>
      <td>0.0</td>
      <td>9.187734e+07</td>
      <td>46396.419362</td>
      <td>POLYGON ((-87.64215 41.68508, -87.64249 41.685...</td>
    </tr>
    <tr>
      <th>74</th>
      <td>0.0</td>
      <td>76</td>
      <td>76</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>OHARE</td>
      <td>0.0</td>
      <td>3.718356e+08</td>
      <td>173625.984660</td>
      <td>MULTIPOLYGON (((-87.83658 41.98640, -87.83658 ...</td>
    </tr>
    <tr>
      <th>75</th>
      <td>0.0</td>
      <td>77</td>
      <td>77</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>EDGEWATER</td>
      <td>0.0</td>
      <td>4.844999e+07</td>
      <td>31004.830946</td>
      <td>POLYGON ((-87.65456 41.99817, -87.65456 41.998...</td>
    </tr>
  </tbody>
</table>
<p>77 rows × 10 columns</p>
</div>



* 融合地理空间数据


```python
def df_linking_geometry(df,gdf,key_df,key_gdf,how="inner"):
    '''
    包含有属性的DataFrame格式数据合并包含有地理空间信息的GeoDataFrame格式数据，仅合并“geometry”字段和用于链接的关键字段列

    Parameters
    ----------
    df : DataFrame
        属性数据，含有用于链接的关键字段.
    gdf : GeoDataFrame
        还有地理空间信息geometry字段和用于链接的关键字段.
    key_df : string
        属性数据用于链接的关键字段名.
    key_gdf : string
        含有地理空间信息数据用于链接的关键字段名.
    how : string, optional
        {‘left’, ‘right’, ‘outer’, ‘inner’, ‘cross’}，具体解释参考pandas.DataFrame.merg. The default is "inner".

    Returns
    -------
    gdf_linked : GeoDataFrame
        属性数据合并地理空间信息后的数据.

    '''    
    gdf_linked=gdf[[key_gdf,"geometry"]].merge(df,left_on=key_gdf,right_on=key_df,how=how,)
    
    return gdf_linked
    
pubicHealth_Statistic_gdf=df_linking_geometry(pubicHealth_Statistic_df,community_area_gdf,key_df="Community Area",key_gdf="area_numbe")    
pubicHealth_Statistic_gdf=pubicHealth_Statistic_gdf.to_crs(args.gi.Chicago_epsg)
print(f"{pubicHealth_Statistic_gdf.crs}")
pubicHealth_Statistic_gdf[:3]
```

    epsg:32616
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>area_numbe</th>
      <th>geometry</th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Birth Rate</th>
      <th>General Fertility Rate</th>
      <th>Low Birth Weight</th>
      <th>Prenatal Care Beginning in First Trimester</th>
      <th>Preterm Births</th>
      <th>Teen Birth Rate</th>
      <th>...</th>
      <th>Childhood Lead Poisoning</th>
      <th>Gonorrhea in Females</th>
      <th>Gonorrhea in Males</th>
      <th>Tuberculosis</th>
      <th>Below Poverty Level</th>
      <th>Crowded Housing</th>
      <th>Dependency</th>
      <th>No High School Diploma</th>
      <th>Per Capita Income</th>
      <th>Unemployment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>POLYGON ((445789.555 4649779.811, 445691.750 4...</td>
      <td>1</td>
      <td>Rogers Park</td>
      <td>16.4</td>
      <td>62.0</td>
      <td>11.0</td>
      <td>73.0</td>
      <td>11.2</td>
      <td>40.8</td>
      <td>...</td>
      <td>0.5</td>
      <td>322.5</td>
      <td>423.3</td>
      <td>11.4</td>
      <td>22.7</td>
      <td>7.9</td>
      <td>28.8</td>
      <td>18.1</td>
      <td>23714</td>
      <td>7.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>POLYGON ((443315.818 4652166.308, 443316.880 4...</td>
      <td>2</td>
      <td>West Ridge</td>
      <td>17.3</td>
      <td>83.3</td>
      <td>8.1</td>
      <td>71.1</td>
      <td>8.3</td>
      <td>29.9</td>
      <td>...</td>
      <td>1.0</td>
      <td>141.0</td>
      <td>205.7</td>
      <td>8.9</td>
      <td>15.1</td>
      <td>7.0</td>
      <td>38.3</td>
      <td>19.6</td>
      <td>21375</td>
      <td>7.9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>POLYGON ((446874.222 4644956.738, 446627.798 4...</td>
      <td>3</td>
      <td>Uptown</td>
      <td>13.1</td>
      <td>50.5</td>
      <td>8.3</td>
      <td>77.7</td>
      <td>10.3</td>
      <td>35.1</td>
      <td>...</td>
      <td>0.5</td>
      <td>170.8</td>
      <td>468.7</td>
      <td>13.6</td>
      <td>22.7</td>
      <td>4.6</td>
      <td>22.2</td>
      <td>13.6</td>
      <td>32355</td>
      <td>7.7</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 31 columns</p>
</div>



经常需要打印地理空间信息数据，显示指定字段的属性值查看分布，同时也会增加标注，例如定位位置信息或相关分类信息等内容，因此定义`gdf_plot_annotate()`函数，方便调用。


```python
def gdf_plot_annotate(gdf_,value_column,annotate_column,**setting):
    '''
    打印GeoDataFrame格式地理空间信息数据

    Parameters
    ----------
    gdf_ : GeoDataFrame
        待打印的数据.
    value_column : string
        数值显示字段名.
    annotate_column : string
        标注显示字段名.
    **setting : key args
        用于配置图表的参数，键和默认值如下
        setting_dict=dict(annotate_fontsize=8,
                          figsize=(10,10),    
                          legend_position="right",
                          legend_size="5%",
                          legend_pad=0.1,
                          legend_bbox_to_anchor=(1, 1),
                          cmap='OrRd',
                          labelsize=8,
                          scheme=None, # 等值分类图，例如 ‘BoxPlot’, ‘EqualInterval’, ‘FisherJenks’,‘FisherJenksSampled’, ‘HeadTailBreaks’, ‘JenksCaspall’, 
                                                         ‘JenksCaspallForced’, ‘JenksCaspallSampled’, ‘MaxP’, ‘MaximumBreaks’, ‘NaturalBreaks’, ‘Quantiles’, 
                                                         ‘Percentiles’, ‘StdMean’, ‘UserDefined’等
                          k=5, # 分类数量， 对应scheme参数，如果scheme参数为None，则k参数忽略
                          categorical=False # 为True时为分类数据，为False时为数值数据
                         ).

    Returns
    -------
    ax : TYPE
        DESCRIPTION.

    '''     
    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    
    gdf=gdf_.copy(deep=True)
    setting_dict=dict(annotate_fontsize=8,
                      figsize=(10,10),    
                      legend_position="right",
                      legend_size="5%",
                      legend_pad=0.1,
                      legend_bbox_to_anchor=(1, 1),
                      cmap='OrRd',
                      labelsize=8,
                      scheme=None,
                      k=5,
                      categorical=False
                     )
    setting_dict.update(setting)
    gdf["index"]=gdf.index
    
    fig, ax=plt.subplots(figsize=setting_dict["figsize"])
    divider=make_axes_locatable(ax) 
    if setting_dict["scheme"]:
        gdf.plot(column=value_column,scheme=setting_dict["scheme"], k= setting_dict["k"],ax=ax,legend=True,cmap=setting_dict["cmap"],legend_kwds={'bbox_to_anchor':setting_dict["legend_bbox_to_anchor"]}) 
    elif setting_dict["categorical"]:
        gdf.plot(column=value_column,categorical=True,ax=ax,legend=True,cmap=setting_dict["cmap"],edgecolor='white',legend_kwds={'bbox_to_anchor':setting_dict["legend_bbox_to_anchor"]}) 
    else:   
        cax=divider.append_axes(setting_dict["legend_position"], size=setting_dict["legend_size"], pad=setting_dict["legend_pad"]) # 配置图例参数
        gdf.plot(column=value_column,scheme=setting_dict["scheme"], k= setting_dict["k"],ax=ax,cax=cax,legend=True,cmap=setting_dict["cmap"]) 
    gdf.apply(lambda x: ax.annotate(text=x[annotate_column], xy=x.geometry.centroid.coords[0], ha='center',fontsize=setting_dict["annotate_fontsize"]),axis=1) # 增加标注
    ax.tick_params(axis='both', labelsize=setting_dict["labelsize"])

    plt.show()

gdf_plot_annotate(pubicHealth_Statistic_gdf,"Lung Cancer","index",annotate_fontsize=10,scheme="Quantiles",k=5)
```


<img src="./imgs/2_7_3/output_10_0.png" height='auto' width='auto' title="caDesign">    


### 2.7.3.2 空间权重 （Spatial Weights）<sup>[1][2]</sup>

#### 1） 空间权重的基本解释


空间权重是地理数据科学和空间统计中用来表示空间关系的数学（拓扑）结构，可被理解为一个图的邻接矩阵（graph adjacency maxtrix），代表了地理信息数据集中观察单位之间的空间地理关系，表达地理位置上的接近或关联性，如空间权重$w_{i,j}$表达了地点$i$和$j$之间地理关系，通常包括毗邻性（contiguity）、地理空间距离（geospatial distance）和一般距离（general distances）。毗邻性包括3种表现形式，为共领边连接的Rook（车）连通，共顶点连接的Queen（后）连通，和共顶点连接又共领边连接的Bishop（象）连通。一般距离则是根据研究内容确定的某种成本距离，例如交通分析下的时间成本距离。许多空间分析方法，例如空间自相关和区域化算法都依赖于空间权重。

<img src="./imgs/2_7_3/2_7_3_01.png" height='auto' width='auto' title="caDesign">

在计算公共健康数据空间权重前，通过定义函数`building_meshgrid_gdf()`构建简单的网格状地理几何数据，用[PySAL](https://pysal.org/)<sup>③</sup库提供的方法计算空间权重，并定义`weights_plot()`函数显示空间权重，方便观察和理解空间权重的拓扑结构和相关统计值。


```python
def building_meshgrid_gdf(x_num=3,y_num=3,distance=1):
    '''
    给定高宽数量和间隔距离，生成polygon的网格状GeoDataFrame格式的地理几何数据，含字段id，标识polygon单元

    Parameters
    ----------
    x_num : int, optional
        高数. The default is 3.
    y_num : int, optional
        宽数. The default is 3.        
    distance : float, optional
        间隔距离. The default is 1.

    Returns
    -------
    p_gdf : GeoDataFrame
        网格状polygon地理几何数据.

    '''    
    
    import numpy as np
    from shapely.geometry import Polygon
    import geopandas as gpd

    xn=np.arange(x_num)
    yn=np.arange(y_num)
    xs,ys=np.meshgrid(xn,yn)
    polygons=[]
    for x,y in zip(xs.flatten(),ys.flatten()):
        polygon=Polygon([(x, y), (x + distance, y), (x + distance, y + distance), (x, y + distance)])
        polygons.append(polygon)

    p_gs=gpd.GeoSeries(polygons)
    p_gdf=gpd.GeoDataFrame({
                          "geometry":p_gs,
                          "id":["P-%s" % str(i).zfill(2) for i in range(len(polygons))],
                          })
    return p_gdf
    
p_gdf=building_meshgrid_gdf(3,3)
p_gdf
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((0.00000 0.00000, 1.00000 0.00000, 1....</td>
      <td>P-00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((1.00000 0.00000, 2.00000 0.00000, 2....</td>
      <td>P-01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((2.00000 0.00000, 3.00000 0.00000, 3....</td>
      <td>P-02</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((0.00000 1.00000, 1.00000 1.00000, 1....</td>
      <td>P-03</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((1.00000 1.00000, 2.00000 1.00000, 2....</td>
      <td>P-04</td>
    </tr>
    <tr>
      <th>5</th>
      <td>POLYGON ((2.00000 1.00000, 3.00000 1.00000, 3....</td>
      <td>P-05</td>
    </tr>
    <tr>
      <th>6</th>
      <td>POLYGON ((0.00000 2.00000, 1.00000 2.00000, 1....</td>
      <td>P-06</td>
    </tr>
    <tr>
      <th>7</th>
      <td>POLYGON ((1.00000 2.00000, 2.00000 2.00000, 2....</td>
      <td>P-07</td>
    </tr>
    <tr>
      <th>8</th>
      <td>POLYGON ((2.00000 2.00000, 3.00000 2.00000, 3....</td>
      <td>P-08</td>
    </tr>
  </tbody>
</table>
</div>



打印显示生成的网格状地理几何数据，总共9个单元，每个单元高宽为1，并标注字段`id`信息。


```python
ax=p_gdf.plot(facecolor="w", edgecolor="k")
_=p_gdf.apply(lambda x: ax.annotate(text=x["id"], xy=x.geometry.centroid.coords[0], ha='center',fontsize=15),axis=1)
```


<img src="./imgs/2_7_3/output_14_0.png" height='auto' width='auto' title="caDesign">    


```python
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

def weights_plot(gdf,weights,annotate_column=None,**setting):  
    '''
    打印显示空间权重

    Parameters
    ----------
    gdf : GeoDataFrame
        地理空间数据.
    weights : libpysal.weights
        有PySAL库计算的空间权重.
    annotate_column : string, optional
        用于标注的列名. The default is None.
    **setting : key args
        打印样式参数配置，包括：
                        setting_dict=dict(figsize=(10,10),
                                  annotate_fontsize=8,
                                  ax=None,
                                  ).

    Returns
    -------
    ax : AxesSubplot
        子图.

    '''    
    setting_dict=dict(figsize=(10,10),
                      annotate_fontsize=8,
                      ax=None,
                      )
    setting_dict.update(setting)

    if setting_dict["ax"]:
        ax=setting_dict["ax"]
        gdf.plot(edgecolor="grey",facecolor="w",figsize=setting_dict["figsize"],ax=ax)
    else:
        ax=gdf.plot(edgecolor="grey",facecolor="w",figsize=setting_dict["figsize"])
    f,ax=weights.plot(gdf,
                      ax=ax,
                      edge_kws=dict(color='r', linestyle=':', linewidth=1),
                      node_kws=dict(marker='')
                      )
    if annotate_column:
        gdf["index"]=gdf.index
        gdf.apply(lambda x: ax.annotate(text=x[annotate_column], xy=x.geometry.centroid.coords[0], ha='center',fontsize=setting_dict["annotate_fontsize"]),axis=1) # 增加标注
```

Rook连通/邻接（contiguity）如下图，单元间共享一条边，红色虚线为邻接连通，例如单元0的Rook邻接有1和3，单元1的Rook邻接有0、2和4，单元4的Rook邻接有1、3、7和5。


```python
import libpysal.weights as LW

wr=LW.contiguity.Rook.from_dataframe(p_gdf)
weights_plot(p_gdf,wr,annotate_column="id",figsize=(5,5),annotate_fontsize=15)
```


<img src="./imgs/2_7_3/output_17_0.png" height='auto' width='auto' title="caDesign">    

`PySAL`计算返回的权重值包含多个属性，因为空间矩阵往往十分稀疏，因此用字典存储邻接矩阵的`w.neighbors`方法，和存储权重矩阵的`w.weights`方法，节省存储空间。可以通过`w.nonzeros`方法查看非零值的数量为24，表明有$9 \times 9-24=57$个零值，并通过值为0表示非连通，和值为1表示连通的矩阵表述。该矩阵量化了包含空值的数量，且大部分包含空值零，为稀疏矩阵。对于稀疏矩阵，尤其规模大的稀疏矩阵，通常只存储非零值而不是包含空值的所有值，以减少存储规模并方便计算。


```python
import pandas as pd

print(f"neighbors: {wr.neighbors};\nnonzeros: {wr.nonzero}")
wr_neighbors_df=pd.DataFrame(*wr.full()).astype(int)
wr_neighbors_df
```

    neighbors: {0: [1, 3], 1: [0, 2, 4], 2: [1, 5], 3: [0, 4, 6], 4: [1, 3, 5, 7], 5: [8, 2, 4], 6: [3, 7], 7: [8, 4, 6], 8: [5, 7]};
    nonzeros: 24
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



Queen连通如下图，单元间共享一个或多个顶点，因此对于单元0的Queen邻接除了1和3单元的Rook边邻接外，还包括顶点邻接单元4，其它单元以此类推。对于$9 \times 9$的矩阵，空间权重非零值有40个，较之Rook邻接增加了16个顶点邻接单元。`w.cardinalities`方法报告了每个单元的邻接数量，`w.histogram`方法则显示了邻接单元数的频数，例如包含有3个邻接单元的单元数有4个，分别为单元0、2、6和8。


```python
wq=LW.contiguity.Queen.from_dataframe(p_gdf)
print(f"neighbors: {wq.neighbors};\nnonzeros: {wq.nonzero};\nweights:\n{wq.weights} ;\ncardinalities: {wq.cardinalities};\nhistogram: {wq.histogram}")
weights_plot(p_gdf,wq,annotate_column="id",figsize=(5,5),annotate_fontsize=15)
```

    neighbors: {0: [1, 3, 4], 1: [0, 2, 3, 4, 5], 2: [1, 4, 5], 3: [0, 1, 4, 6, 7], 4: [0, 1, 2, 3, 5, 6, 7, 8], 5: [1, 2, 4, 7, 8], 6: [3, 4, 7], 7: [3, 4, 5, 6, 8], 8: [4, 5, 7]};
    nonzeros: 40;
    weights:
    {0: [1.0, 1.0, 1.0], 1: [1.0, 1.0, 1.0, 1.0, 1.0], 2: [1.0, 1.0, 1.0], 3: [1.0, 1.0, 1.0, 1.0, 1.0], 4: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], 5: [1.0, 1.0, 1.0, 1.0, 1.0], 6: [1.0, 1.0, 1.0], 7: [1.0, 1.0, 1.0, 1.0, 1.0], 8: [1.0, 1.0, 1.0]} ;
    cardinalities: {0: 3, 1: 5, 2: 3, 3: 5, 4: 8, 5: 5, 6: 3, 7: 5, 8: 3};
    histogram: [(3, 4), (4, 0), (5, 4), (6, 0), (7, 0), (8, 1)]
    




    <AxesSubplot:>




<img src="./imgs/2_7_3/output_21_2.png" height='auto' width='auto' title="caDesign">    


#### 2） Rook neighbors 空间权重——公共健康数据

仅提取索引值为2的邻接单元和对应的社区名称，有单元3、76和5。计算$77 \times 77$的稀疏矩阵，非零数位358个，用`w.pct_nonzeeros`方法可以返回非零数占总数的百分比为$358 \div (77 \times 77) \times 100\%=6.038\%$。


```python
import libpysal.weights as LW

w_rook_pubStats=LW.Rook.from_dataframe(pubicHealth_Statistic_gdf)
idx=2
print(f"neighbors num:{w_rook_pubStats.n};\nnonzero:{w_rook_pubStats.nonzero};\npct_nonzero:{w_rook_pubStats.pct_nonzero};\nneighbors with index {idx}:{w_rook_pubStats.neighbors[idx]};\nneighbor names:\n {pubicHealth_Statistic_gdf['Community Area Name'][w_rook_pubStats.neighbors[idx]+[idx]]}")
weights_plot(pubicHealth_Statistic_gdf,w_rook_pubStats,"index",annotate_fontsize=12)
```

    neighbors num:77;
    nonzero:358;
    pct_nonzero:6.038117726429415;
    neighbors with index 2:[3, 76, 5];
    neighbor names:
     3     Lincoln Square
    76         Edgewater
    5          Lake View
    2             Uptown
    Name: Community Area Name, dtype: object
    


<img src="./imgs/2_7_3/output_23_1.png" height='auto' width='auto' title="caDesign">    

绘制`w.cardinalities`方法返回的邻接数的频数，可以观察到邻接数为4的单元最多，其次为5、6、3等。


```python
w_rook_cardinalities_series=pd.Series(w_rook_pubStats.cardinalities)
w_rook_cardinalities_series.plot.hist(bins=w_rook_cardinalities_series.unique().shape[0])
```




    <AxesSubplot:ylabel='Frequency'>




<img src="./imgs/2_7_3/output_25_1.png" height='auto' width='auto' title="caDesign">   


提取观察前5个单元的权重值，只要毗邻的就为1，否则为0（不存储）。


```python
{k:w_rook_pubStats.weights[k] for k in [0,1,2,3,4]}
```




    {0: [1.0, 1.0],
     1: [1.0, 1.0, 1.0, 1.0],
     2: [1.0, 1.0, 1.0],
     3: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
     4: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]}



#### 3） Queen neighbors 空间权重——公共健康数据

类似Rook neighbors方法计算，可以获取返回空间权重值及相关属性统计量。


```python
w_queen_pubStats=LW.Queen.from_dataframe(pubicHealth_Statistic_gdf)
print(f"neighbors num:{w_queen_pubStats.n};\nnonzero:{w_queen_pubStats.nonzero};\npct_nonzero:{w_queen_pubStats.pct_nonzero};\nneighbors with index {idx}:{w_queen_pubStats.neighbors[idx]};\nneighbor names:\n {pubicHealth_Statistic_gdf['Community Area Name'][w_queen_pubStats.neighbors[idx]+[idx]]}")
weights_plot(pubicHealth_Statistic_gdf,w_queen_pubStats,"index",annotate_fontsize=12)
```

    neighbors num:77;
    nonzero:394;
    pct_nonzero:6.645302749198853;
    neighbors with index 2:[3, 4, 5, 76];
    neighbor names:
     3     Lincoln Square
    4       North Center
    5          Lake View
    76         Edgewater
    2             Uptown
    Name: Community Area Name, dtype: object
    




    <AxesSubplot:>




<img src="./imgs/2_7_3/output_29_2.png" height='auto' width='auto' title="caDesign">    


```python
print(f"histogram: {w_queen_pubStats.histogram};\nneighbors with index {idx}:{w_queen_pubStats.neighbors[idx]};")
```

    histogram: [(1, 1), (2, 3), (3, 8), (4, 19), (5, 13), (6, 16), (7, 11), (8, 5), (9, 1)];
    neighbors with index 2:[3, 4, 5, 76];
    

#### 4） KNN neighbors 空间权重 （K-Nearest Neighbor weights）

除了毗邻性（contiguity），地理空间距离（geospatial distance）的权重为观察单元与邻里单元间的空间距离，中心点由GeoDataFrame中的空间信息计算出。`PySAL`库提供了`KNN`方法，可以指定邻里单元数（参数`k`）确定最近距离单元连通数量。


```python
w_knn_pubStats=LW.KNN.from_dataframe(pubicHealth_Statistic_gdf,k=3)
weights_plot(pubicHealth_Statistic_gdf,w_knn_pubStats,"index",annotate_fontsize=12)
```


<img src="./imgs/2_7_3/output_32_0.png" height='auto' width='auto' title="caDesign">    

提取空间权重值，可以观察到指定`k`数量最近空间距离单元的权重值均为1，否则为0（不存储）。


```python
w_knn_df=pd.DataFrame(w_knn_pubStats.weights).T
w_knn_df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>72</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>73</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>74</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>75</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>76</th>
      <td>1.0</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
<p>77 rows × 3 columns</p>
</div>



#### 5） Kernal 空间权重（Kernel weights）

根据Waldo Tobler的说法，地理学第一定律是“一切事物都与其他事物相关，但近处的事物比远处的事物更相关”<sup>[3]</sup>。Tobler的第一定律是空间依赖性和空间自相关的基本概念的基础，用于空间插值的反距离加权法，并支持kriging（克里格）区域化变量理论<sup>[4]</sup>，是所有空间分析中的基本假设。`PySAL`支持连续值权重，例如Kernal 空间权重（距离权重），以更直接的方式反应地理学第一定律。

Kernal 空间权重是最常用的一种距离权重，反映了空间单元相似性（接近性）随距离增加衰减的情况（特性），即观测值（单元值）与观测值之间的空间权重是基于它们之间的距离，但是被具有某些特性的kernel函数优化，使其具有距离衰减的特性，但可能会以不同的速度相对于距离进行衰减。

`w.distance.Kernal`包含`bandwidth`可选参数，配置缓冲距离，超过该参数值的单元权重为0；`k`可选参数，同KNN 空间权重，配置满足`bandwith`参数之下，最近的k个单元，其余的权重均为0。

默认`bandwidth`和`k`参数，计算结果如下。


```python
w_kernel_pubStats=LW.distance.Kernel.from_dataframe(pubicHealth_Statistic_gdf)
weights_plot(pubicHealth_Statistic_gdf,w_kernel_pubStats,"index",annotate_fontsize=12)
```


<img src="./imgs/2_7_3/output_36_0.png" height='auto' width='auto' title="caDesign">    


```python
print("Neighborhood cells with index values of [0,1]: %s;weights:%s"%({k:w_kernel_pubStats.neighbors[k] for k in [0,75]},{k:w_kernel_pubStats.weights[k] for k in [0,75]}))
print(f"bandwidth:\n {w_kernel_pubStats.bandwidth[:3]}")
```

    Neighborhood cells with index values of [0,1]: {0: [13, 12, 11, 5, 4, 2, 3, 76, 1, 0], 75: [75, 9, 8]};weights:{0: [0.16866186834038388, 0.30053319508986687, 0.005684039422874099, 0.02596010826224393, 0.0785766333091692, 0.33703077271339976, 0.45886912756515374, 0.6550849730275031, 0.7029166480913323, 1.0], 75: [1.0, 9.99999900663795e-08, 0.005604407259564681]}
    bandwidth:
     [[7551.42606251]
     [7551.42606251]
     [7551.42606251]]
    

固定`bandwidth`可能并不是最佳选择，例如观测区域单元密度变化较大的情况，较大密度范围内的邻接密度高，而稀疏范围内的邻接密度低，因此可以配置`fixed`参数值为`False`，使用K-近邻规则自适应调整缓冲距离。一旦考虑给定`k`参数值邻近观测值，剩下的观测值的空间权重则为0。下述计算配置`k=10`，可以提取bandwidth信息，发现缓冲距离并不是固定一个值。


```python
w_kernel_adaptive_bandwidthK_pubStats=LW.distance.Kernel.from_dataframe(pubicHealth_Statistic_gdf,fixed=False,k=10)
print("Neighborhood cells with index values of [0,1]: %s;weights:%s"%({k:w_kernel_adaptive_bandwidthK_pubStats.neighbors[k] for k in [0,75]},{k:w_kernel_adaptive_bandwidthK_pubStats.weights[k] for k in [0,75]}))
print(f"bandwidth:\n {w_kernel_adaptive_bandwidthK_pubStats.bandwidth[:3]}")
weights_plot(pubicHealth_Statistic_gdf,w_kernel_adaptive_bandwidthK_pubStats,"index",annotate_fontsize=12)
```

    Neighborhood cells with index values of [0,1]: {0: [0, 1, 76, 3, 2, 12, 13, 4, 5, 11, 15], 75: [75, 8, 9, 16, 17, 10, 14, 11, 18, 24, 12]};weights:{0: [1.0, 0.7059466557922132, 0.6586028247723479, 0.4643882207762944, 0.3437925176958082, 0.30766718557358774, 0.17714083871950848, 0.08797439955526709, 0.03589452011659111, 0.01582525062943063, 9.99999900663795e-08], 75: [1.0, 0.46823640098244257, 0.4652394381840269, 0.4366454123752175, 0.3304402909469787, 0.2806741382356108, 0.21664465623407503, 0.19315892507283117, 0.15670867768694086, 0.0003303421393521244, 9.99999900663795e-08]}
    bandwidth:
     [[7629.23806353]
     [6794.76626129]
     [5762.32953627]]
    


<img src="./imgs/2_7_3/output_39_1.png" height='auto' width='auto' title="caDesign">    


可以通过地图打印直观查看给定单元的空间权重值分布情况，上述`k`值配置为10，因此只有邻近（含自身）的10个单元权重，其余空间权重值为0.


```python
import matplotlib.pyplot as plt

full_matrix, ids=w_kernel_adaptive_bandwidthK_pubStats.full()
f, ax=plt.subplots(1, 2, figsize=(12, 6), subplot_kw=dict(aspect="equal"))
pubicHealth_Statistic_gdf.assign(weight_0=full_matrix[0]).plot("weight_0", cmap="plasma", ax=ax[0])
pubicHealth_Statistic_gdf.assign(weight_0=full_matrix[75]).plot("weight_0", cmap="plasma", ax=ax[1])

# Add centroid of focal tracts
pubicHealth_Statistic_gdf.iloc[[0], :].centroid.plot(ax=ax[0], marker="*", color="k", label="Focal Tract")
pubicHealth_Statistic_gdf.iloc[[75], :].centroid.plot(ax=ax[1], marker="*", color="k", label="Focal Tract")

ax[0].set_title("Kernel centered on first tract")
ax[1].set_title("Kernel centered on 75th tract")
# Remove axis
[ax_.set_axis_off() for ax_ in ax]
# Add legend
[ax_.legend(loc="upper left") for ax_ in ax];
```


<img src="./imgs/2_7_3/output_41_0.png" height='auto' width='auto' title="caDesign">    

#### 6）距离缓冲带和混合权重（Distance bands and hybrid Weights）

配置目标单元一个给定半径距离的圆形缓冲区域，只有落在该圆形缓冲区域内的单元计算空间权重，参数`binary`可以配置空间权重为二进制或连续值的形式。


```python
w_distanceband_binary_pubStats=LW.distance.DistanceBand.from_dataframe(pubicHealth_Statistic_gdf,10000,binary=True)
w_distanceband_binary_pubStats.weights[0]
```




    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]




```python
w_distanceband_numerical_pubStats=LW.distance.DistanceBand.from_dataframe(pubicHealth_Statistic_gdf,10000,binary=False)
w_distanceband_numerical_pubStats.weights[0]
```




    [0.0004457513942007562,
     0.0001997457994379509,
     0.00024471957719075977,
     0.00014371821151303165,
     0.00013595471749197705,
     0.00010200262902818481,
     0.00011065100827986884,
     0.0001331823319322558,
     0.00018932323503777486,
     0.00015929176500392128,
     0.00010113809568491048,
     0.00013107470125748466,
     0.00011653491130540765,
     0.00010061185161683936,
     0.0003839360652665388]



#### 7）Lattice 空间权重 （Lattice Weights）

创建一个用于规则网格的权重对象，类似于“空间权重的基本解释”部分给出的构建简单的网格状地理几何数据并计算空间权重的方法。


```python
lat2w=LW.lat2W(4,3)
print(f"num: {lat2w.n};\npct_nonzero: {lat2w.pct_nonzero};\nneighbors: {lat2w.neighbors}")
print(lat2w.weights)
weights_plot(p_gdf,wr,annotate_column="id",figsize=(5,5),annotate_fontsize=15)
```

    num: 12;
    pct_nonzero: 23.61111111111111;
    neighbors: {0: [3, 1], 3: [0, 6, 4], 1: [0, 4, 2], 4: [1, 3, 7, 5], 2: [1, 5], 5: [2, 4, 8], 6: [3, 9, 7], 7: [4, 6, 10, 8], 8: [5, 7, 11], 9: [6, 10], 10: [7, 9, 11], 11: [8, 10]}
    {0: [1.0, 1.0], 3: [1.0, 1.0, 1.0], 1: [1.0, 1.0, 1.0], 4: [1.0, 1.0, 1.0, 1.0], 2: [1.0, 1.0], 5: [1.0, 1.0, 1.0], 6: [1.0, 1.0, 1.0], 7: [1.0, 1.0, 1.0, 1.0], 8: [1.0, 1.0, 1.0], 9: [1.0, 1.0], 10: [1.0, 1.0, 1.0], 11: [1.0, 1.0]}
    


<img src="./imgs/2_7_3/output_46_1.png" height='auto' width='auto' title="caDesign">    

#### 8）地球表面的曲率

上述在计算空间权重前已经将公共健康数据投影到`epsg=32616`的芝加哥区域，但是如果仍为wgs84，又不可能或不方便进行投影，则可以考虑非投影参考系统（如经度/纬度）中隐含曲率的近似值配置`radius`参数进行计算，可以发现计算结果约等于上述对应的计算结果。

`w.to_adjlist()`方法可以将空间权重返回为各单元对应邻接单元权重的DataFrame格式数据。


```python
from pysal.lib import cg as geometry
radius=geometry.sphere.RADIUS_EARTH_MILES

w_kernel_adaptive_bandwidthK_radius_pubStats=LW.distance.Kernel.from_dataframe(pubicHealth_Statistic_gdf.to_crs(args.gi.epsg_wgs84),fixed=False,k=10,radius=radius)
w_kernel_adaptive_bandwidthK_radius_pubStats.to_adjlist()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>focal</th>
      <th>neighbor</th>
      <th>weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>1.000000e+00</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>7.065094e-01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>2</td>
      <td>3.431105e-01</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>3</td>
      <td>4.639753e-01</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>4</td>
      <td>8.693914e-02</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>842</th>
      <td>76</td>
      <td>12</td>
      <td>2.498819e-01</td>
    </tr>
    <tr>
      <th>843</th>
      <td>76</td>
      <td>13</td>
      <td>2.123117e-01</td>
    </tr>
    <tr>
      <th>844</th>
      <td>76</td>
      <td>15</td>
      <td>6.983849e-02</td>
    </tr>
    <tr>
      <th>845</th>
      <td>76</td>
      <td>20</td>
      <td>9.999999e-08</td>
    </tr>
    <tr>
      <th>846</th>
      <td>76</td>
      <td>76</td>
      <td>1.000000e+00</td>
    </tr>
  </tbody>
</table>
<p>847 rows × 3 columns</p>
</div>



#### 9）Block 空间权重 （Block Weights）

Block 空间权重是按照分组/分类/区块定义邻接关系，为各组内单元彼此连通，即使单元间不一定在地理空间位置上彼此连接，例如单元0（图左黄色标识邻接具有权重的单元），而非组内的单元则被赋予0值。


```python
#import warnings
#warnings.filterwarnings('ignore')
import numpy as np
import matplotlib.pyplot as plt

p_g_gdf=building_meshgrid_gdf(5,5)
regimes=np.ones(25)
regimes[range(10,20)]=2
regimes[range(21,25)]=3
p_g_gdf["regime"]=regimes
p_g_gdf["id_regime"]=p_g_gdf.apply(lambda row:f"{row.id}_{row.regime}",axis=1)

w_b=LW.block_weights(p_g_gdf["regime"])
full_matrix, ids=w_b.full()

f, ax=plt.subplots(1, 2, figsize=(12, 6), subplot_kw=dict(aspect="equal"))
p_g_gdf.assign(weight_0=full_matrix[0]).plot("weight_0", cmap="plasma", ax=ax[0])
p_g_gdf.assign(weight_0=full_matrix[24]).plot("weight_0", cmap="plasma", ax=ax[1])

# Add centroid of focal tracts
p_g_gdf.iloc[[0], :].centroid.plot(ax=ax[0], marker="*", color="r", label="Focal Tract")
p_g_gdf.iloc[[24], :].centroid.plot(ax=ax[1], marker="*", color="r", label="Focal Tract")

ax[0].set_title("Kernel centered on first tract")
ax[1].set_title("Kernel centered on 24th tract")
# Remove axis
[ax_.set_axis_off() for ax_ in ax]
# Add legend
[ax_.legend(loc="lower right") for ax_ in ax];

# annotate
_=p_g_gdf.apply(lambda x: ax[0].annotate(text=x["id_regime"], xy=x.geometry.centroid.coords[0], ha='center',fontsize=10),axis=1)
_=p_g_gdf.apply(lambda x: ax[1].annotate(text=x["id_regime"], xy=x.geometry.centroid.coords[0], ha='center',fontsize=10),axis=1)
```

    C:\Users\richi\anaconda3\envs\usda\lib\site-packages\libpysal\weights\weights.py:172: UserWarning: The weights matrix is not fully connected: 
     There are 3 disconnected components.
      warnings.warn(message)
    


<img src="./imgs/2_7_3/output_50_1.png" height='auto' width='auto' title="caDesign">    

### 2.7.3.3 空间自相关 (Spatial Autocorrelation)

相关性描述了两个变量之间的关系；自相关描述了在两个不同的对象或同一对象不同时间上对同一变量进行的两个观测之间的关系；空间自相关是一种自相关，其中成对的对象由它们之间的距离定义，表明空间分布上的不同。空间自相关的目的是为了寻找某一变量（属性）在空间分布上的特征（模式），即空间结构，这涉及到两个内容，一个是衡量空间分布的空间相似性，通常用空间权重衡量；另一个是匹配空间相似性的衡量标准属性相似性，通常用空间滞后（延迟）衡量。

#### 1）空间相似性（Spatial Similarity）与属性相似性（Attribute Similarity） 

对公共健康数据采用queen空间权重，考虑邻边和一个到多个顶点的连通，实现空间相似性的计算。对于属性相似性，根据公式：$ylag_{i} = \sum_{j=1}^n w_{ij}   y_{j} $计算，式中$w_{ij}$为空间权重，表述单元$i$和单元$j$之间是否连通；$y_{j}$为连通单元的属性值。如果空间权重为1或0表述，则目标单元的空间滞后为其连通单元的属性值和均值；如果为连续变化值，则目标单元的空间滞后为连通单元属性值空间权重加权后的和均值。


为了清晰计算过程，移除不相关的属性字段，仅保留测量值`Lung Cancer`字段，地理空间几何`geometry`字段和用于标识单元（社区）的ID。空间滞后使用`w.lag_spatial`方法计算。


```python
LungCancer_gdf=pubicHealth_Statistic_gdf[["geometry","Community Area","Community Area Name","Lung Cancer"]]
LungCancer_gdf[:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((445789.555 4649779.811, 445691.750 4...</td>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((443315.818 4652166.308, 443316.880 4...</td>
      <td>2</td>
      <td>West Ridge</td>
      <td>36.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((446874.222 4644956.738, 446627.798 4...</td>
      <td>3</td>
      <td>Uptown</td>
      <td>50.5</td>
    </tr>
  </tbody>
</table>
</div>




```python
import pandas as pd
pd.options.mode.chained_assignment = None  # default='warn'

w_queen_pubStats=LW.Queen.from_dataframe(pubicHealth_Statistic_gdf)
w_queen_pubStats.transform='r'
LungCancer_gdf["lag"]=list(LW.lag_spatial(w_queen_pubStats,LungCancer_gdf['Lung Cancer']))
LungCancer_gdf
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((445789.555 4649779.811, 445691.750 4...</td>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.0500</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((443315.818 4652166.308, 443316.880 4...</td>
      <td>2</td>
      <td>West Ridge</td>
      <td>36.0</td>
      <td>38.6500</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((446874.222 4644956.738, 446627.798 4...</td>
      <td>3</td>
      <td>Uptown</td>
      <td>50.5</td>
      <td>39.5250</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POLYGON ((444126.139 4647342.956, 444126.361 4...</td>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.3000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POLYGON ((444174.409 4642483.583, 444169.878 4...</td>
      <td>5</td>
      <td>North Center</td>
      <td>42.4</td>
      <td>39.3125</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>72</th>
      <td>POLYGON ((447293.327 4619865.787, 447295.721 4...</td>
      <td>73</td>
      <td>Washington Heights</td>
      <td>70.0</td>
      <td>58.3250</td>
    </tr>
    <tr>
      <th>73</th>
      <td>POLYGON ((442056.996 4617496.001, 442058.132 4...</td>
      <td>74</td>
      <td>Mount Greenwood</td>
      <td>55.0</td>
      <td>48.9500</td>
    </tr>
    <tr>
      <th>74</th>
      <td>POLYGON ((446556.956 4615011.389, 446528.614 4...</td>
      <td>75</td>
      <td>Morgan Park</td>
      <td>50.0</td>
      <td>64.3600</td>
    </tr>
    <tr>
      <th>75</th>
      <td>MULTIPOLYGON (((430701.343 4648604.251, 430701...</td>
      <td>76</td>
      <td>O'Hare</td>
      <td>37.4</td>
      <td>49.2000</td>
    </tr>
    <tr>
      <th>76</th>
      <td>POLYGON ((445789.555 4649779.811, 445789.556 4...</td>
      <td>77</td>
      <td>Edgewater</td>
      <td>40.1</td>
      <td>41.5750</td>
    </tr>
  </tbody>
</table>
<p>77 rows × 5 columns</p>
</div>



配置参数`scheme`，按分位数（Quantiles）给定参数`k`划分数量，显示空间滞后地图。


```python
gdf_plot_annotate(LungCancer_gdf,"lag","Lung Cancer",annotate_fontsize=10,scheme="Quantiles",k=5)
```


<img src="./imgs/2_7_3/output_55_0.png" height='auto' width='auto' title="caDesign">    


#### 2）全局空间自相关（Global Spatial Autocorrelation ）

* 二进制方式 （Binary Case） 

二进制方式是指测量数据的值只包含0和1，一类情况是测量值本身即为0或1；另一类是将连续数值按照中位数或均值等切分为0或1的值。二进制方式是最简单观察数值空间分布的手段，其中大于中位数的值数量有38个单元，通过显示高值和低值的集聚或分散情况，可以初步判断感染肺癌人数的分布是存在集聚关系的，即如果一个单元为高值，则邻近的单元也趋近于高值；反之，如果一个单元为低值，则邻近单元也趋近于低值的关系。


```python
LC_val=LungCancer_gdf['Lung Cancer']
LC_val_binary=LC_val>LC_val.median()
print(f"number greater than median: {sum(LC_val_binary)}")
```

    number greater than median: 38
    


```python
LC_binary_labels=["0_low","1_high"]
LC_val_binary=[LC_binary_labels[i] for i in 1*LC_val_binary]
LungCancer_gdf["binary_median"]=LC_val_binary
LungCancer_gdf[:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>geometry</th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>POLYGON ((445789.555 4649779.811, 445691.750 4...</td>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.050</td>
      <td>0_low</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POLYGON ((443315.818 4652166.308, 443316.880 4...</td>
      <td>2</td>
      <td>West Ridge</td>
      <td>36.0</td>
      <td>38.650</td>
      <td>0_low</td>
    </tr>
    <tr>
      <th>2</th>
      <td>POLYGON ((446874.222 4644956.738, 446627.798 4...</td>
      <td>3</td>
      <td>Uptown</td>
      <td>50.5</td>
      <td>39.525</td>
      <td>1_high</td>
    </tr>
  </tbody>
</table>
</div>




```python
gdf_plot_annotate(LungCancer_gdf,"binary_median","index",annotate_fontsize=10,categorical=True)
```


<img src="./imgs/2_7_3/output_59_0.png" height='auto' width='auto' title="caDesign">   

* 邻接数 （Join counts） 

为量化高值集聚或低值集聚，引入连接数计算，计数两两一对单元是高值-高值（Black-Black，BB）、低值-低值（White-white，WW）还是高值-低值（Black-White，BW）。使用`jc.bb`，`jc.ww`和`jc.bw`方法计算邻接数，从计算结果$BB+BW=65+64=129$来看，测量值趋向于“同类”集聚。


```python
import esda
import numpy as np

LC_val_binary=1*(LC_val>LC_val.median())
np.random.seed(7777777)
w_queen_pubStats.transform='b'
LC_jc=esda.join_counts.Join_Counts(LC_val_binary,w_queen_pubStats)
print(f"BB: {LC_jc.bb};\nWW: {LC_jc.ww};\nBW: {LC_jc.bw}\nall possibilities: {w_queen_pubStats.s0/2}\nmean_BB: {LC_jc.mean_bb}")
```

    BB: 65.0;
    WW: 64.0;
    BW: 68.0
    all possibilities: 197.0
    mean_BB: 47.3973973973974
    

如何确定BB或WW分布是趋于集聚而不是完全随机分布的？`PySAL`库的`jc.sim_bb`方法使用观察到的属性值的随机空间排列生成完全空间随机（complete spatial randomness，CSR）无效情况下的数组数据，重复了大量次数（默认为999次），以构建一个参考分布来评估计数的统计意义。从计算结果来看，每次重新随机分布已有属性值到各个空间单元（相当于打乱实际属性值分布，使其空间分布随机），并统计每次的BB连接数，发现BB连接数位于33到64之间，均值为47.397，而实际BB连接数为65，高于CRS分布最大值，且p-value=0.001，小于显著性水平0.05，拒绝原假设，即实际BB的空间分布不是空间随机的，可以说明具有一定的集聚性。


```python
import seaborn as sbn
import matplotlib.pyplot as plt

print(f"p-value sim_bb: {LC_jc.p_sim_bb}")
print(f"sim_bb min: {LC_jc.sim_bb.min()},sim_bb max: {LC_jc.sim_bb.max()},sim_bb mean: {LC_jc.mean_bb}")

sbn.kdeplot(LC_jc.sim_bb, shade=True)
plt.vlines(LC_jc.bb, 0, 0.075, color='r')
plt.vlines(LC_jc.mean_bb, 0,0.075)
plt.xlabel('BB Counts')

plt.show()
```

    p-value sim_bb: 0.001
    sim_bb min: 33.0,sim_bb max: 64.0,sim_bb mean: 47.3973973973974
    


<img src="./imgs/2_7_3/output_63_1.png" height='auto' width='auto' title="caDesign">    


* [权重变换](https://pysal.org/libpysal/_modules/libpysal/weights/weights.html#W.set_transform) （Transformations of weights）——`w.transform`

可以直接对空间权重执行权重转换，参数包括：

B – Binary，二进制。目标单元的连通单元均为1

R – Row-standardization (global sum=n)，行-标准化。因为值为1，因此和为行（连通样本数）数。例如单元1含有4个连通单元，因此值为1/4=0.25

D – Double-standardization (global sum=1)，加倍-标准化。为测量值除以单元数，和为1。例如，本例有77个单元，1/77=0.012987012987012988

V – Variance stabilizing，方差稳定化

O – Restore original transformation (from instantiation)，恢复原始转换（从实例化对象）


```python
w_queen_pubStats.transform="b"
keys_lst=[0,1,2]
{k:w_queen_pubStats.weights[k] for k in keys_lst}
```




    {0: [1.0, 1.0], 1: [1.0, 1.0, 1.0, 1.0], 2: [1.0, 1.0, 1.0, 1.0]}




```python
w_queen_pubStats.transform="r"
{k:w_queen_pubStats.weights[k] for k in keys_lst}
```




    {0: [0.5, 0.5], 1: [0.25, 0.25, 0.25, 0.25], 2: [0.25, 0.25, 0.25, 0.25]}




```python
w_queen_pubStats.transform="d"

print(w_queen_pubStats.nonzero)
{k:w_queen_pubStats.weights[k] for k in keys_lst}
```

    394
    




    {0: [0.012987012987012988, 0.012987012987012988],
     1: [0.012987012987012988,
      0.012987012987012988,
      0.012987012987012988,
      0.012987012987012988],
     2: [0.012987012987012988,
      0.012987012987012988,
      0.012987012987012988,
      0.012987012987012988]}




```python
w_queen_pubStats.transform="v"
{k:w_queen_pubStats.weights[k] for k in keys_lst}
```




    {0: [0.31728195118702557, 0.31728195118702557],
     1: [0.22435221923244497,
      0.22435221923244497,
      0.22435221923244497,
      0.22435221923244497],
     2: [0.22435221923244497,
      0.22435221923244497,
      0.22435221923244497,
      0.22435221923244497]}




```python
w_queen_pubStats.transform="o"
{k:w_queen_pubStats.weights[k] for k in keys_lst}
```




    {0: [1.0, 1.0], 1: [1.0, 1.0, 1.0, 1.0], 2: [1.0, 1.0, 1.0, 1.0]}




```python
LungCancer_gdf.shape
```




    (77, 6)



* 连续值方式（Continuous Case）

__全局 Moran’s I指数（全局莫兰指数）__

对于Moran’s I指数，若$n$代表某一变量的样本总数，$x_{i} $为空间位置或空间单元$i$处的变量观测值，则该变量的全局Moran’s I指数（Global Moran’s I）为：$GI= \frac{n \sum_{i=1}^n \sum_{j=1}^n  w_{ij} ( x_{i}- \overline{x}  ) ( x_{j}- \overline{x}  )}{\sum_{i=1}^n \sum_{j=1}^n   ( x_{i}- \overline{x}  )^{2} } $，式中，$x_{i} $为单元$i$的观测值；$w_{ij}$为空间权重矩阵。Moran’s I指数的值域为[-1,1]，小于0表示负相关，大于0表示正相关，等于0则表示研究区域个单元间彼此独立。Moran’s I值越趋近于1，表明研究对象属性测量值在空间分布上呈现集聚效应越显著；Moran’s I值越趋近于-1，则表明研究对象属性测量值在空间分布上呈现异质性（趋异性）越显著。

计算公共健康数据的全局Moran’s I指数，结果为0.431，可以判断感染肺癌人数的分布是存在一定集聚关系的。同样，将Moran’s I指数对照CRS无效情况下的数组数据，可以发现p-value=0.001，拒绝原假设，表明单元测量值之间具有集聚性。

`PySAL`的`splot`模块提供了`plot_moran`方法，可以直接打印Moran’s I指数，这包括CRS参考分布图表，及属性值和空间滞后的散点图，含回归曲线。


```python
from splot.esda import plot_moran

w_queen_pubStats.transform='r'

LC_mi=esda.moran.Moran(LC_val,w_queen_pubStats)
print(f"LC mi: {LC_mi.I}; p-value p_sim: {LC_mi.p_sim}")

plot_moran(LC_mi)
```

    LC mi: 0.43157676011326235; p-value p_sim: 0.001
    




    (<Figure size 1000x400 with 2 Axes>,
     array([<AxesSubplot:title={'center':'Reference Distribution'}, xlabel='Moran I: 0.43', ylabel='Density'>,
            <AxesSubplot:title={'center':'Moran Scatterplot (0.43)'}, xlabel='Attribute', ylabel='Spatial Lag'>],
           dtype=object))




<img src="./imgs/2_7_3/output_72_2.png" height='auto' width='auto' title="caDesign">   



* 其它全局指数——Geary’s C和 Getis and Ord’s G

在 The contiguity ratio and statistical mapping<sup>[5]</sup>中提出的Geary’s C指数，公式为：$C= \frac{(n-1)}{2 \sum_i \sum_j w_{ij}  }  \frac{\sum_i \sum_j w_{ij} ( x_{i}-x_{j} )^{2}  }{\sum_i  ( x_{i}- \overline{x}  )^{2} } $，式中，$n$是观测值的数量，即单元数；$w_{ij}$为空间权重矩阵；$x_{i}$为第$i$个观测值；$\overline{x}$为样本均值。与Moran's I比较，两种测量方法都是将每个观察点的本地邻域内的关系与整个样本的关系进行比较，Moran's I在标准化数值上采用交叉乘积，而Geary's C在没有任何标准化的数值上采用差异。

Geary’s C计算结果为0.561，p-value为0.001，因此同Global Moran’s I一样，表明单元测量值之间具有集聚性。


```python
w_queen_pubStats.transform="b"
geary=esda.geary.Geary(LungCancer_gdf["Lung Cancer"],w_queen_pubStats)
print(f"Geary's C: {geary.C}; Pseudo p-value: {geary.p_sim}")
```

    Geary's C: 0.5618485483281203; Pseudo p-value: 0.001
    

在The analysis of spatial association by use of distance statistics<sup>[6]</sup>中提出的Getis and Ord’s G指数，是针对点基于距离的空间自相关统计，如果构建二元空间权重矩阵，也可用于多边形（polygon）数据计算，其公式为：$G(d)= \frac{ \sum_i \sum_j w_{ij}(d )x_{i} x_{j} }{\sum_i \sum_j x_{i} x_{j}} $，式中，$w_{ij}(d )$是对观测值（单元）之间关系分配的二元权重，并遵循距离缓冲带标准。该指数最初是作为集中度而不是空间自相关的方法提出，因此该指数非常适合于测量值（高或低）趋向于集聚的程度，为正空间相关统计值，因此不能发现负空间相关关系。

Getis & Ord G计算结果为0.221，p-value值为0.037，小于显著性水平0.05，表明单元之间具有一定的集聚性。


```python
pts=LungCancer_gdf.centroid
xys=pd.DataFrame({"X": pts.x, "Y": pts.y})
min_thr=LW.util.min_threshold_distance(xys)
print(f"min_thr: {min_thr}")
w_db=LW.DistanceBand.from_dataframe(LungCancer_gdf, min_thr)
gao=esda.getisord.G(LungCancer_gdf["Lung Cancer"], w_db)
print( "Getis & Ord G: %.3f; Pseudo p-value: %.3f" % (gao.G, gao.p_sim))
```

    min_thr: 7509.104795460789
    Getis & Ord G: 0.221; Pseudo p-value: 0.037
    

#### 3）局部空间自相关（Local Autocorrelation）——热点（Hot Spots）、冷点（Cold Spots）和空间异常值（Spatial Outliers）

全局空间自相关对研究区域提供了一个单一数值结果，并没有指出单元（高、低测量值）集聚的区域，或明确分散的情况，而局部空间自相关侧重于观察单元与邻近单元之间的关系，从而了解属性单元分布的空间结构。

首先建立测量值与空间滞后之间的散点图，并按照各自均值位置分为四象限图观察数值分布情况，指定四个象限分布：右上角为高-高（HH），高值集聚；左上角为低-高（LH），高值包含低值异常；左下方为低-低（LL），低值集聚；右下方为高-低（HL），低值包含高值异常。


```python
LC_val=LungCancer_gdf["Lung Cancer"]
LC_lag=LungCancer_gdf["lag"]
b,a=np.polyfit(LC_val,LC_lag,1)

f, ax=plt.subplots(1, figsize=(5, 5))
plt.plot(LC_val, LC_lag, '.', color='firebrick')

# dashed vert at mean of the price
plt.vlines(LC_val.mean(), LC_lag.min(), LC_lag.max(), linestyle='--')
# dashed horizontal at mean of lagged price 
plt.hlines(LC_lag.mean(), LC_val.min(), LC_val.max(), linestyle='--')

# red line of best fit using global I as slope
plt.plot(LC_val, a + b*LC_val, 'r')
plt.title('Moran Scatterplot')
plt.ylabel('Spatial Lag of Lung Cancer')
plt.xlabel('lung Cancer')

plt.text(80, 70, "HH", fontsize=20, c="r")
plt.text(80, 45, "HL", fontsize=20, c="r")
plt.text(20, 70, "LH", fontsize=20, c="r")
plt.text(20, 35, "LL", fontsize=20, c="r")

plt.show()
```


<img src="./imgs/2_7_3/output_78_0.png" height='auto' width='auto' title="caDesign">    


__局部 Moran’s I指数（局部莫兰指数）__

对于空间位置$i$单元的局部Moran’s I指数定义为：$LI= \frac{n( x_{i}- \overline{x} ) \sum_j w_{ij}(x_{j}- \overline{x})   )}{ \sum_i (x_{i}- \overline{x})^{2}  } $，局部 Moran’s I取值范围不限于[-1,1]。使用`PySAL`库提供的`esda.moran.Moran_Local`方法计算局部 Moran’s I指数，其属性`Is`为local Moran's I值，`q`则是划分为四象限后的分类，包括HH、LH、LL和HL。用`p_sim`查看各单元对应p-value值，计算满足显著性水平0.05的单元数量为28个，不满足的单元地图打印是标识为灰色。从计算结果来看，HH区域主要集中于芝加哥城南部，LL区间集中于城北部，这样的分布与城市用地类型存在关联，南部区域多工业用地，例如矿物提取、一般工业、制造加工、仓储配送和通用电气工业等，而北部工业用地较少，多植被和水体。


```python
w_queen_pubStats.transform='r'
LC_li=esda.moran.Moran_Local(LC_val,w_queen_pubStats)
print(LC_li.q) # values indicate quandrant location 1 HH,  2 LH,  3 LL,  4 HL
print(LC_li.Is)
print(f"p_value<0.05 num: {(LC_li.p_sim<0.05).sum()}")

LungCancer_gdf["li"]=LC_li.q
LungCancer_gdf["p_value_li"]=LC_li.p_sim
LungCancer_gdf["li_005"]=LungCancer_gdf.apply(lambda row:row.li if row.p_value_li<0.05 else 0,axis=1)
spot_labels=[ '0 ns', '1 hot spot', '2 doughnut', '3 cold spot', '4 diamond']
LungCancer_gdf['cl_li']=LungCancer_gdf.apply(lambda row:spot_labels[row.li_005],axis=1)
```

    [3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 4 2 3 3 3 3 3 3 4 1 1 4 4 3 3 3 3 1 1 1 1
     1 2 1 2 1 1 1 1 2 1 2 1 1 1 2 1 1 1 4 3 3 3 1 1 4 3 4 2 2 1 1 1 4 1 2 1 4
     2 3 3]
    [ 7.34620122e-01  7.35038893e-01  4.34357030e-02  3.77790044e-01
      4.08920807e-01  5.25466603e-01  7.12085185e-01  7.13351926e-01
      1.62275911e-01  2.62377369e-01 -1.97927882e-01  7.68303455e-01
      9.76827976e-01  6.78820959e-01  2.78568895e-01  5.69785716e-01
     -1.17269854e-01 -2.64366188e-01  2.22662497e-01  5.47724185e-01
      9.97779992e-01  7.72459773e-01  6.17866759e-02  4.02310865e-01
     -4.98836025e-01  4.43178899e-01  3.99005339e-02 -5.12948531e-01
     -1.75860468e-02  9.78415607e-01  5.16474374e-01  2.32087932e-01
      2.11416015e-02  9.25450975e-02  2.74082781e-01  1.22670357e-01
      2.10636271e+00  4.96968056e-01 -5.96459256e-02  1.51368595e+00
     -8.67719651e-01  9.53499561e-01  8.59421513e-01  8.90341145e-04
      2.31571055e-01 -1.01569221e-02  6.86771446e-01 -8.13951200e-02
      1.24236761e+00  2.36680617e+00  3.33414230e-01 -9.33124407e-02
      1.73765287e+00  2.36681139e+00  2.90939023e-01 -2.21655560e-01
      7.89000752e-02  8.48155414e-01  6.06819219e-01  4.74881975e-02
      2.54081230e-01 -1.67501098e-01  8.67244258e-02 -6.54438964e-03
     -5.93331085e-02 -4.82062395e-02  3.38731639e-01  2.16720170e+00
      1.52001725e+00 -1.39526956e-01  5.74769112e-01 -1.20575288e-01
      4.68874466e-01 -3.29572490e-02 -7.06073043e-02  1.18888522e-01
      4.17201629e-01]
    p_value<0.05 num: 26
    


```python
from matplotlib import colors
cmap=colors.ListedColormap([ 'lightgrey', 'red', 'lightblue', 'blue', 'pink'])
gdf_plot_annotate(LungCancer_gdf,"cl_li","index",annotate_fontsize=10,categorical=True,cmap=cmap)
```


<img src="./imgs/2_7_3/output_81_0.png" height='auto' width='auto' title="caDesign">    


打印局部 Moran’s I指数核密度估计图，从分布情况也可以判断出，高于0的部分相对于低于0的部分数量多，但HH和LL均存在。


```python
import seaborn 
ax=seaborn.kdeplot(LC_li.Is)
seaborn.rugplot(LC_li.Is, ax=ax);
```


<img src="./imgs/2_7_3/output_83_0.png" height='auto' width='auto' title="caDesign">    


### 2.7.3.3 地理轮廓 (Geosilhouettes)

聚类契合度的地理测量，用于测量观测值与特定聚类的拟合程度，在Geosilhouettes: Geographical measures of cluster fit<sup>[7]</sup>中提出有两个轮廓系数，分别为：

1. Path Silhouettes（路径轮廓，组内/组间相似度），表征聚类中联合地理和特征的相似度；
2. Boundary Silhouettes（边缘轮廓，组缘相似度）, 表征聚类中地理边界的定义程度。

上述轮廓指数已经纳入到了`PySAL`库的`edsa`模块中，可以调用计算。

#### 1）轮廓指数/系数（Silhouette Score）

在聚类问题中使用的轮廓系数，用来衡量观测结果与当前聚类分组的匹配程度，常用来评价聚类算法模型的效果。轮廓系数组成部分：

* $c$，为单元$i$所处的群组（簇）；

* $k$，为不包含单元$i$的群组；

* $d_{i}(c) $，为观测单元$i$与所处群组$c$之间的不相似度（反之相似度），等于观测单元测量值与同一群组中所有其它单元测量值之间的平均距离，为组内差异；

* $d_{i}(k) $，为观测单元$i$与不含$i$的群组$k$之间的不相似度（反之相似度），等于观测单元测量值与其它群组中所有单元测量值之间的平均距离，为组间差异。

根据聚类的要求，通常为“簇内差异小，而簇外差异大”，即$d_{i}(k) $不相似度大于$d_{i}(c) $不相似度，且越大越好。那么，如果单元$i$除了当前所在聚类群组，定义单元$i$可以选择的第2最佳群组/次优簇（不含单元$i$的簇），是与单元$i$最相似的群组，表述为$\widehat{ k_{i} }=k  |  _{k}^{min\{ d_{i}(k) \}}$，则轮廓系数可以定义为单元$i$和所在群组$c$，即单元$i$和第2最佳选择群组$ \widehat{k} $之间的异质性分数：$s_{i}= \frac{ d_{i}(c)- d_{i}( \widehat{k} )  }{max \big\{d_{i}(c), d_{i}( \widehat{k} ) \big\} }  $，当单元$i$与所在簇$c$比第2最佳簇$k$更接近时，值接近于1，表明当前聚类结果较好；而当单元$i$与$k$的相似度高于所在簇时，则$s_{i}$接近于-1。

评估聚类结果的轮廓系数可以使用`Sklearn`库提供的`silhouette_samples`方法。这里用`Sklearn`库提供的`KMeans`算法执行聚类，计算轮廓系数时，给出两种情形，一种是直接的聚类结果，这包括为同一簇而分散的单元；另一种是将同一簇按照地理空间位置进一步切分为单独的群组，通过定义函数`gdf_parent_child_dissolve()`实现切分。

下述代码执行了`KMeans`聚类，并打印聚类结果，这里配置参数`n_clusters`为5，即聚类5类。


```python
import warnings
warnings.filterwarnings('ignore')

from sklearn.cluster import KMeans

clusterer=KMeans(n_clusters=5)
LungCancer_gdf["cluster_labels"]=clusterer.fit_predict(LungCancer_gdf[['Lung Cancer']].values)

gdf_plot_annotate(LungCancer_gdf,"cluster_labels","cluster_labels",annotate_fontsize=10,categorical=True,cmap="Set3")
```


<img src="./imgs/2_7_3/output_85_0.png" height='auto' width='auto' title="caDesign">    


```python
def gdf_parent_child_dissolve(gdf,cluster_column,prefix="parent_child"):
    '''
    将聚类簇结果按照地理空间邻接性切分，即同一簇中，邻接的单元划分为1组，结果信息存储与列parent_child_idx或parent_child_int中

    Parameters
    ----------
    gdf : GeoDataFrame
        含有簇/分组标签列的数据.
    cluster_column : string
        簇/分组列名.
    prefix : string, optional
        列名前缀. The default is "parent_child".

    Returns
    -------
    overlay_gdf : GeoDataFrame
        重新切分的簇为一个polygon.
    explode_gdf : GeoDataFrame
        炸开重新切分的簇为多个单元.

    '''    
    from sklearn import preprocessing
    
    parent_child_idx="%s_idx"%prefix
    parent_child_int="%s_int"%prefix
    
    dissolve_gdf=gdf[['geometry',cluster_column]].dissolve(by=cluster_column)
    explode_gdf=dissolve_gdf.explode()
    explode_gdf[parent_child_idx]=explode_gdf.index    
    label_encoder=preprocessing.LabelEncoder()    
    print(explode_gdf[parent_child_idx].to_list())
    
    explode_gdf[parent_child_int]=label_encoder.fit_transform([str(i) for i in explode_gdf[parent_child_idx].to_list()])
    overlay_gdf=gpd.overlay(gdf,explode_gdf, how='intersection',make_valid=True)
    
    return overlay_gdf,explode_gdf    
```


```python
LungCancer_overlay_gdf,_=gdf_parent_child_dissolve(LungCancer_gdf,'cluster_labels')
LungCancer_overlay_gdf
```

    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (4, 0), (4, 1), (4, 2), (4, 3)]
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
      <th>li</th>
      <th>p_value_li</th>
      <th>li_005</th>
      <th>cl_li</th>
      <th>cluster_labels</th>
      <th>parent_child_idx</th>
      <th>parent_child_int</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.050000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.128</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((445691.750 4649781.565, 445688.751 4...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.300000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444126.361 4647333.168, 444126.692 4...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>North Center</td>
      <td>42.4</td>
      <td>39.312500</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444169.878 4642483.548, 444159.821 4...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7</td>
      <td>Lincoln Park</td>
      <td>40.0</td>
      <td>34.720000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.006</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((447619.016 4642483.907, 447618.814 4...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>14</td>
      <td>Albany Park</td>
      <td>36.9</td>
      <td>38.900000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.025</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((441669.914 4647075.747, 441672.157 4...</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>74</th>
      <td>65</td>
      <td>West Lawn</td>
      <td>36.7</td>
      <td>52.566667</td>
      <td>0_low</td>
      <td>2</td>
      <td>0.466</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 0)</td>
      <td>4</td>
      <td>POLYGON ((440745.000 4623085.184, 440729.460 4...</td>
    </tr>
    <tr>
      <th>75</th>
      <td>66</td>
      <td>Chicago Lawn</td>
      <td>42.9</td>
      <td>53.000000</td>
      <td>0_low</td>
      <td>2</td>
      <td>0.442</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 0)</td>
      <td>4</td>
      <td>POLYGON ((443592.071 4623091.859, 443588.072 4...</td>
    </tr>
    <tr>
      <th>76</th>
      <td>72</td>
      <td>Beverly</td>
      <td>47.9</td>
      <td>60.580000</td>
      <td>0_low</td>
      <td>2</td>
      <td>0.113</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 6)</td>
      <td>10</td>
      <td>POLYGON ((444300.698 4620227.572, 444349.926 4...</td>
    </tr>
    <tr>
      <th>77</th>
      <td>76</td>
      <td>O'Hare</td>
      <td>37.4</td>
      <td>49.200000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.421</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 3)</td>
      <td>7</td>
      <td>POLYGON ((422147.083 4649993.382, 422145.649 4...</td>
    </tr>
    <tr>
      <th>78</th>
      <td>76</td>
      <td>O'Hare</td>
      <td>37.4</td>
      <td>49.200000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.421</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 4)</td>
      <td>8</td>
      <td>POLYGON ((422686.092 4650740.455, 422686.092 4...</td>
    </tr>
  </tbody>
</table>
<p>79 rows × 13 columns</p>
</div>



按照地理空间位置邻接切分聚类簇，并以元组形式表述，例如(1,1)，（1,0）等，第1个数值为原始聚类标签，第2个数值为同一簇切分后的子类标签。


```python
gdf_plot_annotate(LungCancer_overlay_gdf,"parent_child_idx","parent_child_idx",annotate_fontsize=10,categorical=True,cmap="Set3",legend_bbox_to_anchor=(1.2, 1))
```


<img src="./imgs/2_7_3/output_89_0.png" height='auto' width='auto' title="caDesign">    


按照地理空间位置邻接切分聚类簇结果计算轮廓系数如下图，可以观察到，多数单元轮廓系数为负数（蓝色），有较强的异质性，相对组内相似度低而组间相似度高；个别单元为正数（红色），相对组内相似度高而组间相似度低。对聚类结果按照地理邻接切分后，使得各单元的轮廓系数变低，聚类效果不明显。


```python
from sklearn.metrics import silhouette_samples

LungCancer_overlay_gdf["silhouettes_pci"]=silhouette_samples(LungCancer_overlay_gdf[['Lung Cancer']].values, LungCancer_overlay_gdf.parent_child_int)
gdf_plot_annotate(LungCancer_overlay_gdf,"silhouettes_pci","parent_child_idx",annotate_fontsize=10,cmap="bwr")
```


<img src="./imgs/2_7_3/output_91_0.png" height='auto' width='auto' title="caDesign">    

统计结果直方图的轮廓系数数值分布，也表明了较多单元的轮廓系数值小于0，为负值。


```python
LungCancer_overlay_gdf["silhouettes_pci"].plot.hist();
```


<img src="./imgs/2_7_3/output_93_0.png" height='auto' width='auto' title="caDesign">    


对未切分，最初的聚类结果执行轮廓系数计算，则可以看到多数为红色，聚类结果较好，但也有少数单元轮廓系数低，组内相似度低而组件高。


```python
LungCancer_overlay_gdf["silhouettes_cluster"]=silhouette_samples(LungCancer_overlay_gdf[['Lung Cancer']].values, LungCancer_overlay_gdf.cluster_labels)
gdf_plot_annotate(LungCancer_overlay_gdf,"silhouettes_cluster","parent_child_idx",annotate_fontsize=10,cmap="bwr")
```


<img src="./imgs/2_7_3/output_95_0.png" height='auto' width='auto' title="caDesign">    



```python
LungCancer_overlay_gdf["silhouettes_cluster"].plot.hist();
```


<img src="./imgs/2_7_3/output_96_0.png" height='auto' width='auto' title="caDesign">    


#### 2）次优簇标签/最近邻吻合分布（Nearest Label ）

轮廓系数表述了单元组内和组间的相似度，并评估聚类的结果，但并未给出次优簇/第2最佳选择群组的标签，即$\widehat{ k_{i} }$，为位于$k$中单元$i$第2最佳选择群组。次优簇显示了目标单元和其它聚类簇之间潜在的关系，反映了如果单元$i$选择次优簇可能对聚类结果的影响，从而可以辅助构建一个衡量标准，明确当前$c$优于$\widehat{ k_{i} }$的程度。

`PySAL`提供了`esda.silhouettes.nearest_label`方法计算次优簇标签。


```python
import esda
import numpy as np

LungCancer_overlay_gdf["nearest_label"]=esda.silhouettes.nearest_label(LungCancer_overlay_gdf[['Lung Cancer']].values, LungCancer_overlay_gdf.parent_child_int.values)
LungCancer_overlay_gdf["nearest_culster"]=np.asarray(LungCancer_overlay_gdf.parent_child_idx)[LungCancer_overlay_gdf.nearest_label]
LungCancer_overlay_gdf[:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
      <th>li</th>
      <th>p_value_li</th>
      <th>li_005</th>
      <th>cl_li</th>
      <th>cluster_labels</th>
      <th>parent_child_idx</th>
      <th>parent_child_int</th>
      <th>geometry</th>
      <th>silhouettes_pci</th>
      <th>nearest_label</th>
      <th>nearest_culster</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.0500</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.128</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((445691.750 4649781.565, 445688.751 4...</td>
      <td>-0.845133</td>
      <td>7</td>
      <td>(1, 1)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.3000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444126.361 4647333.168, 444126.692 4...</td>
      <td>-0.274611</td>
      <td>9</td>
      <td>(1, 1)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>North Center</td>
      <td>42.4</td>
      <td>39.3125</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444169.878 4642483.548, 444159.821 4...</td>
      <td>-0.116809</td>
      <td>9</td>
      <td>(1, 1)</td>
    </tr>
  </tbody>
</table>
</div>



图中图例为次优簇$\widehat{ k_{i} }$，单元标签为当前簇$c$。


```python
gdf_plot_annotate(LungCancer_overlay_gdf,"nearest_culster","parent_child_idx",annotate_fontsize=10,categorical=True,cmap="Set3")
```


<img src="./imgs/2_7_3/output_100_0.png" height='auto' width='auto' title="caDesign">    


配置`keep_self`参数为`True`，则包含当前单元$i$所在的簇$c$，对于按地理空间邻接切分后的群组，因为轮廓系数多数降低为负值，则单元的次优簇通常不会选择当前簇$c$。


```python
LungCancer_overlay_gdf["nearest_label_self"]=esda.silhouettes.nearest_label(LungCancer_overlay_gdf[['Lung Cancer']].values, LungCancer_overlay_gdf.parent_child_int.values,keep_self=True)
LungCancer_overlay_gdf["nearest_culster_self"]=np.asarray(LungCancer_overlay_gdf.parent_child_idx)[LungCancer_overlay_gdf.nearest_label]
LungCancer_overlay_gdf[:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
      <th>li</th>
      <th>p_value_li</th>
      <th>li_005</th>
      <th>cl_li</th>
      <th>cluster_labels</th>
      <th>parent_child_idx</th>
      <th>parent_child_int</th>
      <th>geometry</th>
      <th>silhouettes_pci</th>
      <th>nearest_label</th>
      <th>nearest_culster</th>
      <th>nearest_label_self</th>
      <th>nearest_culster_self</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.0500</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.128</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((445691.750 4649781.565, 445688.751 4...</td>
      <td>-0.845133</td>
      <td>7</td>
      <td>(1, 1)</td>
      <td>7</td>
      <td>(1, 1)</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.3000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444126.361 4647333.168, 444126.692 4...</td>
      <td>-0.274611</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>9</td>
      <td>(1, 1)</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>North Center</td>
      <td>42.4</td>
      <td>39.3125</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>(1, 1)</td>
      <td>5</td>
      <td>POLYGON ((444169.878 4642483.548, 444159.821 4...</td>
      <td>-0.116809</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>9</td>
      <td>(1, 1)</td>
    </tr>
  </tbody>
</table>
</div>




```python
gdf_plot_annotate(LungCancer_overlay_gdf,"nearest_culster_self","parent_child_idx",annotate_fontsize=10,categorical=True,cmap="Set3")
```


<img src="./imgs/2_7_3/output_103_0.png" height='auto' width='auto' title="caDesign">    

#### 3）地理结构（Geographical Structure）

地理结构为所用空间权重单元间空间连接的图或网络形式，每个单元（或几何中心点）为一个观测点（单元），边代表观察点之间的地理联系。


```python
import libpysal.weights as LW
w_rook_LC=LW.Rook.from_dataframe(LungCancer_overlay_gdf)
```


```python
import matplotlib.pyplot as plt

f,ax=w_rook_LC.plot(LungCancer_overlay_gdf,edge_kws=dict(linewidth=.5), node_kws=dict(s=0))
LungCancer_overlay_gdf.plot('parent_child_idx', ax=ax, alpha=.6)
plt.show()
```


<img src="./imgs/2_7_3/output_106_0.png" height='auto' width='auto' title="caDesign">    


#### 4）Path Silhouettes （路径轮廓）

路径轮廓将两个观测单元之间的空间权重（地理位置关系）和属性特征相似度（异同）结合起来，表达为：$d(i,j)= d_{f}(i,j) \times  d_{s}(i,j)$，式中，$d_{f}(i,j)$为观测单元$i$和$j$间的属性特征相似度；$d_{s}(i,j)$为空间地理位置差异。$d_{s}(i,j)$通常由测量单元间的欧式距离衡量，但有时单元$i$通过与$j$之间的其它单元（假设有单元$l$，$m$）连接到$j$，路径$i  \rightarrow  l \rightarrow m \rightarrow j$为最短路径，因此公式修正为： $d(i,j)= d_{f}(i,l) \times  d_{s}(i,l)+ d_{f}(l,m) \times  d_{s}(l,m)+ d_{f}(m,j) \times  d_{s}(m,j)$。

`PySAL`库提供了`esda.silhouettes.path_silhouette`方法计算路径轮廓。


```python
w_queen_overlay=LW.Queen.from_dataframe(LungCancer_overlay_gdf)

LungCancer_overlay_gdf["path_silhouettes"]=esda.silhouettes.path_silhouette(LungCancer_overlay_gdf[['Lung Cancer']].values, LungCancer_overlay_gdf.parent_child_int.values,w_queen_overlay)
LungCancer_overlay_gdf[:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
      <th>li</th>
      <th>p_value_li</th>
      <th>li_005</th>
      <th>cl_li</th>
      <th>cluster_labels</th>
      <th>...</th>
      <th>parent_child_int</th>
      <th>geometry</th>
      <th>silhouettes_pci</th>
      <th>nearest_label</th>
      <th>nearest_culster</th>
      <th>nearest_label_self</th>
      <th>nearest_culster_self</th>
      <th>path_silhouettes</th>
      <th>centroid</th>
      <th>dbscan_cluster</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.0500</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.128</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>...</td>
      <td>5</td>
      <td>POLYGON ((445691.750 4649781.565, 445688.751 4...</td>
      <td>-0.845133</td>
      <td>7</td>
      <td>(1, 1)</td>
      <td>7</td>
      <td>(1, 1)</td>
      <td>-0.600258</td>
      <td>POINT (444506.602 4651061.851)</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.3000</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>...</td>
      <td>5</td>
      <td>POLYGON ((444126.361 4647333.168, 444126.692 4...</td>
      <td>-0.274611</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>0.186486</td>
      <td>POINT (443039.322 4647248.058)</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5</td>
      <td>North Center</td>
      <td>42.4</td>
      <td>39.3125</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>...</td>
      <td>5</td>
      <td>POLYGON ((444169.878 4642483.548, 444159.821 4...</td>
      <td>-0.116809</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>0.300000</td>
      <td>POINT (443320.001 4644205.717)</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 21 columns</p>
</div>



从打印地图中可以得知，对于依据地理邻接切分后的簇，与前文计算的轮廓系数比较，在考虑了地理空间（空间权重）因素后，多数单元的路径轮廓为正值，表明具有较好的聚类结果；其中也包括少数蓝色单元，为组内相似度低，而组间相似度高，可以考虑选择次优簇。


```python
_=gdf_plot_annotate(LungCancer_overlay_gdf,"path_silhouettes","parent_child_idx",annotate_fontsize=10,cmap="bwr")
```


<img src="./imgs/2_7_3/output_110_0.png" height='auto' width='auto' title="caDesign">    


```python
LungCancer_overlay_gdf["path_silhouettes"].plot.hist();
```


<img src="./imgs/2_7_3/output_111_0.png" height='auto' width='auto' title="caDesign">    

为与`KMeans`聚类结果地理邻接切分的路径轮廓比较，下述实验则使用`DBSCAN`，不考虑测量（属性）值前提下，执行空间距离聚类将邻近的单元组合为簇，并计算该聚类结果的路径轮廓，可以发现多数单元为蓝色，表明仅考虑空间距离而忽略单元特征值的聚类，在考虑特征值计算路径轮廓，则路径轮廓值往往小于0，不能反映单元的特征属性值的聚类情况。


```python
from sklearn.cluster import DBSCAN

LungCancer_overlay_gdf['centroid']=LungCancer_overlay_gdf.geometry.apply(lambda row:row.centroid)
centroids=LungCancer_overlay_gdf['centroid'].to_list()
centroids_coordinates=np.array([[p.x,p.y] for p in centroids])
clustering_dbscan=DBSCAN(eps=2500, min_samples=2).fit(centroids_coordinates)
LungCancer_overlay_gdf["dbscan_cluster"]=clustering_dbscan.labels_
LungCancer_overlay_dbscan_gdf,_=gdf_parent_child_dissolve(LungCancer_overlay_gdf,'dbscan_cluster',prefix="dbscan_parent_child")
LungCancer_overlay_dbscan_gdf[:3]
```

    [(-1, 0), (-1, 1), (-1, 2), (-1, 3), (0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0), (10, 1)]
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Community Area</th>
      <th>Community Area Name</th>
      <th>Lung Cancer</th>
      <th>lag</th>
      <th>binary_median</th>
      <th>li</th>
      <th>p_value_li</th>
      <th>li_005</th>
      <th>cl_li</th>
      <th>cluster_labels</th>
      <th>...</th>
      <th>nearest_label</th>
      <th>nearest_culster</th>
      <th>nearest_label_self</th>
      <th>nearest_culster_self</th>
      <th>path_silhouettes</th>
      <th>centroid</th>
      <th>dbscan_cluster</th>
      <th>dbscan_parent_child_idx</th>
      <th>dbscan_parent_child_int</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Rogers Park</td>
      <td>36.7</td>
      <td>38.05</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.128</td>
      <td>0</td>
      <td>0 ns</td>
      <td>1</td>
      <td>...</td>
      <td>7</td>
      <td>(1, 1)</td>
      <td>7</td>
      <td>(1, 1)</td>
      <td>-0.600258</td>
      <td>POINT (444506.602 4651061.851)</td>
      <td>0</td>
      <td>(0, 0)</td>
      <td>4</td>
      <td>POLYGON ((445688.751 4649783.865, 445686.199 4...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>West Ridge</td>
      <td>36.0</td>
      <td>38.65</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.052</td>
      <td>0</td>
      <td>0 ns</td>
      <td>3</td>
      <td>...</td>
      <td>27</td>
      <td>(2, 5)</td>
      <td>27</td>
      <td>(2, 5)</td>
      <td>0.469072</td>
      <td>POINT (442441.974 4650184.259)</td>
      <td>0</td>
      <td>(0, 0)</td>
      <td>4</td>
      <td>POLYGON ((443319.829 4652121.144, 443322.049 4...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4</td>
      <td>Lincoln Square</td>
      <td>43.1</td>
      <td>39.30</td>
      <td>0_low</td>
      <td>3</td>
      <td>0.018</td>
      <td>3</td>
      <td>3 cold spot</td>
      <td>1</td>
      <td>...</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>9</td>
      <td>(1, 1)</td>
      <td>0.186486</td>
      <td>POINT (443039.322 4647248.058)</td>
      <td>1</td>
      <td>(1, 0)</td>
      <td>5</td>
      <td>POLYGON ((444126.692 4647293.701, 444127.074 4...</td>
    </tr>
  </tbody>
</table>
<p>3 rows × 23 columns</p>
</div>




```python
_=gdf_plot_annotate(LungCancer_overlay_dbscan_gdf,"dbscan_parent_child_idx","dbscan_parent_child_idx",annotate_fontsize=10,categorical=True,cmap="Set3")
```


<img src="./imgs/2_7_3/output_114_0.png" height='auto' width='auto' title="caDesign">    


```python
LungCancer_overlay_dbscan_gdf["path_silhouettes_dbscan"]=esda.silhouettes.path_silhouette(LungCancer_overlay_dbscan_gdf[['Lung Cancer']].values, LungCancer_overlay_dbscan_gdf.dbscan_parent_child_int.values,w_rook_LC)
```


```python
gdf_plot_annotate(LungCancer_overlay_dbscan_gdf,"path_silhouettes_dbscan","dbscan_parent_child_idx",annotate_fontsize=10,cmap="bwr")
```


<img src="./imgs/2_7_3/output_116_0.png" height='auto' width='auto' title="caDesign">    


计算路径轮廓时，如果配置参数`return_nbfc`为`True`，则会返回次优簇。

> 注意，在按地理邻近分解簇时，将位于簇1的单元75也分解为了小片区域，其中新产生的77和78单元并不与其它单元邻接，即不共边，也无点连通，因此计算Queen空间权重时，值为空值，如果为空值，在返回次优簇时`esda.silhouettes.path_silhouette`方法会提示错误，因此先移除了这两个无空间权重值的单元。


```python
LungCancer_overlay_dropped_gdf=LungCancer_overlay_gdf.drop(index=[77,78])
w_queen_overlay_dropped=LW.Queen.from_dataframe(LungCancer_overlay_dropped_gdf)

LungCancer_overlay_dropped_gdf["path_silhouette"], LungCancer_overlay_dropped_gdf["next_best_path"]=esda.silhouettes.path_silhouette(LungCancer_overlay_dropped_gdf[['Lung Cancer']].values, LungCancer_overlay_dropped_gdf.parent_child_int.values,w_queen_overlay_dropped,return_nbfc=True)
```

图中图例为当前簇标签，单元标注为当前簇→次优簇。


```python
LungCancer_overlay_dropped_gdf["pci_nbp"]=LungCancer_overlay_dropped_gdf.apply(lambda row:f"{row.parent_child_int}→{row.next_best_path}",axis=1)

gdf_plot_annotate(LungCancer_overlay_dropped_gdf,"parent_child_int","pci_nbp",annotate_fontsize=8,categorical=True,cmap="Set3",legend_bbox_to_anchor=(1.15, 1))
```


<img src="./imgs/2_7_3/output_120_0.png" height='auto' width='auto' title="caDesign">    


#### 5）Boundary Silhouettes（边缘轮廓） 

目标单元路径轮廓指示的次优簇可能并不在当前簇邻近的簇中，如果考虑地理空间邻接的特性，则分析可能并不现实，因此边缘轮廓则考虑了这一需求，将注意力限制在邻近的簇中，从而将目标单元归于次优簇时，也不会在地理空间上被孤立。当一个单元位于邻近簇$\widehat{k} $时，较之位于当前簇$c$时，具有更好的相似度，则边缘轮廓系数值为负值；反之为正值。从下述打印的地图中可以观察到，大部分单元都具有较高的组内相似度和较低的组间相似度；而蓝色小于0的单元则可以考虑归于邻接的次优簇。


```python
LungCancer_overlay_dropped_gdf["boundary_silhouette"]=esda.silhouettes.boundary_silhouette(LungCancer_overlay_dropped_gdf[['Lung Cancer']].values, LungCancer_overlay_dropped_gdf.parent_child_int.values,w_queen_overlay_dropped)
gdf_plot_annotate(LungCancer_overlay_dropped_gdf,"boundary_silhouette","parent_child_idx",cmap='bwr',annotate_fontsize=8)
```


<img src="./imgs/2_7_3/output_122_0.png" height='auto' width='auto' title="caDesign">    

---

注释（Notes）：

① 芝加哥公共健康数据，该数据集包含了按芝加哥社区区域划分的27个具有公共卫生意义的指标（<https://data.cityofchicago.org/Health-Human-Services/Public-Health-Statistics-Selected-public-health-in/iqnk-2tcu>）。

② Chicago Data Portal，为芝加哥城开放数据门户，可免费下载数据用于相关分析，其中许多数据集每天至少更新一次或数次（<https://data.cityofchicago.org/>）。

③ PySAL，支持空间数据科学计算的开源项目（<https://pysal.org/>）。

参考文献（References）:

[1] Sergio J. Rey, Dani Arribas-Bel, Levi J. Wolf. Geographic Data Science with Python[M]. licensed under a [Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.](https://creativecommons.org/licenses/by-nc-nd/4.0/), 2020.

[2] [PySAL Notebooks Book](http://pysal.org/notebooks/intro.html)，http://pysal.org/notebooks/intro.html.

[3] Tobler W. A computer movie simulating urban growth in the Detroit region[J]. Economic Geography, 1970, 46(Supplement): 234–240.

[4] Kemp, Karen. Encyclopedia of Geographic Information Science, SAGE, 2008, pp 146–147.

[5] Robert C Geary. The contiguity ratio and statistical mapping. The incorporated statistician, 5(3):115–146, 1954.

[6] Arthur Getis and JK Ord. The analysis of spatial association by use of distance statistics. Geographical Analysis, 24(3):189–206, 1992.

[7] Wolf, L. J., Knaap, E., & Rey, S. (2021). Geosilhouettes: Geographical measures of cluster fit. Environment and Planning B: Urban Analytics and City Science, 48(3), 521–539. https://doi.org/10.1177/2399808319875752
