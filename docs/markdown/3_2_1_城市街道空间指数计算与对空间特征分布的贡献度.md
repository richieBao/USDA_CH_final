> Created on Wed Apr 28 14:46:58 2021 @author: Richie Bao-caDesign设计(cadesign.cn)__+updated on Tue Jan 18 20:45:54 2022 by Richie Bao 

# 3.2.1 城市街道空间指数计算与对空间特征分布的贡献度

## A. 建立研究代码项目

1. 建立本地仓库与GitHub仓库

2. 建立数据库

使用[pgAdmin](https://www.pgadmin.org/)创建本地关系数据库`PAPER_Urban_Street_Space_Metrics`，并在`Query Editor`中执行`CREATE EXTENSION postgis;`，使能够存储具有坐标系统的地理几何对象。随书写研究代码进展读写数据库。

3. 建立配置文件

使用[YAML](https://en.wikipedia.org/wiki/YAML)文件格式，书写配置文件。随书写研究代码进展完善配置内容。

4. 项目文件结构

5. requirements文件


## B. 专项研究与代码实现

### B.1 背景


### B.2 研究方法与结果

#### B.2.1 研究区域

选取西安市（34° 15'N，108°56'E）碑林区、莲湖区、雁塔区、新城区、未央区和灞桥区等6个行政区域为区域尺度研究对象。选取荐福寺路、朱雀大街北段、友谊西路、长安北路、南大街、西大街、回民路、西华门大街等8段部分道路，及南门盘道和钟楼环道连续的部分区段作为街道尺度的研究对象。

> 在数据选择上，实际不需要划分为区域及连续街道两种形式，可以直接下载每8m(百度地图应用限制)为一个采样点的全城全景图数据。百度街道全景图及Google街道全景图下载需要支付数据费用，因此在资金支付和研究内容上做了平衡。

#### B.2.2 数据

| 序号  | 数据名称  | 数据来源  | 说明  |大小|数据类型|
|---|---|---|---|---|---|
| 1  | 道路  | 来源于中国专业IT社区CSDN (Chinese Software Developer Network)的开放数据  | 由道路提取采样点，用于全景图检索下载  |/ |.shp，.kml|
| 2  |  行政区域 | CSDN  | 用于数据裁切至研究区域  |/ |.shp|
| 3  |  全景静态图 | 百度地图应用  | 用于像素级图像语义分割，计算城市街道空间指数  |区域：13,359张； 街道：599张|.jpg|
|  4 |  POI | 百度地图应用  | 计算业态分布指数  |街道：13,732个 |.csv或.json|

##### B.2.2.1 数据获取及预处理

###### 1) 原数据转换为GeoDataFrame数据格式，并写入数据库，用于后续分析，及QGIS地图的建立

处理数据包括：道路（.shp格式和.kml格式两种）、行政区划（.shp格式）

`database.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 10:45:39 2021
updated on Wed Jan 19 09:25:11 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def gpd2postSQL(gdf,table_name,**kwargs):  
    '''
    function - 将GeoDataFrame格式数据写入PostgreSQL数据库
    
    Paras:
        gdf - GeoDataFrame格式数据，含geometry字段（几何对象，点、线和面，数据值对应定义的坐标系统）
        table_name - 写入数据库中的表名
        **kwargs - 连接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）
    '''    
    from sqlalchemy import create_engine
    
    engine=create_engine("postgres://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    gdf.to_postgis(table_name, con=engine, if_exists='replace', index=False,)  
    print("_"*50)
    print('The GeoDataFrame has been written to the PostgreSQL database.The table name is {}.'.format(table_name))

def postSQL2gpd(table_name,geom_col='geometry',**kwargs):    
    '''
    function - 读取PostgreSQL数据库中的表为GeoDataFrame格式数据
    
    Paras:
        table_name - 待读取数据库中的表名
        geom_col='geometry' - 几何对象，常规默认字段为'geometry'
        **kwargs - 连接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）
    '''
    from sqlalchemy import create_engine
    import geopandas as gpd   
    
    engine=create_engine("postgres://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    gdf=gpd.read_postgis(table_name, con=engine,geom_col=geom_col)
    print("_"*50)
    print('The data has been read from PostgreSQL database. The table name is {}.'.format(table_name))    
    return gdf  

def shp2gdf(fn,epsg=None,boundary=None,encoding='utf-8'):    
    '''
    function - 转换.shp地理信息数据为GeoDataFrame(geopandas)数据格式，可以配置投影
    
    Paras:
        fn - .shp文件路径
        epsg - 配置投影，默认为None
        boundary - 配置裁切边界，默认为None
        encoding - 配置编码，默认为'utf-8'
    '''
    import geopandas as gpd
    
    shp_gdf=gpd.read_file(fn,encoding=encoding)
    print('original data info:{}'.format(shp_gdf.shape))
    shp_gdf.dropna(how='all',axis=1,inplace=True)
    print('dropna-how=all,result:{}'.format(shp_gdf.shape))
    shp_gdf.dropna(inplace=True)
    print('dropna-several rows,result:{}'.format(shp_gdf.shape))
    # print(shp_gdf)
    if epsg is not None:
        shp_gdf_proj=shp_gdf.to_crs(epsg=epsg)
    if boundary:
        shp_gdf_proj['mask']=shp_gdf_proj.geometry.apply(lambda row:row.within(boundary))
        shp_gdf_proj.query('mask',inplace=True)        
    
    return shp_gdf_proj

def kml2gdf_folder(fn,epsg=None,boundary=None): 
    '''
    转换.kml（Google Eath）为GeoDataFrame格式

    Parameters
    ----------
    fn : .kml
        在Google Earth中绘制的格式.
    epsg : epsg编号, optional
        地理投影信息.
    boundary : GeoDataFrame, optional
        裁切边界. The default is None.

    Returns
    -------
    kml_gdf_proj : GeoDataFrame
        转换.kml为GeoDataFrame.

    '''
    import pandas as pd
    import geopandas as gpd
    import fiona,io
    from tqdm import tqdm

    # Enable fiona driver
    gpd.io.file.fiona.drvsupport.supported_drivers['KML'] = 'rw'
    kml_gdf=gpd.GeoDataFrame()
    for layer in tqdm(fiona.listlayers(fn)):
        # print("_"*50)
        # print(layer)
        src=fiona.open(fn, layer=layer)
        meta = src.meta
        meta['driver'] = 'KML'        
        with io.BytesIO() as buffer:
            with fiona.open(buffer, 'w', **meta) as dst:            
                for i, feature in enumerate(src):
                    # print(feature)
                    # print("_"*50)
                    # print(feature['geometry']['coordinates'])
                    if len(feature['geometry']['coordinates'][0]) > 1:
                        # print(feature['geometry']['coordinates'])
                        
                        dst.write(feature)
                        # break
            buffer.seek(0)
            one_layer=gpd.read_file(buffer,driver='KML')
            # print(one_layer)
            one_layer['group']=layer
            kml_gdf=kml_gdf.append(one_layer,ignore_index=True)

    if epsg is not None:
        kml_gdf_proj=kml_gdf.to_crs(epsg=epsg)

    if boundary:
        kml_gdf_proj['mask']=kml_gdf_proj.geometry.apply(lambda row:row.within(boundary))
        kml_gdf_proj.query('mask',inplace=True)        

    return kml_gdf_proj    


def cfg_load_yaml(ymlf_fp):
    '''
    读取 yaml 格式的配置文件

    Parameters
    ----------
    ymlf_fp : string
        配置文件路径.

    Returns
    -------
    cfg : yaml-dict
        读取到python中的配置信息.
    '''
    import yaml
    with open (ymlf_fp,'r') as ymlfile:
        cfg=yaml.safe_load(ymlfile)   
    return cfg

if __name__=="__main__":
    cfg=cfg_load_yaml('config.yml')
    print(cfg["data_path"]) 
    #help(cfg_load_yaml)
    
    #1.转换.shp格式的行政区划region_merge（合并的）为GeoDataFrame格式，并写入数据库
    region_merge=shp2gdf(cfg['data_path']['region_merge'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8')
    #region_merge.plot() 
    gpd2postSQL(region_merge,
                table_name='region_merge',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #2.配置行政区划的英文名称（拆分的），并写入数据库
    region=shp2gdf(cfg['data_path']['region'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8') 
    #region.plot()
    region_name_mapping={'bqq':'Baoqiao District','wyq':'Weiyang District','lhq':'Lianhu District','ytq':'Yanta District','xcq':'Xincheng District','blq':'Beilin District'}    
    region['name_en']=region['PYNAME'].map(region_name_mapping)
    gpd2postSQL(region,
                table_name='region',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #3.提取研究区域内的道路，并写入数据库
    road=shp2gdf(cfg["data_path"]['road'],epsg=cfg['xian_epsg'],boundary=region_merge.geometry[0],encoding='GBK')
    road.plot()
    gpd2postSQL(road,
                table_name='road',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      
    
    #4.转换.kml街道路径(合并的)为GeoDataFrame格式，并写入数据库
    tour_line=kml2gdf_folder(cfg['data_path']['tour_line'],epsg=cfg['xian_epsg'],boundary=None) 
    tour_line.plot()
    gpd2postSQL(tour_line,
                table_name='tour_line',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      
    
    #5.转换.kml街道路径（拆分的）为GeoDataFrame格式，并写入数据库
    tour_line_seg=shp2gdf(cfg['data_path']['tour_line_seg'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8')
    # tour_line_seg.plot()
    gpd2postSQL(tour_line_seg,
                table_name='tour_line_seg',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      

```

###### 2)  全景静态图检索下载

基本流程：根据道路线，给定距离获取采样点；->给定采样点从百度地图应用中检索全景图下载；->验证下载图像的有效性，并复制有效的图像至新建的文件夹下。

`baidu_streetview_crawler.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 14:46:58 2021
updated on Wed Jan 19 16:00:24 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def roads_pts4bsv(roads_gdf,distance=10):
    '''
    给定GeoDataFrame的道路中心线，和采样距离，返回采样点

    Parameters
    ----------
    roads_gdf : GeoDataFrame
        GeoDataFrame的道路中心线.
    distance : numerical value, optional
        采样距离. The default is 10.

    Returns
    -------
    GeoDataFrame
        采样点.

    '''
    from tqdm import tqdm
    import numpy as np
    from shapely.geometry import MultiPoint
    import pyproj
    from shapely.ops import transform
    import geopandas as gpd
    
    tqdm.pandas()    
    def line_pts(line):
        dists=np.arange(0,line.length,distance)
        pts=MultiPoint([line.interpolate(d,normalized=False) for d in dists])
        return pts      
        
    roads_gdf['pts']=roads_gdf.geometry.progress_apply(line_pts)
    
    wgs84=pyproj.CRS('EPSG:4326')
    utm=roads_gdf.crs #pyproj.CRS(roads_gpd.crs.srs)
    project=pyproj.Transformer.from_crs(utm, wgs84, always_xy=True).transform
    roads_gdf['pts_wgs84']=roads_gdf.pts.progress_apply(lambda row:transform(project,row))    
    
    pts_gdf=gpd.GeoDataFrame(roads_gdf[['Name','Uid']],geometry=roads_gdf.pts_wgs84.to_list(),crs=wgs84) #roads_gdf.drop(['geometry'],axis=1)    
    return pts_gdf

   
def baidu_steetview_crawler(pts_gdf,save_path,ak,save_path_BSV_retrival_info):
    '''
    从百度地图应用中，根据采样点检索下载全景图
    
    Parameters
    ----------
    pts_gdf : GeoDataFrame
        采样点.
    save_path : string
        全景图的保存路径.
    ak : string
        访问应用的AK值，在百度应用中注册申请.
    save_path_BSV_retrival_info : dict
        pickle方式保存下载信息，包括pt_fns-以路径为键，全景图下载地址列表为值；coords-以路径为键，采样点坐标列表为值；
                                 downloadError_idx-错误索引列表.

    Returns
    -------
    coords : dict
        以路径为键，值为采样点坐标列表.
    pts_num : int
        下载全景图的数量.
        
    '''
    import urllib,os
    from tqdm import tqdm
    import pickle
    
    downloadError_idx=[]
    coords={}
    pts_num={}    
    pt_fns={}
    for idx,row in pts_gdf.iterrows():
        pt_coords=[(pt.x,pt.y) for pt in row.geometry]
        coords[row.Name]=pt_coords
        pts_num[row.Name]=len(pt_coords)
    print("\npts_num={}".format(sum(pts_num.values())))
    
    urlRoot=r"http://api.map.baidu.com/panorama/v2?"
    query_dic={
        'width':'1024',
        'height':'512', 
        'fov':'360',
        'heading':'0',
        'pitch':'0',
        'coordtype':'wgs84ll',
        'ak':ak,
    }   
    # tt=0
    for k,v in tqdm(coords.items()):
        pt_fn=[]
        for i,coord in enumerate(v):
            pic_fn=os.path.join(save_path,"{}_{}.jpg".format(k,i))                        
            if not os.path.exists(pic_fn):
                #update query arguments
                query_dic.update({
                                  'location':str(coord[0])+','+str(coord[1]),
                                 })         
                url=urlRoot+urllib.parse.urlencode(query_dic)
                try:
                    data=urllib.request.urlopen(url)
                    pt_fn.append(pic_fn)
                    with open(pic_fn,'wb') as fp:
                        fp.write(data.read())           
                except:
                    downloadError_idx.append((k,i))
                    print('download_error:{},{}'.format(k,i))
            else:
                print("file existed.")
                
        pt_fns[k]=pt_fn
        # if tt==2:break
        # tt+=1
        
    with open(save_path_BSV_retrival_info["pt_fns"],'wb') as f:
        pickle.dump(pt_fns,f)
    with open(save_path_BSV_retrival_info["coords"],'wb') as f:
        pickle.dump(coords,f)       
    with open(save_path_BSV_retrival_info["downloadError_idx"],'wb') as f:
        pickle.dump(downloadError_idx,f)      
            
    return coords,pts_num

def img_valid(img_fns,save_path_img_valid):
    '''
    验证图像是否有效，即是否可以被打开

    Parameters
    ----------
    img_fns : dict
        图像路径字典.
    save_path_img_valid : dict
        保存路径字典.

    Returns
    -------
    img_val : dict
        返回有效图像字典.

    '''
    from tqdm import tqdm
    import pickle
    from PIL import Image
    
    img_val={}
    img_inval=[]
    for k,v in tqdm(img_fns.items()):
        fns=[]
        for fn in v:
            try:
                im=Image.open(fn)
                fns.append(fn)
            except:
                img_inval.append(fn)        
        img_val[k]=fns
            
    with open(save_path_img_valid["img_val"],'wb') as f:
        pickle.dump(img_val,f)        
    with open(save_path_img_valid["img_inval"],'wb') as f:
        pickle.dump(img_inval,f)                 
    return img_val

def img_valid_copy_folder(imgs_root,panoramic_imgs_valid_root):
    '''
    功能基本同img_valid(img_fns,save_path_img_valid)函数。除了验证图像是否有效，同时将其复制到新建的文件夹下

    Parameters
    ----------
    imgs_root : string
        图像根目录.
    panoramic_imgs_valid_root : string
        新建文件夹，复制有效图像至该文件夹.

    Returns
    -------
    None.

    '''
    from tqdm import tqdm
    import pickle
    import glob,os 
    from PIL import Image
    import shutil
    
    img_fns=glob.glob(os.path.join(imgs_root,'*.jpg'))
    # print(img_fns)  
    img_val=[]
    img_inval=[]
    for fn in tqdm(img_fns):
        try:
            im=Image.open(fn)
            img_val.append(fn)
        except:
            img_inval.append(fn)    
    # print(img_val)
    for fn in tqdm(img_val):
        shutil.copy(fn,panoramic_imgs_valid_root)   
        
def roads_pts4bsv_tourLine(roads_gdf,distance=10):
    '''
    由道路GeoDataFrame数据，提取给定距离的采样点

    Parameters
    ----------
    roads_gdf : GeoDataFrame
        道路线.
    distance : numericle value, optional
        指定采样距离. The default is 10.

    Returns
    -------
    GeoDataFrame
        采样点.

    '''
    from tqdm import tqdm
    import numpy as np
    from shapely.geometry import MultiPoint
    import pyproj
    from shapely.ops import transform
    import geopandas as gpd
    
    tqdm.pandas()    
    def line_pts(line):
        dists=np.arange(0,line.length,distance)
        pts=MultiPoint([line.interpolate(d,normalized=False) for d in dists])
        return pts      
        
    roads_gdf['pts']=roads_gdf.geometry.progress_apply(line_pts)
    
    wgs84=pyproj.CRS('EPSG:4326')
    utm=roads_gdf.crs #pyproj.CRS(roads_gpd.crs.srs)
    project=pyproj.Transformer.from_crs(utm, wgs84, always_xy=True).transform
    roads_gdf['pts_wgs84']=roads_gdf.pts.progress_apply(lambda row:transform(project,row))    
    
    pts_gdf=gpd.GeoDataFrame(roads_gdf[['Name','group']],geometry=roads_gdf.pts_wgs84.to_list(),crs=wgs84) #roads_gdf.drop(['geometry'],axis=1)    
    return pts_gdf

def pts_number_check(pts):
    '''
    查看采样点，打印数量

    Parameters
    ----------
    pts : GeoDataFrame
        输入点数据.

    Returns
    -------
    None.

    '''
    
    downloadError_idx=[]
    coords={}
    pts_num={}    
    pt_fns={}
    for idx,row in pts.iterrows():
        pt_coords=[(pt.x,pt.y) for pt in row.geometry]
        coords[row.Name]=pt_coords
        pts_num[row.Name]=len(pt_coords)
    # print(coords)
    print("\npts_num={}".format(sum(pts_num.values())))

if __name__=="__main__":
    from database import postSQL2gpd,gpd2postSQL,cfg_load_yaml   
    import pickle
    
    cfg=cfg_load_yaml('config.yml')
    
    #1.读取道路，提取采样点后写入数据库
    roads=postSQL2gpd(table_name='road',
                geom_col=cfg["postgreSQL"]["geom_col"],
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])     
    pts_gdf=roads_pts4bsv(roads,cfg['streetview']['distance_region'])
    gpd2postSQL(pts_gdf,
                table_name='pts_region',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #2.从百度地图应用中下载全景静态图
    coords,pts_num=baidu_steetview_crawler(pts_gdf,
                                           cfg["streetview"]["save_path_BSV_region"],
                                           cfg["streetview"]["ak"],
                                           cfg["streetview"]["save_path_BSV_retrival_info"])
    #3.验证下载的全景图是否有效，并将有效全景图复制到新建文件夹中
    with open(cfg["streetview"]["save_path_BSV_retrival_info"]["pt_fns"],'rb') as f:
        pt_fns=pickle.load(f)    
    img_val=img_valid(pt_fns,cfg["streetview"]["save_path_img_valid"])  #14973 /13359  14973-13359=1614
 
    img_valid_copy_folder(cfg["streetview"]["save_path_BSV_region"],cfg["streetview"]["panoramic_imgs_valid_root"])
    
    #4. 过去街道采样点，从百度地图应用检索街道全景图下载，并验证有效性，将有效图像保存到新建文件夹下。代码同上（区域检索）
    tour_line=postSQL2gpd(table_name='tour_line',
                geom_col=cfg["postgreSQL"]["geom_col"],
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
    pts_tourLine_gdf=roads_pts4bsv_tourLine(tour_line,cfg['streetview']['distance_street']) 
    pts_number_check(pts_tourLine_gdf)
    gpd2postSQL(pts_tourLine_gdf,
                table_name='pts_tourline',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
    coords_street,pts_num_street=baidu_steetview_crawler(pts_tourLine_gdf,
                                                        cfg["streetview"]["save_path_BSV_street"],
                                                        cfg["streetview"]["ak"],
                                                        cfg["streetview"]["save_path_BSV_retrival_info_street"])     
    img_valid_copy_folder(cfg["streetview"]["save_path_BSV_street"],cfg["streetview"]["panoramic_imgs_valid_root_street"])

```

###### 3)  全景图像素级语义分割（Pixel-wise semantic segmentation）

应用[PASS（ERF-PSPNet）深度学习模型](https://github.com/elnino9ykl/PASS)实现全景图像素级语义分割。可以从给定的链接处下载计算。

###### 4)  百度POI数据检索下载，转换为GeoDataFrame后保存到数据库

POI数据检索方法可以参考‘数据POI与描述性统计和正态分布’章节部分。新定义的转换方法追加到`database.py`中。

`database.py`（追加）
```python

def filePath_extraction(dirpath,fileType):  
    '''
    funciton  -以所在文件夹路径为键，值为包含该文件夹下所有文件名的列表。文件类型可以自行定义 
    
    Paras:
        dirpath - 根目录，存储所有待读取的文件
        fileType - 待读取文件的类型
    '''
    import os
    filePath_Info={}
    i=0
    for dirpath,dirNames,fileNames in os.walk(dirpath): #os.walk()遍历目录，使用help(os.walk)查看返回值解释
       i+=1
       if fileNames: #仅当文件夹中有文件时才提取
           tempList=[f for f in fileNames if f.split('.')[-1] in fileType]
           if tempList: #剔除文件名列表为空的情况，即文件夹下存在不为指定文件类型的文件时，上一步列表会返回空列表[]
               filePath_Info.setdefault(dirpath,tempList)
    return filePath_Info

def csv2df(poi_fn_csv):
    '''
    转换.csv格式的POI数据为pandas的DataFrame

    Parameters
    ----------
    poi_fn_csv : string
        单个.csv文件路径.

    Returns
    -------
    poi_df : DataFrame
        POI点数据.

    '''
    import pandas as pd
    from benedict import benedict #benedict库是dict的子类，支持键列表（keylist）/键路径（keypath），应用该库的flatten方法展平嵌套的字典，准备用于DataFrame数据结构
    import csv

    n=0
    with open(poi_fn_csv, newline='',encoding='utf-8') as csvfile:
        poi_reader=csv.reader(csvfile)
        poi_dict={}    
        poiExceptions_dict={}
        for row in poi_reader:    
            if row:
                try:
                    row_benedict=benedict(eval(row[0])) #用eval方法，将字符串字典"{}"转换为字典{}
                    flatten_dict=row_benedict.flatten(separator='_') #展平嵌套字典
                    poi_dict[n]=flatten_dict
                except:                    
                    print("incorrect format of data_row number:%s"%n)                    
                    poiExceptions_dict[n]=row
            n+=1
            #if n==5:break #因为循环次数比较多，在调试代码时，可以设置停止的条件，节省时间与方便数据查看
    poi_df=pd.concat([pd.DataFrame(poi_dict[d_k].values(),index=poi_dict[d_k].keys(),columns=[d_k]).T for d_k in poi_dict.keys()], sort=True,axis=0)
    # print("_"*50)
    for col in poi_df.columns:
        try:
            poi_df[col]=pd.to_numeric(poi_df[col])
        except:
            pass
            #print("%s data type is not converted..."%(col))
    print("_"*50)
    print(".csv to DataFrame is completed!")
    #print(poi_df.head()) #查看最终DataFrame格式下POI数据
    #print(poi_df.dtypes) #查看数据类型
    return poi_df

def poi_csv2GeoDF_batch(poi_paths,fields_extraction,save_path):
    '''
    .csv格式POI数据批量转换为GeoDataFrame，需要调用转换.csv格式的POI数据为pandas的DataFrame函数csv2df(poi_fn_csv)'

    Parameters
    ----------
    poi_paths : dict
        poi路径字典.
    fields_extraction : list
        待提取的字段列表.
    save_path : dict
        GeoJSON、Shapefile和pickle三种数据格式各自的保存路径.

    Returns
    -------
    poiAll_gpd : GeoDataFrame
        poi的GeoDataFrame数据格式.

    '''
    import os,pathlib
    import pandas as pd
    import geopandas as gpd
    from shapely.geometry import Point
    #循环读取与转换poi的.csv文件为pandas的DataFrame数据格式
    poi_df_dic={}
    i=0
    for key in poi_paths:
        for val in poi_paths[key]:
            poi_csvPath=os.path.join(key,val)
            poi_df=csv2df(poi_csvPath) #注释掉了了csv2df()函数内部的print("%s data type is not converted..."%(col))语句，以pass替代，减少提示内容，避免干扰
            print(val)
            poi_df_path=pathlib.Path(val)
            poi_df_dic[poi_df_path.stem]=poi_df
            
            #if i==2:break
            i+=1
    poi_df_concat=pd.concat(poi_df_dic.values(),keys=poi_df_dic.keys(),sort=True)
    #print(poi_df_concat.loc[['poi_0_delicacy'],:]) #提取index为 'poi_0_delicacy'的行，验证结果
    poi_fieldsExtraction=poi_df_concat.loc[:,fields_extraction]
    poi_geoDF=poi_fieldsExtraction.copy(deep=True)
    poi_geoDF['geometry']=poi_geoDF.apply(lambda row:Point(row.location_lng,row.location_lat),axis=1) 
    # crs_4326=CRS('epsg:4326') #配置坐标系统，参考：https://spatialreference.org/     
    crs_4326='epsg:4326'
    poiAll_gpd=gpd.GeoDataFrame(poi_geoDF,crs=crs_4326)     
    
    poiAll_gpd.to_pickle(save_path['pkl'])
    # poiAll_gpd.to_file(save_path['geojson'],driver='GeoJSON')
    
    poiAll_gpd2shp=poiAll_gpd.reset_index() #不指定level参数，例如Level=0，会把多重索引中的所有索引转换为列
    poiAll_gpd2shp.rename(columns={
        'location_lat':'lat', 'location_lng':'lng',
        'detail_info_tag':'tag','detail_info_overall_rating':'rating', 'detail_info_price':'price'},inplace=True)
    poiAll_gpd2shp.to_file(save_path['shp'],encoding='utf-8')
        
    return poiAll_gpd

if __name__=="__main__":
    #6.转换POI(.csv,.json)为GeoDataFrame格式，并写入数据库
    fileType=["csv"]
    poi_paths=filePath_extraction(cfg["POI"]["poi_path"],fileType)
    #分别存储为GeoJSON、Shapefile和pickle三种数据格式
    poi_gpd=poi_csv2GeoDF_batch(poi_paths,cfg["POI"]["fields_extraction"],cfg["POI"]["save_path_POI"])
    gpd2postSQL(poi_gpd,
                table_name='poi',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
```

至此数据获取及预处理部分基本完成。后续的分析可以直接从本地关系数据库`PAPER_Urban_Street_Space_Metrics`中读取数据，以及写入分析过程中新产生的数据。

##### B.2.2.2 QGIS建立地图

除了在python中从数据库中读入数据，打印查看外，最终出图推荐用QGIS通过`PostGIS`配置连接到数据库，读取和查看数据。可以用`Project->New print layout`建立布局，打印输出。

__Fig. 区域尺度全景图采样点__  

<a href=""><img src="./imgs/3_2_1_01.png" height="auto" width="auto" title="caDesign"></a>

__Fig. 街道尺度区段与POI数据__  

<a href=""><img src="./imgs/3_2_1_02.png" height="auto" width=800 title="caDesign"></a>

##### B.2.2.3 全景与语义分割图的投影变换

在城市街道空间的组成结构分析过程中，需要根据不同的分析内容对数据进行预先处理满足分析的要求和改善计算的准确性。极坐标格式全景图(小行星视角360度全景)用于天空相关指数的计算，避免等量矩形投影图未闭合的天空形状影响；等量矩形投影图和极坐标格式全景图因为投影变形，对象像素所占比例不能最大限度的反应实际视觉下对象比例关系。而立方体型全景格式由前，后，左，右，上，下6张透视图组成，用于语义分割对象所占像素百分比的统计相对合理；球面全景，可以反应对象在实际空间中的位置关系，用于语义分割对象空间位置变化的分析。

变换等量矩形投影图到极坐标格式全景图和立方体型全景格式计算量较大（13,359张全景图），因此调用`from multiprocessing import Pool`模块实现多进程计算，以节约大量计算时间。因为调用多进程，避免出错，通常需要从一个.py文件调用另一个.py文件的函数，因此通常多进程部分包括两个.py文件，例如从等量矩形投影图到立方体型全景格式，包括`equi2cube.py`和`equi2cube_pool.py`两个文件。其中前者为多进程处理文件，后者为包含具体功能计算函数的文件。

这个过程需要计算图像部分（保存为.jpg格式）和对应的类标部分（label，保存为.pkl格式），文件保存路径相对较多，需要在配置文件`config.yml`中清晰配置。

###### 1)  等量矩形投影图到立方体型全景格式

`equi2cube_pool.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Sun May  9 12:44:29 2021
Updated on Thu Jan 20 10:14:26 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
ref:https://github.com/bingsyslab/360projection
"""
import sys
sys.path.append('..')

label_color={
    0:(117,115,102), #"pole",
    1:(212,209,156),#"slight",
    2:(224,9,9),#"bboard",
    3:(227,195,66),#"tlight",
    4:(137,147,169),#"car",
    5:(53,67,98),#"truck",
    6:(185,181,51),#"bicycle",
    7:(238,108,91),#"motor",
    8:(247,5,5),#"bus",
    9:(127,154,82),#"tsignf",
    10:(193,209,167),#"tsignb",
    11:(82,83,76),#"road",
    12:(141,142,133),#"sidewalk",
    13:(208,212,188),#"curbcut",
    14:(98,133,145),#"crosspln",
    15:(194,183,61),#"bikelane",
    16:(141,139,115),#"curb",
    17:(157,186,133),#"fence",
    18:(114,92,127),#"wall",
    19:(78,61,76),#"building",
    20:(100,56,67),#"person",
    21:(240,116,148),#"rider",
    22:(32,181,191),#"sky",
    23:(55,204,26),#"vege",
    24:(84,97,82),#"terrain",
    25:(231,24,126),#"markings",
    26:(141,173,166),#"crosszeb",
    27:(0,0,0),#"Nan",                
    }    
    
def deg2rad(d):
    import numpy as np
    return float(d) * np.pi / 180

def rotate_image(old_image,channel_num=1):
    import cv2
    if channel_num==3:
        (old_height, old_width, _) = old_image.shape
    elif channel_num==1:
        (old_height, old_width, ) = old_image.shape
    M = cv2.getRotationMatrix2D(((old_width - 1) / 2., (old_height - 1) / 2.), 270, 1)
    rotated = cv2.warpAffine(old_image, M, (old_width, old_height))
    return rotated

def xrotation(th):
    import numpy as np
    c = np.cos(th)
    s = np.sin(th)
    return np.array([[1, 0, 0], [0, c, s], [0, -s, c]])

def yrotation(th):
    import numpy as np
    c = np.cos(th)
    s = np.sin(th)
    return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])

def render_image_np(theta0, phi0, fov_h, fov_v, width, img,channel_num=1):
    """
    theta0 is pitch
    phi0 is yaw
    render view at (pitch, yaw) with fov_h by fov_v
    width is the number of horizontal pixels in the view
    """
    import numpy as np
    m = np.dot(yrotation(phi0), xrotation(theta0))
    
    if channel_num==3:
        (base_height, base_width, _) = img.shape
    elif channel_num==1:
        (base_height, base_width, ) = img.shape    
    
    height = int(width * np.tan(fov_v / 2) / np.tan(fov_h / 2))
    
    if channel_num==3:
        new_img = np.zeros((height, width, 3), np.uint8)
    elif channel_num==1:
        new_img = np.zeros((height, width, ), np.uint8)    
      
    DI = np.ones((height * width, 3), np.int)
    trans = np.array([[2.*np.tan(fov_h / 2) / float(width), 0., -np.tan(fov_h / 2)],
                      [0., -2.*np.tan(fov_v / 2) / float(height), np.tan(fov_v / 2)]])
    
    xx, yy = np.meshgrid(np.arange(width), np.arange(height))
    
    DI[:, 0] = xx.reshape(height * width)
    DI[:, 1] = yy.reshape(height * width)
    
    v = np.ones((height * width, 3), np.float)
    
    v[:, :2] = np.dot(DI, trans.T)
    v = np.dot(v, m.T)
    
    diag = np.sqrt(v[:, 2] ** 2 + v[:, 0] ** 2)
    theta = np.pi / 2 - np.arctan2(v[:, 1], diag)
    phi = np.arctan2(v[:, 0], v[:, 2]) + np.pi
    
    ey = np.rint(theta * base_height / np.pi).astype(np.int)
    ex = np.rint(phi * base_width / (2 * np.pi)).astype(np.int)
    
    ex[ex >= base_width] = base_width - 1
    ey[ey >= base_height] = base_height - 1  
    
    # print(ey.shape,ex.shape)
    new_img[DI[:, 1], DI[:, 0]] = img[ey, ex]
    return new_img
  
def equi_to_cube(face_size, img,channel_num=1):        
      """
      given an equirectangular spherical image, project it onto standard cube
      """
      import numpy as np
      cube_img_h = face_size * 3
      cube_img_w = face_size * 2
      if channel_num==3:
          cube_img = np.zeros((cube_img_h, cube_img_w, 3), np.uint8)
      elif channel_num==1:
         cube_img = np.zeros((cube_img_h, cube_img_w, ), np.uint8)
    
      ii = render_image_np(np.pi / 2, np.pi, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_top.jpg', ii)

      cube_img[:int(cube_img_h / 3), int(cube_img_w / 2):] = ii.copy()
    
      ii = render_image_np(0, 0, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_front.jpg', ii)
    
      cube_img[int(cube_img_h / 3):int(cube_img_h * 2 / 3), :int(cube_img_w / 2)] = rotate_image(ii,channel_num=channel_num).copy()
    
      ii = render_image_np(0, np.pi / 2, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_right.jpg', ii)
    
      cube_img[int(cube_img_h * 2 / 3):, :int(cube_img_w / 2)] = rotate_image(ii,channel_num=channel_num).copy()
    
      ii = render_image_np(0, np.pi, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_back.jpg', ii)
    
      cube_img[int(cube_img_h / 3):int(cube_img_h * 2 / 3), int(cube_img_w / 2):] = ii.copy()
    
      ii = render_image_np(0, np.pi * 3 / 2, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_left.jpg', ii)
    
      cube_img[:int(cube_img_h / 3), :int(cube_img_w / 2)] = rotate_image(ii,channel_num=channel_num).copy()
    
      ii = render_image_np(-np.pi / 2, np.pi, \
              np.pi / 2, np.pi / 2, \
              face_size, img,channel_num=channel_num)
    #   cv2.imwrite('g_bottom.jpg', ii)
    
      cube_img[int(cube_img_h * 2 / 3):, int(cube_img_w / 2):] = ii.copy()
    
    #   cv2.imwrite('g_cube.jpg', cube_img)
      return cube_img

def labels_equi2cube(label_seg_path,face_size,save_path_dict):
    '''
    转换等量矩形全景图的语义分割图为立方体型全景格式

    Parameters
    ----------
    label_seg_path : string
        语义分割图label 索引图，.pkl文件.
    face_size : numerical val
        立方体型全景格式单元大小.
    save_path_dict : dict
        保存立方体型label（label_seg_cube_root），分类图像（img_seg_cube_root）和重新映射颜色值的图像（img_seg_redefined_color_root）根目录.

    Returns
    -------
    None.

    '''
    import glob,os,pickle
    from tqdm import tqdm
    from pathlib import Path
    import numpy as np
    from PIL import Image
    
    label_seg_cube_root=save_path_dict["label_seg_cube_root"]
    img_seg_redefined_color_root=save_path_dict["img_seg_redefined_color_root"]
    img_seg_cube_root=save_path_dict["img_seg_cube_root"]    
    
    label_seg_fns=glob.glob(os.path.join(label_seg_path,'*.pkl'))
    #print(label_seg_fns)
    for label_seg_fn in tqdm(label_seg_fns):
        with open(label_seg_fn,'rb') as f:
            label_seg=pickle.load(f) #.cpu().detach().numpy() 
        fn_stem=Path(label_seg_fn).stem
        fn_key,fn_idx=fn_stem.split("_")
        
        label_seg_cube=equi_to_cube(face_size,label_seg)
        with open(os.path.join(label_seg_cube_root,'{}.pkl'.format(fn_stem)),'wb') as f:
            pickle.dump(label_seg_cube,f)        
        
        label_seg=label_seg.cpu().detach().numpy()
        label_seg_panorama=np.array([label_color[v] for v in label_seg.flatten()]).reshape((label_seg.shape[0],label_seg.shape[1],3))
        label_panorama=Image.fromarray(label_seg_panorama.astype(np.uint8))   
        label_panorama.save(os.path.join(img_seg_redefined_color_root,'{}.jpg'.format(fn_stem)))        
        
        label_seg_cube_color=np.array([label_color[v] for v in label_seg_cube.flatten()]).reshape((label_seg_cube.shape[0],label_seg_cube.shape[1],3))
        label_cube=Image.fromarray(label_seg_cube_color.astype(np.uint8))  
        label_cube=label_cube.rotate(90, expand=1)
        label_cube.save(os.path.join(img_seg_cube_root,'{}.jpg'.format(fn_stem)))        
        break
    
def labels_equi2cube_pool(label_seg_fn,args): 
    '''
    函数labels_equi2cube(label_seg_path,face_size,save_path_dict)的多线程版

    Parameters
    ----------
    label_seg_fn : string
        单个语义分割图label 索引图，.pkl文件.
    args : list
        包含参数：save_path_dict,face_size.

    Returns
    -------
    None.

    '''
    import glob,os,pickle
    from tqdm import tqdm
    from pathlib import Path
    import numpy as np
    from PIL import Image
    
    save_path_dict,face_size=args
    label_seg_cube_root=save_path_dict["label_seg_cube_root"]
    img_seg_redefined_color_root=save_path_dict["img_seg_redefined_color_root"]
    img_seg_cube_root=save_path_dict["img_seg_cube_root"]      
    
    with open(label_seg_fn,'rb') as f:
        label_seg=pickle.load(f)#.cpu().detach().numpy() 
    fn_stem=Path(label_seg_fn).stem
    fn_key,fn_idx=fn_stem.split("_")
    
    label_seg_cube=equi_to_cube(face_size,label_seg)
    with open(os.path.join(label_seg_cube_root,'{}.pkl'.format(fn_stem)),'wb') as f: #'./processed data/label_seg_cube'
        pickle.dump(label_seg_cube,f)        
    
    label_seg=label_seg.cpu().detach().numpy()
    label_seg_panorama=np.array([label_color[v] for v in label_seg.flatten()]).reshape((label_seg.shape[0],label_seg.shape[1],3))
    label_panorama=Image.fromarray(label_seg_panorama.astype(np.uint8))   
    label_panorama.save(os.path.join(img_seg_redefined_color_root,'{}.jpg'.format(fn_stem)))  #'./processed data/img_seg_redefined_color'      
    
    label_seg_cube_color=np.array([label_color[v] for v in label_seg_cube.flatten()]).reshape((label_seg_cube.shape[0],label_seg_cube.shape[1],3))
    label_cube=Image.fromarray(label_seg_cube_color.astype(np.uint8))  
    label_cube=label_cube.rotate(90, expand=1)
    label_cube.save(os.path.join(img_seg_cube_root,'{}.jpg'.format(fn_stem)))    #'./processed data/img_seg_cube'

def imgs__equi2cube(pano_path,face_size,save_path):
    '''
    转换等量矩形全景图为立方体型全景格式

    Parameters
    ----------
    pano_path : string
        等量矩形全景图根路径.
    face_size : numerical val
        立方体型全景格式单元大小.
    save_path : string
        立方体型全景格式保存路径.

    Returns
    -------
    None.

    '''
    import glob,os
    from tqdm import tqdm
    from pathlib import Path
    import cv2
    import numpy as np
    
    pano_path_fns=glob.glob(os.path.join(pano_path,'*.jpg'))
    # print(pano_path_fns)
    for fn in tqdm(pano_path_fns):
        fn_stem=Path(fn).stem
        fn_key,fn_idx=fn_stem.split("_")
        
        img=cv2.imread(fn)
        cube_img=equi_to_cube(face_size,img,channel_num=3)
        cube_img=np.rot90(cube_img)
        cv2.imwrite(os.path.join(save_path,'{}.jpg'.format(fn_stem)), cube_img) 
        break

if __name__ == '__main__':    
    import os
    from database import cfg_load_yaml
    cfg=cfg_load_yaml('../config.yml')
    face_size=cfg["equi2cube"]["face_size"]
    
    parent_path=os.path.dirname(os.getcwd())
    label_seg_path=os.path.join(parent_path,cfg["panaSeg"]["label_seg_path"])    
    save_path_dict={"label_seg_cube_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["label_seg_cube_root"]),
                    "img_seg_redefined_color_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_redefined_color_root"]),
                    "img_seg_cube_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_cube_root"])}
    labels_equi2cube(label_seg_path,face_size,save_path_dict)
 
    #pano_path=os.path.join(parent_path,cfg["panaSeg"]["pano_path"])
    #imgs__equi2cube(pano_path,face_size,os.path.join(parent_path,cfg["equi2cube"]["region"]["img_cube"]))
```

`equi2cube.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Sun May  9 19:14:17 2021
Updated on Thu Jan 20 13:56:01 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""


if __name__ == '__main__':  
    import glob,os
    from multiprocessing import Pool
    from tqdm import tqdm
    from equi2cube_pool import labels_equi2cube_pool
    from functools import partial
    
    import sys
    sys.path.append('..')
    from database import cfg_load_yaml
    cfg=cfg_load_yaml('../config.yml')
    
    parent_path=os.path.dirname(os.getcwd())
    label_seg_path=os.path.join(parent_path,cfg["panaSeg"]["label_seg_path"]) 
    label_seg_fns=glob.glob(os.path.join(label_seg_path,'*.pkl'))
    
    save_path_dict={"label_seg_cube_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["label_seg_cube_root"]),
                    "img_seg_redefined_color_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_redefined_color_root"]),
                    "img_seg_cube_root":os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_cube_root"])}    
    face_size=cfg["equi2cube"]["face_size"]
    args=partial(labels_equi2cube_pool, args=[save_path_dict,face_size])
    with Pool(8) as p:
        p.map(args, tqdm(label_seg_fns))      
```

> 街道部分计算同上述区域计算。

###### 2)  等量矩形投影图到极坐标格式全景图

`equi2polar_pool.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Sat May  1 20:38:23 2021
updated on Thu Jan 20 09:23:48 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
ref: http://www.richwareham.com/little-planet-projection/
"""
import sys
sys.path.append('..')

def output_coord_to_r_theta(coords):
    """Convert co-ordinates in the output image to r, theta co-ordinates.
    The r co-ordinate is scaled to range from from 0 to 1. The theta
    co-ordinate is scaled to range from 0 to 1.
    
    A Nx2 array is returned with r being the first column and theta being
    the second.
    """
    import numpy as np
    # Calculate x- and y-co-ordinate offsets from the centre:
    x_offset = coords[:,0] - (output_shape[1]/2)
    y_offset = coords[:,1] - (output_shape[0]/2)
    
    # Calculate r and theta in pixels and radians:
    r = np.sqrt(x_offset ** 2 + y_offset ** 2)
    theta = np.arctan2(y_offset, x_offset)
    
    # The maximum value r can take is the diagonal corner:
    max_x_offset, max_y_offset = output_shape[1]/2, output_shape[0]/2
    max_r = np.sqrt(max_x_offset ** 2 + max_y_offset ** 2)
    
    # Scale r to lie between 0 and 1
    r = r / max_r
    
    # arctan2 returns an angle in radians between -pi and +pi. Re-scale
    # it to lie between 0 and 1
    theta = (theta + np.pi) / (2*np.pi)
    
    # Stack r and theta together into one array. Note that r and theta are initially
    # 1-d or "1xN" arrays and so we vertically stack them and then transpose
    # to get the desired output.
    return np.vstack((r, theta)).T

def r_theta_to_input_coords(r_theta):
    """Convert a Nx2 array of r, theta co-ordinates into the corresponding
    co-ordinates in the input image.
    
    Return a Nx2 array of input image co-ordinates.
    
    """
    import numpy as np
    # Extract r and theta from input
    r, theta = r_theta[:,0], r_theta[:,1]
    
    # Theta wraps at the side of the image. That is to say that theta=1.1
    # is equivalent to theta=0.1 => just extract the fractional part of
    # theta
    theta = theta - np.floor(theta)
    
    # Calculate the maximum x- and y-co-ordinates
    max_x, max_y = input_shape[1]-1, input_shape[0]-1
    
    # Calculate x co-ordinates from theta
    xs = theta * max_x
    
    # Calculate y co-ordinates from r noting that r=0 means maximum y
    # and r=1 means minimum y
    ys = (1-r) * max_y
    
    # Return the x- and y-co-ordinates stacked into a single Nx2 array
    return np.hstack((xs, ys))

def little_planet_1(coords):
    """Chain our two mapping functions together."""
    r_theta = output_coord_to_r_theta(coords)
    input_coords = r_theta_to_input_coords(r_theta)
    return input_coords

def little_planet_2(coords):
    """Chain our two mapping functions together with modified r."""
    import numpy as np
    r_theta = output_coord_to_r_theta(coords)
    # Take square root of r
    r_theta[:,0] = np.sqrt(r_theta[:,0])
    input_coords = r_theta_to_input_coords(r_theta)
    return input_coords

def little_planet_3(coords):
    """Chain our two mapping functions together with modified r
    and shifted theta.
    
    """
    import numpy as np
    r_theta = output_coord_to_r_theta(coords)
    
    # Take square root of r
    r_theta[:,0] = np.sqrt(r_theta[:,0])
    
    # Shift theta
    r_theta[:,1] += 0.1
    
    input_coords = r_theta_to_input_coords(r_theta)
    return input_coords

def little_planet_4(coords):
    """Chain our two mapping functions together with modified and
    scaled r and shifted theta.
    
    """
    import numpy as np
    r_theta = output_coord_to_r_theta(coords)
    
    # Scale r down a little to zoom in
    r_theta[:,0] *= 0.75
    
    # Take square root of r
    r_theta[:,0] = np.sqrt(r_theta[:,0])
    
    # Shift theta
    r_theta[:,1] += 0.1
    
    input_coords = r_theta_to_input_coords(r_theta)
    return input_coords

def equi2polar(imgs_root,output_shape,little_planet,save_path):
    '''
    转换等量矩形全景图为极坐标格式全景图

    Parameters
    ----------
    imgs_root : string
        全景图根目录.
    output_shape : tuple
        极坐标格式全景图的图像大小（width,height）.
    little_planet : function
        极坐标格式全景图可选类型：little_planet_1，little_planet_2，little_planet_3，little_planet_4.
    save_path : string
        图像保存根目录.

    Returns
    -------
    None.

    '''
    import glob,os 
    from tqdm import tqdm
    from PIL import Image,ImageOps
    import numpy as np
    from skimage.transform import warp
    from PIL import Image
    from pathlib import Path
    
    img_fns=glob.glob(os.path.join(imgs_root,'*.jpg'))
    for fn in tqdm(img_fns):        
        pano=np.asarray(ImageOps.flip(Image.open(fn)))
        global input_shape
        input_shape=pano.shape      
        pano_warp=warp(pano, little_planet, output_shape=output_shape)
        # The image is a NxMx3 array of floating point values from 0 to 1. Convert this to
        # bytes from 0 to 255 for saving the image:
        pano_warp=(255 * pano_warp).astype(np.uint8)       
        im=Image.fromarray(pano_warp)
        # im_save_fn=os.path.join('./processed data/polar_img','{}.jpg'.format(Path(fn).stem))
        im_save_fn=os.path.join(save_path,'{}.jpg'.format(Path(fn).stem))
        im.save(im_save_fn)     
        break  

def equi2polar_pool(fn,args): 
    '''
    equi2polar(imgs_root,output_shape,little_planet,save_path)函数的多进程版。转换等量矩形全景图为极坐标格式全景图

    Parameters
    ----------
    fn : string
        单个图像路径.
    args : list
        包括：output_shape,little_planet,save_path 等3个参数.

    Returns
    -------
    None.

    '''
    import glob,os 
    from tqdm import tqdm
    from PIL import Image,ImageOps
    import numpy as np
    from skimage.transform import warp
    from PIL import Image
    from pathlib import Path   
    
    global output_shape
    output_shape,little_planet,save_path=args
       
    pano=np.asarray(ImageOps.flip(Image.open(fn)))
    global input_shape
    input_shape = pano.shape     
    pano_warp=warp(pano, eval(little_planet), output_shape=output_shape)
    pano_warp = (255 * pano_warp).astype(np.uint8)    
    im=Image.fromarray(pano_warp)
    im_save_fn=os.path.join(save_path,'{}.jpg'.format(Path(fn).stem))
    im.save(im_save_fn)   

if __name__=="__main__":
    import os
    from database import cfg_load_yaml
    cfg=cfg_load_yaml('../config.yml')  
    
    parent_path=os.path.dirname(os.getcwd())
    imgs_root=os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_redefined_color_root"]) 
    output_shape=eval(cfg["equi2polar"]["output_shape"])
    little_planet=eval(cfg["equi2polar"]["little_planet"])
    save_path=os.path.join(parent_path,cfg["equi2polar"]["region"]["polar_seg_root"])
    equi2polar(imgs_root,output_shape,little_planet,save_path)      
```

`equi2polar.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Sun May  2 10:11:12 2021
Updated on Thu Jan 20 16:13:33 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""


if __name__ == '__main__':  
    import glob,os
    from multiprocessing import Pool
    from tqdm import tqdm
    from equi2polar_pool import equi2polar_pool
    from functools import partial
    
    import sys
    sys.path.append('..')
    from database import cfg_load_yaml
    cfg=cfg_load_yaml('../config.yml')
    
    parent_path=os.path.dirname(os.getcwd())
    imgs_root=os.path.join(parent_path,cfg["equi2cube"]["region"]["img_seg_redefined_color_root"]) 
    img_fns=glob.glob(os.path.join(imgs_root,'*.jpg'))
    
    output_shape=eval(cfg["equi2polar"]["output_shape"])
    little_planet=cfg["equi2polar"]["little_planet"]
    save_path=os.path.join(parent_path,cfg["equi2polar"]["region"]["polar_seg_root"]) 
    args=partial(equi2polar_pool, args=[output_shape,little_planet,save_path])
    
    with Pool(8) as p:
        p.map(args, tqdm(img_fns))  

```

> 全景图转极坐标格式全景图，同语义分割全景图转极坐标格式的方法，通过替换`imgs_root`图像位置根目录，和重新定义`save_path`输出目录实现。街道部分同。

###### 3) 等量矩形投影图到球面全景

使用[mayavi](https://docs.enthought.com/mayavi/mayavi/)三维科学数据可视化绘图工具实现。`mlab.show()`方法可以交互显示三维图像，也可以通过`mlab.savefig`方法保存图像。

`spherical_panorama.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 29 21:45:02 2021
Updated on Thu Jan 20 18:24:48 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def sphere_panorama_label(image_file):
    '''
    转换等量矩形投影图到球面全景

    Parameters
    ----------
    image_file : string
        单张全景图文件路径.

    Returns
    -------
    None.

    '''
    import math
    import numpy as np
    from mayavi import mlab
    from tvtk.api import tvtk # python wrappers for the C++ vtk ecosystem
    
    # create a figure window (and scene)
    fig = mlab.figure(size=(600, 600),bgcolor=(1, 1, 1))

    # load and map the texture
    img = tvtk.JPEGReader()
    img.file_name = image_file
    texture = tvtk.Texture(input_connection=img.output_port, interpolate=1)
    # print(texture)
    # (interpolate for a less raster appearance when zoomed in)

    # use a TexturedSphereSource, a.k.a. getting our hands dirty
    R = 50
    Nrad = 180

    # create the sphere source with a given radius and angular resolution
    sphere = tvtk.TexturedSphereSource(radius=R, theta_resolution=Nrad,phi_resolution=Nrad)

    # assemble rest of the pipeline, assign texture    
    sphere_mapper = tvtk.PolyDataMapper(input_connection=sphere.output_port)
    sphere_actor = tvtk.Actor(mapper=sphere_mapper, texture=texture)
    fig.scene.add_actor(sphere_actor)
    
    # Plot the equator and the tropiques
    theta_equator=np.linspace(0, 2 * np.pi, 100)
    veiw_scope_dic={}
    for i,angle in enumerate([-math.radians(70), 0, math.radians(50)]):
        x_equator=R * np.cos(theta_equator) * np.cos(angle)
        y_equator=R * np.sin(theta_equator) * np.cos(angle)
        z_equator=R * np.ones_like(theta_equator) * np.sin(angle)    
        mlab.plot3d(x_equator, y_equator, z_equator, color=(0, 0, 0),opacity=0.6, tube_radius=None)  
        veiw_scope_dic[i]=[x_equator,y_equator,z_equator]    
    
    str_info={0:'lower limit of visual filed:-70',1:'Standard line of sight:0',2:'Upper limit of visual filed:+50'}
    for k,v in str_info.items():
        mlab.text(veiw_scope_dic[k][0][0], veiw_scope_dic[k][1][0], v, z=veiw_scope_dic[k][2][0],width=0.029 * len(v), name=v,color=(0,0,0))
    
    vertical_label_radians=np.linspace(0, np.pi,14)
    vertical_label_degree=["{:.2f}".format(90-math.degrees(radi)) for radi in vertical_label_radians]
    phi_label=0
    for idx in range(len(vertical_label_radians)):
        theta_labe=vertical_label_radians[idx]
        x_label=R * np.sin(theta_labe) * np.cos(phi_label)
        y_label=R * np.sin(theta_labe) * np.sin(phi_label)
        z_label=R * np.cos(theta_labe)         
        mlab.points3d(x_label, y_label, z_label,scale_factor=1,color=(0,0,0))
        label=vertical_label_degree[idx]
        mlab.text(x_label, y_label, label, z=z_label,width=0.028 * len(label), name=label,color=(0,0,0))    
        
    # mlab.savefig('./processed data/img_sphere/x.jpg',size=(50,50))
    mlab.show()

if __name__ == "__main__":
    from database import cfg_load_yaml 
    cfg=cfg_load_yaml('config.yml')
    
    panorama_example_fn=cfg["spherical_panorama"]["panorama_example_fn"]
    sphere_panorama_label(panorama_example_fn)  
    #panorama_seg_example_fn=cfg["spherical_panorama"]["panorama_seg_example_fn"]
    #sphere_panorama_label(panorama_seg_example_fn)      
```

__Fig. 球面全景交互可视化__  

<a href=""><img src="./imgs/3_2_1_03.gif" height="auto" width=800 title="caDesign"></a>

__Fig. 语义分割球面全景交互可视化__  

<a href=""><img src="./imgs/3_2_1_04.gif" height="auto" width=800 title="caDesign"></a>

###### 4) 全景图投影变换示例排布绘图

`imgs_arranging.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Wed May 12 12:44:51 2021
Updated on Thu Jan 20 17:13:05 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""


def panoramic_transform_example_show(*args):
    '''
    全景图投影变换示例排布绘图

    Parameters
    ----------
    *args : 图像路径参数
        包括：panorama_fn,polar_fn,cube_fn,sphere_fn.

    Returns
    -------
    None.

    '''
    from PIL import Image,ImageOps
    import numpy as np
    import matplotlib.pyplot as plt
    import cv2
    import matplotlib
    
    panorama_fn,polar_fn,cube_fn,sphere_fn=args
    
    font = {
            # 'family' : 'normal',
            # 'weight' : 'bold',
            'size'   : 28}
    matplotlib.rc('font', **font)
    title_fontsize=55
    
    # vertical_label_radians=np.linspace(0, np.pi,14)
    # vertical_label_degree=["{:.2f}".format(90-math.degrees(radi)) for radi in vertical_label_radians]
    vertical_label_degree=90-np.linspace(0, 180,17)
    horizontal_label_degree=180-np.linspace(0, 360,17)    
    print(horizontal_label_degree)
    
    pano=np.asarray(Image.open(panorama_fn))
    # pano=cv2.imread(panorama_fn)
    pano_height,pano_width,_=pano.shape
    print(pano_width,pano_height)
    
    # fig, (ax1, ax2)=plt.subplots(ncols=2, figsize=(20,10))
    fig=plt.figure(figsize=(20,10))
    
    #01-pano
    # ax1=plt.subplot(131, frameon=False)  
    ax1_coords=[0, 0, 1, 1] #rect : This parameter is the dimensions [left, bottom, width, height] of the new axes.
    ax1=fig.add_axes(ax1_coords)    
    
    ax1.imshow(pano,)     #extent=[x0, x1, y0, y1]  interpolation='bilinear',aspect='auto',origin='lower',
    ax1.set_yticks(np.linspace(0,pano_height,len(vertical_label_degree)))    
    ax1.set_yticklabels(vertical_label_degree) # provide name to the x axis tick marks   
    ax1.set_xticks(np.linspace(0,pano_width,len(horizontal_label_degree)))    
    ax1.set_xticklabels(horizontal_label_degree) # provide name to the x axis tick marks   
    ax1.axhline(y=pano_height/2,color='gray',linestyle='-.',linewidth=1)
    ax1.axvline(x=pano_width/2,color='gray',linestyle='-.',linewidth=1)
    ax1.set_title("Equirectangular format", va = 'bottom',fontsize=title_fontsize)

    #02-polar
    # polar=cv2.imread(polar_fn)
    polar=np.asarray(Image.open(polar_fn))
    polar_height,polar_width,_=polar.shape   
    ax2_coords = [0.8, 0, 1, 1]
    
    ax2_image = fig.add_axes(ax2_coords)
    ax2_image.imshow(polar, alpha = 1)
    ax2_image.axis('off')  # don't show the axes ticks/lines/etc. associated with the image    

    #theta = np.linspace(0, 2 * np.pi, 73)       
    ax2_coords_=[0.80000001, 0, 1, 1] #如果位置重叠，可能会提示ValueError: Unknown element o错误
    ax2_polar = fig.add_axes(ax2_coords_, projection='polar')
    ax2_polar.patch.set_alpha(0)
    ax2_polar.set_ylim(30, 41)
    ax2_polar.set_yticks(np.arange(30, 41, 2))
    ax2_polar.set_yticklabels([])
    ax2_polar.set_rlabel_position(-22.5)  # get radial labels away from plotted line
    ax2_polar.grid(True)
    ax2_polar.set_title("Polar format", va = 'bottom',fontsize=title_fontsize)    

    #03-cube
    ax3_coords=[1.47, 0, 1, 1]
    ax3=fig.add_axes(ax3_coords)
    # cube=cv2.imread(cube_fn)
    cube=np.asarray(Image.open(cube_fn))
    cube_height,cube_width,_=cube.shape
    ax3.imshow(cube, alpha = 1)
    ax3.axis('off')    
    ax3.axvline(x=cube_width*(1/3),color='gray',linestyle='-.',linewidth=1)
    ax3.axvline(x=cube_width*(2/3),color='gray',linestyle='-.',linewidth=1)    
    ax3.set_title("Cubic format", va = 'bottom',fontsize=title_fontsize)
    bbox_props = dict(boxstyle="round", fc="w", ec="0.5", alpha=0.4)
    ax3.text(cube_width*(1/6), cube_height*(1/4), "Top", ha="center", va="center", size=40,bbox=bbox_props)
    ax3.text(cube_width*(3/6), cube_height*(1/4), "Back", ha="center", va="center", size=40,bbox=bbox_props)
    ax3.text(cube_width*(5/6), cube_height*(1/4), "Down", ha="center", va="center", size=40,bbox=bbox_props)
    ax3.text(cube_width*(1/6), cube_height*(3/4), "Left", ha="center", va="center", size=40,bbox=bbox_props)
    ax3.text(cube_width*(3/6), cube_height*(3/4), "Front", ha="center", va="center", size=40,bbox=bbox_props)
    ax3.text(cube_width*(5/6), cube_height*(3/4), "Right", ha="center", va="center", size=40,bbox=bbox_props)    
    
    #04-sphere
    ax4_coords=[2.15, 0, 1, 1]
    ax4=fig.add_axes(ax4_coords)    
    # sphere=cv2.imread(sphere_fn)    
    sphere=np.asarray(Image.open(sphere_fn))
    ax4.imshow(sphere)     
    ax4.axis('off') 
    ax4.set_title("Spherical format", va = 'bottom',fontsize=title_fontsize)
    
    fig.tight_layout()    
    # fig.savefig('./graph/preprocessed data_01',dpi=300)
    plt.show()

if __name__=="__main__":
    from database import cfg_load_yaml   
    import os    
    cfg=cfg_load_yaml('config.yml')    
    
    #A.全景图投影变换示例排布绘图
    panoramic_transform_example_fn=cfg["imgs_arranging"]["panoramic_transform_example_fn"]
    # PT_img_fns=[os.path.join(cfg["streetview"]["panoramic_imgs_valid_root"],panoramic_transform_example_fn),
    #             os.path.join(cfg["equi2polar"]["region"]["polar_img_root"],panoramic_transform_example_fn),
    #             os.path.join(cfg["equi2cube"]["cube_img"],panoramic_transform_example_fn),
    #             os.path.join(cfg["spherical_panorama"]["img_sphere_root"],panoramic_transform_example_fn)]
    # panoramic_transform_example_show(*PT_img_fns)
    
    PT_seg_fns=[os.path.join(cfg["panaSeg"]["pano_path"],panoramic_transform_example_fn),
                os.path.join(cfg["equi2polar"]["region"]["polar_seg_root"],panoramic_transform_example_fn),
                os.path.join(cfg["equi2cube"]["region"]["img_seg_cube_root"],panoramic_transform_example_fn),
                os.path.join(cfg["spherical_panorama"]["seg_sphere_root"],panoramic_transform_example_fn)]
    panoramic_transform_example_show(*PT_seg_fns)
```

__Fig. 全景变换数据类型__  

<a href=""><img src="./imgs/3_2_1_05.png" height="auto" width="auto" title="caDesign"></a>


#### B.2.3 分析与结果

分析城市街道空间特征的指数主要包括基于立方体型360度全景图语义分割对象像素占比，即绿视率、天空视域因子和地面视域占比，及视觉（熵）均衡度和域对象位置变化；基于极坐标格式全景图语义分割天空对象的景观指数，包括周长面积比、形状指数和分维数；基于等量矩形投影全景图颜色的主题色提取和色彩丰富度指数；基于尺度不变特征转换特征关键点信息的关键点邻域尺度(i,j]区间频数、标准差和视域特征匹配消失距离；基于行业分类服务内容兴趣点的POI点数、POI均衡度和POI特征映射，总共16个指数。其中反应视域城市街道物质空间组成结构，基于全景图计算机视觉分析的指数13个；反应居民日常活动，基于具有社会属性，即服务空间的兴趣点指数3个。

| 序号  | 指数名称  |  值个数 | 内容  |  公式 |  描述 |   
|---|---|---|---|---|---|
|  1 | 绿视率（Seg object_Green view index, Seg_GVI）  | 1  | 基于立方体型360度全景图语义分割对象像素占比  | $Seg\_GVI= \frac{ P_{seg\_green} }{P}  \times 100$  |  绿视率（$Seg\_GVI$）等于立方体型360度全景图语义分割对象中植被像素数$P_{seg\_green}$ 占全部像素数P的百分比。 |   
|  2 | 天空视域因子（Seg object Sky view factor, Seg_SVF）  | 1  |   | $Seg\_SVF= \frac{ P_{seg\_sky} }{P}  \times 100$  | 天空视域因子（$Seg\_SVF$ ）等于立方体型360度全景图语义分割对象中天空像素数$P_{seg\_sky}$ 占全部像素数 P的百分比。  |   
|  3 | 地面视域占比（Seg object Ground view factor, Seg_GVF）  | 1  |   | $Seg\_GVF= \frac{ P_{seg\_ground} }{P}  \times 100$  | 地面视域占比（$Seg\_GVF$ ）等于立方体型360度全景图语义分割对象中地面像素数$P_{seg\_ground}$ 占全部像素数P的百分比。  |   
|  4 | 视觉（熵）均衡度（Seg object equilibrium degree, Seg_ED）  |  1 |   |  $Seg\_ED= \frac{- \sum_{i=1}^n  P_{i}logP_{i}  }{logN}$  | 视觉（熵）均衡度（$Seg\_ED$）为立方体型360度全景图语义分割对象信息熵与最大熵值$logN$之比。 $P_{i}$ 为第$i$个语义分割对象像素数与全部像素数的比值。  |  
| 5  | 视域对象位置变化（Variation degree of objects , VDO）  | 多个值  |   |  $VDO_{ij}= \Delta  ( A_{0} ) _{ij} +  \Delta  ( A_{1} ) _{ij} +  \ldots  + \Delta  ( A_{k-1} ) _{ij};  \Delta  (A) _{ij}=\begin{cases}1 & \Delta  (A) _{ij}> 0\\0 & \Delta  (A) _{ij}=0\end{cases} $ |  视域对象位置变化$VDO$为分析路径下各个地理位置点的球面全景语义分割对象在球面各像素点位置上的变化，即任意球面位置$(i,j)$在路径上相邻两位置语义分割对象发生了改变则加1，即$\Delta  (A) _{ij}=1$否则加0，未发生改变，得球面位置$(i,j)$的变化次数$VDO_{ij}$。$VDO$矩阵即为视域对象位置变化。 |  
|  6 | 天际线周长面积比（均值）（Skyline perimeter area ratio, Sky_PARA(mn)） |  1 | 基于极坐标格式全景图语义分割天空对象的景观指数  |  $Sky\_PARA_{(mn)} = \frac{ \sum_{i=1}^n  \frac{ p_{i} }{ a_{i} }  }{n}$  |  天际线周长面积比（均值）（$Sky\_PARA_{(mn)}$）等于极坐标格式全景图语义分割对象中各个天空斑块周长$p_{i}$与面积$a_{i}$ 比之和除以天空的斑块数$n$。由PyLandStats库（Python）计算。 |   
|  7 | 天际线形状指数（均值）（Skyline shape index, Sky_ SHAPE(mn)）  | 1  |   | $ Sky\_SHAPE_{(mn)} = \frac{ \sum_{i=1}^n  \frac{.25 p_{i} }{ \sqrt{ a_{i} } } }{n} $  |  天际线形状指数（均值）（$ Sky\_SHAPE_{(mn)}$）等于极坐标格式全景图语义分割对象中各个天空斑块周长$p_{i}$与面积$a_{i}$ 平方根比值乘以调整系数的和除以天空的斑块数 $n$。 由PyLandStats库（Python）计算。|   
|  8 | 天际线分维数（均值）（Skyline fractal dimension, Sky_ FRAC(mn) ）  |  1 |   | $Sky\_FRAC_{(mn)} = \frac{ \sum_{i=1}^n  \frac{2ln(.25 p_{i} )}{ln( a_{i} )}  }{n} $  | 天际线分维数（均值）（$Sky\_FRAC_{(mn)}$ ）等于极坐标格式全景图语义分割对象中各个天空斑块周长$p_{i}$乘以调整系数后取其对数的2倍与面积$a_{i}$ 的对数比值的和除以天空的斑块数 $n$。 由PyLandStats库（Python）计算。 |   
|  9 | 主题色（Theme color, TC）  | 多个值  | 基于等量矩形投影全景图城市街道色彩  | $argmin_{S} \sum_{i=1}^k  \sum_{x \in  S_{i} }\|x-  \mu _{i}   \|^{2}  $;$TC=\{ TC_{i} : TC_{i} =  \frac{1}{ \| S_{i} \| }  \sum_{ x_{j}  \in   S_{i} }  x_{j} \}$ | 主题色（$TC$）为等量矩形投影全景图颜色值聚类各簇中心值 $TC_{i}$的集合，即第$i$个类簇所有颜色点各属性值（R、G、B）的和除以该簇个数$\|S_{i}\|$。聚类条件为使得所有簇内各颜色点$x$到该簇中心值（经验均值）$μ_{i}$的平方误差和最小。 由scikit-learn库（Python）的K-Means方法聚类。 |   
|  10 | 色彩丰富度指数（Color richness index, CRI）   |  1 |   | $CRI= \frac{- \sum_{i=1}^k  P_{i}logP_{i}  }{log\| S\| } $;$P_{i} = \frac{\| S_{i} \|  }{ \sum_{i=1}^k \| S_{i} \|  } , S_{i} \in S$  | 色彩丰富度指数（CRI）为等量矩形投影全景图主题色聚类的信息熵与最大熵值log⌈S⌉的比值， ⌈S⌉ 即主题色聚类数，全景图各颜色点所属主题色由主题色TC计算时获取。P_i为第i个主题色聚类簇颜色点数（像素数）⌈S_i ⌉与全部像素数的比值。  |   
|  11 |关键点邻域尺度(i,j]区间频数（Key point size(i-j] frequency,KPSF_(i,j] )   | 多个值  | 尺度不变特征转换（Scale Invariant Feature Transform, SIFT）  |  $ KPSF_{(i,j]} =\{ x_{k} :i \leq  x_{k} <j,  x_{k}  \in KPS  \}$ | 关键点邻域尺度$(i,j]$区间频数（$KPSF_{(i,j]}$) 为关键点邻域尺度$x_{k}$, 即提取的等量矩形投影全景图特征关键点的大小 $KPS$, 满足条件$i≤ x_{k} < j$的集合。  由opencv-python库（Python）StarDetector_create()方法提取特征关键点。|   
| 12 | 关键点邻域尺度标准差（Key point size std, KPS_STD）  | 1  |   | $KPS\_STD= \sqrt{ \frac{1}{N} \sum_{i=1}^N   ( x_{i}- \mu  )^{2}  } ,  x_{i}  \epsilon KPS$  | 关键点邻域尺度标准差（$KPS\_STD$）为各个关键点邻域尺度$x_{i}$ 与均值 $μ$的差值平方除以关键点数的平方根。 由opencv-python库（Python）StarDetector_create()方法提取特征关键点。 |    
| 13  | 视域特征匹配消失距离 （Vanishing distance of feature matching, VDFM ）   |  1 |   | $VDFM=f( x_{1} ), where  \triangle (x)== \triangle ( \triangle (x)) \& \triangle (x)!=0$  | 视域特征匹配消失距离  $VDFM$为分析路径某一位置等量矩形投影全景图与之后所有位置全景图图像匹配特征点数变化趋于平缓的位置与该位置的路径距离。$\triangle (x)$为连续相邻图像匹配特征点数的差值，$\triangle ( \triangle (x))$为差值的差值；$f(x_{1} )$为满足条件的第一个值$x_{1}$作为参数输入函数$f$，返回其间的路径距离。  由opencv-python库（Python）BFMatcher()方法计算图像匹配。  |   
| 14  | 兴趣点数（Number of POI, POI_NUM）  |  1 |  POI | $POI\_NUM=n$  | 兴趣点数$POI\_NUM$为分析路径某一位置给定缓冲区下兴趣点的数量。|   
| 15  | POI均衡度（Equilibrium degree of POI, POI_ED）  |  1 |   |  $POI\_ED= \frac{- \sum_{i=1}^k  P_{i}logP_{i}  }{log\|S\|} $; $P_{i}= \frac{\| S_{i} \|}{ \sum_{i=1}^k \| S_{i} \| }  , S_{i} \in S$| $POI$均衡度$POI\_ED$为分析路径某一位置给定缓冲区下兴趣点一级行业分类的信息熵与最大熵值$log\|S\|$的比值，$\|S\|$为兴趣点一级行业分类数。$P_{i}$为第$i$个一级行业分类数$\| S_{i} \|$与全部一级行业分类数的比值。  |   
| 16  | POI特征映射（码本映射）（Codewords of POI, POI_CW）  | 多个值  |   |  POI\_CW=[w_{0},w_{1},⋯,w_{k} ] |  $POI$特征映射（码本映射）$POI\_CW$为分析路径某一位置给定缓冲区下兴趣点各一级行业分类的数量或其与总数的比值的矩阵或向量。$k$为一级行业分类的数量，即为矩阵的长度。 |   


##### B.2.3.1 街道空间对象视域占比指数测量

###### 1) 指数计算

语义分割立方体型全景图，计算植被（绿视率）、天空（天空视域因子）、地面视域所占百分比，以及视觉熵均衡度。将计算结果划分为4个数量级区间，(0,15], (15,25], (25,50]和(50,100]，可以描述为较少，正常，较多，多。街道空间对象视域占比指数与城市街区类型，空间体验，市民活动行为，建筑外热环境（微气候）等内容相关。从计算结果的表中可以初步判断分析区域不同视域占比频数比例的分布，绿视率低于15%的接近一半数量，道路以车行为主，高于25%适宜于步行体验，易于放松身心的占到约30%；天空视域因子高于50%的基本没有，以25%为数量级划分，高低各占约一半；将绿视率和天空视域因子综合考虑，即自然因素视域占比，高于25%的达到95%的数量；地面视域占比有约1/4的数量高于50%，通常为道路交叉口以及快速路、主干路等路面宽阔的空间。街道空间对象的混合程度以50%为数量级划分，上下各占约一半，即约有一半数量的街道空间对象均质性相对较强，对象视域数量分布均衡；而一半数量均质性较弱，以某一类对象占主导。

|                | vege_percentage | sky_percentage | sky_vege_percentage | ground_percentage | equilibrium_degree_percentage |
|----------------|-----------------|----------------|---------------------|-------------------|-------------------------------|
| (-0.001, 15.0] | 46.837          | 21.229         | 1.594               | 0.03              | 0.052                         |
| (15.0, 25.0]   | 23.116          | 24.141         | 3.369               | 0.12              | 0.142                         |
| (25.0, 50.0]   | 28.812          | 54.6           | 66.809              | 72.857            | 47.96                         |
| (50.0, 100.0]  | 1.235           | 0.03           | 28.228              | 26.993            | 51.845                        |

`visual_field_proportion_metrics.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 29 19:21:17 2021
Updated on Mon Jan 24 10:54:54 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def metrics_seg_pano_proportion(label_seg_path,img_Seg_path,coords):
    '''
    给定语义分割图像，计算各个对象占图像的百分比

    Parameters
    ----------
    label_seg_path : string
        语义分割标签根目录.
    img_Seg_path : string
        语义分割图像根目录.
    coords : pickle
        各个道路对应全景图的采集坐标点.

    Returns
    -------
    panorama_object_percent_gdf : GeoDataFrame
        包含各个对象占比.

    '''
    import glob,os    
    import pickle
    from pathlib import Path
    from PIL import Image
    from tqdm import tqdm
    import numpy as np
    import pandas as pd
    from shapely.geometry import Point
    import geopandas as gpd
    import pyproj
    
    panorama_object_num=pd.DataFrame(columns=["fn_stem","fn_key","fn_idx","geometry",]+list(range(28)))
    label_mapping={
        0:"pole",
        1:"slight",
        2:"bboard",
        3:"tlight",
        4:"car",
        5:"truck",
        6:"bicycle",
        7:"motor",
        8:"bus",
        9:"tsignf",
        10:"tsignb",
        11:"road",
        12:"sidewalk",
        13:"curbcut",
        14:"crosspln",
        15:"bikelane",
        16:"curb",
        17:"fence",
        18:"wall",
        19:"building",
        20:"person",
        21:"rider",
        22:"sky",
        23:"vege",
        24:"terrain",
        25:"markings",
        26:"crosszeb",
        27:"Nan",                           
        }    
    label_seg_fns=glob.glob(os.path.join(label_seg_path,'*.pkl'))
    # print(label_seg_fns)
    i=0
    for label_seg_fn in tqdm(label_seg_fns):
        with open(label_seg_fn,'rb') as f:
            label_seg=pickle.load(f)  
        fn_stem=Path(label_seg_fn).stem
        fn_key,fn_idx=fn_stem.split("_")      
        
        unique_elements, counts_elements=np.unique(label_seg, return_counts=True)
        object_frequency=dict(zip(unique_elements, counts_elements))
        object_frequency_update={k:object_frequency[k] if k in object_frequency.keys() else 0 for k in range(28) }
        coord=coords[fn_key][int(fn_idx)]
        object_frequency_update.update({"fn_stem":fn_stem,"fn_key":fn_key,"fn_idx":int(fn_idx),"geometry":Point(coord)})
        panorama_object_num=panorama_object_num.append(object_frequency_update,ignore_index=True)
        
        # if i==0:break
        # i+=1
    panorama_object_percent=panorama_object_num.copy(deep=True)
    panorama_object_percent[list(range(28))]=panorama_object_num[list(range(28))].div(np.prod(label_seg.shape)/100)   

    panorama_object_percent=panorama_object_percent.rename(columns=label_mapping)
    panorama_object_percent['ground_diff']=panorama_object_percent.apply(lambda row:100-row.sky-row.vege-row.building-row.wall-row.fence-row.bboard,axis=1)
    panorama_object_percent['sky_vege']=panorama_object_percent.apply(lambda row:row.sky+row.vege,axis=1)
    
    wgs84=pyproj.CRS('EPSG:4326')
    panorama_object_percent_gdf=gpd.GeoDataFrame(panorama_object_percent,geometry=panorama_object_percent.geometry,crs=wgs84) 

    return panorama_object_percent_gdf

def metrics_visual_entropy(panorama_object_percent_gdf):
    '''
    计算每幅语义分割图像，对象的信息和均衡度

    Parameters
    ----------
    panorama_object_percent_gdf : GeoDataFrame
        语义分割图像各个对象占图像的百分比.

    Returns
    -------
    GeoDataFrame
        包含对象的信息和均衡度.

    '''
    panorama_object_percent_gdf['ground']=panorama_object_percent_gdf.apply(lambda row:100-row.sky-row.vege-row.building,axis=1)
    def ve_row(row):
        import math
        import pandas as pd
        label=['pole', 'slight', 'bboard', 'tlight', 'car', 'truck', 'bicycle', 'motor', 'bus', 'tsignf', 'tsignb', 'road', 'sidewalk', 'curbcut', 'crosspln', 'bikelane', 'curb', 'fence', 'wall', 'building', 'person', 'rider', 'sky', 'vege', 'terrain', 'markings', 'crosszeb', 'Nan']
        ve=0.0
        for i in label:
            decimal_percentage=row[i]/100
            # print(decimal_percentage)
            if decimal_percentage!=0.:
                ve-=decimal_percentage*math.log(decimal_percentage)
        max_entropy=math.log(len(label))
        frank_e=ve/max_entropy*100
        
        return pd.Series([ve,frank_e])
    
    panorama_object_percent_gdf[['ve','equilibrium_degree']]=panorama_object_percent_gdf.apply(ve_row,axis=1)
    return panorama_object_percent_gdf

def percent_frequency(df,columns,bins,digits):
    '''
    计算给定区间的百分比频数（percent frequency）

    Parameters
    ----------
    df : DataFrame or GeoDataFrame
        DataFrame数据.
    columns : list
        需要计算的列字段列表.
    bins : list
        频数宽度列表.

    Returns
    -------
    frequency : DataFrame
        给定区间的百分比频数.

    '''
    import pandas as pd
    frequency=df[columns].apply(pd.Series.value_counts,bins=bins,)
    column_names=[]
    for column_name in columns:
        cn=column_name+'_percentage'
        frequency[cn]=round((frequency[column_name] / frequency[column_name].sum()) * 100,3)
        column_names.append(cn)
    return frequency,column_names

if __name__=="__main__":
    import sys,os
    sys.path.append('..')  
    
    from database import postSQL2gpd,gpd2postSQL,cfg_load_yaml   
    import pickle
    parent_path=os.path.dirname(os.getcwd())
    cfg=cfg_load_yaml('../config.yml')  
    UN=cfg["postgreSQL"]["myusername"]
    PW=cfg["postgreSQL"]["mypassword"]
    DB=cfg["postgreSQL"]["mydatabase"] 
    GC='geometry'
    
    #A.街道空间对象视域占比
    label_seg_path=cfg['equi2cube']['region']['label_seg_cube_root'] #r'./processed data/label_seg_cube'    
    img_Seg_path=cfg['equi2cube']['region']['label_seg_cube_root'] #r'./processed data/img_seg_cube'
    img_path=cfg['streetview']['panoramic_imgs_valid_root']  #r'./data/panoramic imgs valid'
        
    with open(os.path.join(parent_path,cfg['streetview']['save_path_BSV_retrival_info']['coords']),'rb') as f: 
        coords=pickle.load(f)       
    
    cube_object_percent_gdf=metrics_seg_pano_proportion(label_seg_path,img_Seg_path,coords,)
    cube_object_percent_gdf.plot()       
    gpd2postSQL(cube_object_percent_gdf,table_name='cube_object_percent',myusername=UN,mypassword=PW,mydatabase=DB)
    
    #B.视觉（熵）均衡度    
    cube_object_percent_gdf=postSQL2gpd(table_name='cube_object_percent',geom_col=GC,myusername=UN,mypassword=PW,mydatabase=DB)
    cube_object_VE_gdf=metrics_visual_entropy(cube_object_percent_gdf)
    gpd2postSQL(cube_object_VE_gdf,table_name='cube_object_percent',myusername=UN,mypassword=PW,mydatabase=DB)
    
    #C.街道空间对象视域占比区间统计 
    cube_object_metrics=postSQL2gpd(table_name='cube_object_percent',geom_col=GC,myusername=UN,mypassword=PW,mydatabase=DB)
    columns=cfg['semantic_segmention_object_pixel_ratio']['columns']
    bins=cfg['semantic_segmention_object_pixel_ratio']['bins']
    digits=cfg['semantic_segmention_object_pixel_ratio']['digits']
    percentage,column_names=percent_frequency(cube_object_metrics,columns,bins,digits)
    percentage[column_names].to_excel(os.path.join(parent_path,cfg['semantic_segmention_object_pixel_ratio']['percentage2excel_path']))
```

###### 2) 示例

列出了不同数量级下立方体型全景图的示例，可以视觉感知判断之间的差异。

`imgs_arranging.py`
```python

def imgs_arranging(imgs_root,img_fns,save_path):
    '''
    语义分割立方体型全景图不同对象视域占比示例

    Parameters
    ----------
    imgs_root : dict
        图像根目录.
    img_fns : dict
        选择不同区间像素占比的图像.
    save_path : string
        保持排布图像的路径.

    Returns
    -------
    None.

    '''
    import os
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import ImageGrid
    from PIL import Image,ImageOps
    import matplotlib
    
    font = {
            # 'family' : 'normal',
            # 'weight' : 'bold',
            'size'   : 28}
    matplotlib.rc('font', **font)    
    
    rows=['(-0.001, 15.0]','(15.0, 25.0]','(25.0, 50.0]','(50.0, 100.0]']
    img_list=[]
    for k,fns in img_fns.items():
        img_list.append([os.path.join(imgs_root,i[1]+'.jpg') for i in fns])
    img_list=list(map(list,zip(*img_list)))
    
    flatten_lst=lambda lst: [m for n_lst in lst for m in flatten_lst(n_lst)] if type(lst) is list else [lst]
    img_list=flatten_lst(img_list)
    nrows_ncols=(len(list(img_fns.values())[0]),len(img_fns.keys()),)
    print(nrows_ncols)
    fig=plt.figure(figsize=(30.+1, 20.-3))
    grid=ImageGrid(fig, 111,  # similar to subplot(111)
                   nrows_ncols=nrows_ncols,  # creates 2x2 grid of axes
                   axes_pad=0.05,  # pad between axes in inch.
                     )    
    i=0
    for ax,im_fn in zip(grid,img_list):
        # print(ax)
        ax.imshow(Image.open(im_fn))           
        # ax.axis('off')         
        
        if i<5:ax.set_title(list(img_fns.keys())[i])        
        if i%5==0:ax.set_ylabel(rows[i//5], )
        i+=1
    fig.tight_layout()
    # plt.show()
    plt.savefig(save_path,dpi=300)

if __name__=="__main__":
    from database import cfg_load_yaml   
    import os    
    cfg=cfg_load_yaml('config.yml')

    #B.语义分割立方体型全景图不同对象视域占比示例
    cube_object_percentage_example_fn=cfg['imgs_arranging']['cube_object_percentage_example_fn']
    object_percentage_cube_save_path=cfg['imgs_arranging']['object_percentage_cube_save_path']
    cube_imgs_root=cfg['equi2cube']['cube_img']
    imgs_arranging(cube_imgs_root,cube_object_percentage_example_fn,object_percentage_cube_save_path)        
```


__Fig. 语义分割立方体型全景图不同对象视域占比示例__ 

<a href=""><img src="./imgs/3_2_1_06.png" height="auto" width="auto" title="caDesign"></a>

###### 3) 视觉（熵）均衡度

较高的均衡度具有较高的均质性。如果延道路计算均衡度的变化值，可以用于评估街道对象变化的程度，这也是街道自身特征的一个映射。

地图构建是在QGIS中从`PostGIS`中调入数据库中保存的`cube_object_percent`表，包含`equilibrium_degree`字段。在`Symbology`项选择`Heatmap`可视化数据。

__Fig. 视觉（熵）均衡度__  

<a href=""><img src="./imgs/3_2_1_07.png" height="auto" width="auto" title="caDesign"></a>

##### B.2.3.2 天际线变化指数

###### 1) 指数计算

语义分割后的等量矩形投影全景图转换为极坐标格式的小行星全景图，提取天空对象计算斑块数量(NP)、周长面积比、形状指数、分维数等4个景观指数。计算4个指数的相关系数，相关性值高于0.5的两对指数分别为周长面积比和斑块数量（0.600），及形状指数和分维数（0.512）。使用自然最佳断裂点分级方法（Natural break, Jenks）划分指数，尽量使得划分的聚类簇示例偏离划分界限值观察天际线的形状差异。


|                         | number_of_patches | perimeter_area_ratio_mn | shape_index_mn | fractal_dimension_mn |
|-------------------------|-------------------|-------------------------|----------------|----------------------|
| number_of_patches       | 1                 | 0.6                     | -0.227         | 0.058                |
| perimeter_area_ratio_mn | 0.6               | 1                       | -0.249         | 0.029                |
| shape_index_mn          | -0.227            | -0.249                  | 1              | 0.512                |
| fractal_dimension_mn    | 0.058             | 0.029                   | 0.512          | 1                    |

__Fig. 天际线变化指数相关系数__  

<a href=""><img src="./imgs/3_2_1_08.png" height="auto" width="auto" title="caDesign"></a>

`skyline_shape_metrics.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Sun May  2 14:01:09 2021
Updated on Mon Jan 24 22:32:44 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def metrics_skyline_shape(img_root,coords,hsv_lower,hsv_upper,save_root):
    '''
    天际线景观指数计算

    Parameters
    ----------
    img_root : string
        极坐标格式全景图所在根目录.
    coords : dict
        各个道路对应全景图的采集坐标点.
    hsv_lower : list
        颜色最小值控制.
    hsv_upper : list
        颜色最大值控制.
    save_root : string
        TIFF 格式图像保存根目录.

    Returns
    -------
    metrics_skyline_shape_gdf : GeoDataFrame
        天际线景观指数.

    '''
    from tqdm import tqdm
    import glob,os 
    import numpy as np
    import cv2
    import matplotlib.pyplot as plt
    import rasterio as rio
    from rasterio.transform import from_origin
    from pathlib import Path 
    import pylandstats as pls
    import pandas as pd
    from shapely.geometry import Point
    import geopandas as gpd
    import pyproj        
    
    polar_seg_fns=glob.glob(os.path.join(img_root,'*.jpg'))
    hsv_lower_=np.asarray(hsv_lower)
    hsv_upper_=np.asarray(hsv_upper)
    
    transform=from_origin(472137, 5015782, 100, 100)  #472137, 5015782, 0.5, 0.5
    
    '''
    columns=["fn_stem","fn_key","fn_idx","geometry",]+['total_area', 'proportion_of_landscape', 'number_of_patches',
       'patch_density', 'largest_patch_index', 'total_edge', 'edge_density',
       'landscape_shape_index', 'effective_mesh_size', 'area_mn', 'area_am',
       'area_md', 'area_ra', 'area_sd', 'area_cv', 'perimeter_mn',
       'perimeter_am', 'perimeter_md', 'perimeter_ra', 'perimeter_sd',
       'perimeter_cv', 'perimeter_area_ratio_mn', 'perimeter_area_ratio_am',
       'perimeter_area_ratio_md', 'perimeter_area_ratio_ra',
       'perimeter_area_ratio_sd', 'perimeter_area_ratio_cv', 'shape_index_mn',
       'shape_index_am', 'shape_index_md', 'shape_index_ra', 'shape_index_sd',
       'shape_index_cv', 'fractal_dimension_mn', 'fractal_dimension_am',
       'fractal_dimension_md', 'fractal_dimension_ra', 'fractal_dimension_sd',
       'fractal_dimension_cv', 'euclidean_nearest_neighbor_mn',
       'euclidean_nearest_neighbor_am', 'euclidean_nearest_neighbor_md',
       'euclidean_nearest_neighbor_ra', 'euclidean_nearest_neighbor_sd',
       'euclidean_nearest_neighbor_cv']
    '''
    metrics=['total_area','area_mn','perimeter_mn','perimeter_area_ratio_mn','number_of_patches','landscape_shape_index','shape_index_mn','fractal_dimension_mn',]
    columns=["fn_stem","fn_key","fn_idx","geometry",]+metrics
    
    sky_class_level_metrics=pd.DataFrame(columns=columns)    
    i=0
    for fn in tqdm(polar_seg_fns):
        fn_stem=Path(fn).stem
        fn_key,fn_idx=fn_stem.split("_")    
        coord=coords[fn_key][int(fn_idx)]
        img=cv2.imread(fn)
        img_hsv=cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
        mask=cv2.inRange(img_hsv, hsv_lower_, hsv_upper_)        
        mask=np.where(mask==255,1,mask) #.astype(np.float64)       
        tiff_fn=os.path.join(save_root,'{}.tif'.format(Path(fn).stem))
        dst=rio.open(tiff_fn, 'w', driver='GTiff',
                                  height=mask.shape[0], width=mask.shape[1],
                                  count=1, dtype=str(mask.dtype),#dtype=rio.uint8,
                                  crs='+proj=utm +zone=10 +ellps=GRS80 +datum=NAD83 +units=m +no_defs',
                                  transform=transform)        
        dst.nodata=0
        dst.write(mask,1)
        dst.close()
        
        ls=pls.Landscape(tiff_fn)
        try:      
            class_metrics_df=ls.compute_class_metrics_df(metrics=metrics) 
            class_metrics_dict=class_metrics_df.transpose().to_dict()[1]
        except:
            class_metrics_dict={k:0 for k in metrics}              
        
        class_metrics_dict.update({"fn_stem":fn_stem,"fn_key":fn_key,"fn_idx":int(fn_idx),"geometry":Point(coord)})
        sky_class_level_metrics=sky_class_level_metrics.append(class_metrics_dict,ignore_index=True)
        
        # if i==3:break
        # i+=1

    wgs84='EPSG:4326' #pyproj.CRS('EPSG:4326')
    metrics_skyline_shape_gdf=gpd.GeoDataFrame(sky_class_level_metrics,geometry=sky_class_level_metrics.geometry,crs=wgs84) 
    return metrics_skyline_shape_gdf

def correlation_df(df,idxes,save_path,digits):
        '''
    有DataFrame数据格式计算相关系数

    Parameters
    ----------
    df : dataframe
        待计算的数据.
    idxes : list
        待计算的指数列名.
    save_path : string
        excel文件保存路径.
    digits : int
        保留小位数.

    Returns
    -------
    None.

    '''
    import seaborn as sns
    import matplotlib.pyplot as plt
    import numpy as np
    
    corr=df[idxes].corr()
    corr_round=corr.round(digits)
    corr_round.to_excel(save_path)
    
    # Generate a mask for the upper triangle
    mask=np.triu(np.ones_like(corr, dtype=bool))
    
    # Set up the matplotlib figure
    f, ax=plt.subplots(figsize=(11, 9))    
    
    # Generate a custom diverging colormap
    cmap=sns.diverging_palette(230, 20, as_cmap=True)    
    # Draw the heatmap with the mask and correct aspect ratio
    sns.heatmap(corr_round, mask=mask, cmap=cmap, vmax=.3, center=0, annot=True, square=True, linewidths=.5, cbar_kws={"shrink": .5})    

if __name__=="__main__":
    import sys,os
    sys.path.append('..')  
    
    from database import postSQL2gpd,gpd2postSQL,cfg_load_yaml   
    import pickle
    parent_path=os.path.dirname(os.getcwd())
    cfg=cfg_load_yaml('../config.yml')  

    cfg=cfg_load_yaml('../config.yml')  
    UN=cfg["postgreSQL"]["myusername"]
    PW=cfg["postgreSQL"]["mypassword"]
    DB=cfg["postgreSQL"]["mydatabase"] 
    GC='geometry'       
    
    #A.计算天际线变化指数
    with open(os.path.join(parent_path,cfg['streetview']['save_path_BSV_retrival_info']['coords']),'rb') as f: 
        coords=pickle.load(f) 
        
    polar_seg_root=cfg['equi2polar']['region']['polar_sky_root'] 
    tiff_sky_save_root=cfg['skyline_shape_metrics']['tiff_sky_save_root']
    hsv_lower=cfg['skyline_shape_metrics']['hsv_lower']
    hsv_upper=cfg['skyline_shape_metrics']['hsv_upper']
    metrics_skyline_shape_gdf=metrics_skyline_shape(polar_seg_root,coords,hsv_lower,hsv_upper,tiff_sky_save_root)
    gpd2postSQL(metrics_skyline_shape_gdf,table_name='metrics_skyline_shape',myusername=UN,mypassword=PW,mydatabase=DB)
    
    #B.天际线景观指数间的相关系数
    metrics_skyline_shape_gdf=postSQL2gpd(table_name='metrics_skyline_shape',geom_col=GC,myusername=UN,mypassword=PW,mydatabase=DB)
    correlation_columns=cfg['skyline_shape_metrics']['correlation_columns']
    correlation_save_path=os.path.join(parent_path,cfg['skyline_shape_metrics']['correlation_save_path'])
    digits=cfg['skyline_shape_metrics']['digits']
    correlation_df(metrics_skyline_shape_gdf,correlation_columns,correlation_save_path,digits)
```

###### 2) 示例

其中形状指数、分维数能够较好分离天际线形状差异。

`imgs_arranging.py`
```python

def skyline_metrics_imgs_arranging(idxes_df,imgs_root,save_path,domain,idx='PA'):
    '''
    不同数量级的天际线形状指数的极坐标形式示例

    Parameters
    ----------
    idxes_df : DataFrame
        天际线景观指数.
    imgs_root : string
        极坐标格式全景图根目录.
    save_path : string
        排布图像保存路径.
    domain : dict
        不同指数计算对应提取区间的配置.
    idx : string, optional
        所要计算的指数. The default is 'PA'.

    Returns
    -------
    None.

    '''
    import os
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.axes_grid1 import ImageGrid
    from PIL import Image,ImageOps
    import matplotlib
    
    idx_domain=domain[idx]
    if idx=='PA':
        lower_df=idxes_df[idxes_df.perimeter_area_ratio_mn<idx_domain[1]-20]
        upper_df=idxes_df[idxes_df.perimeter_area_ratio_mn>=idx_domain[1]+140]
        title_n='Perimeter area ratio'
    elif idx=='SI':
        lower_df=idxes_df[idxes_df.shape_index_mn<idx_domain[1]-0.5]
        upper_df=idxes_df[idxes_df.shape_index_mn>=idx_domain[1]+1]
        title_n='Shape index'
    elif idx=='FD':
        lower_df=idxes_df[idxes_df.fractal_dimension_mn<idx_domain[1]-0.01]
        upper_df=idxes_df[idxes_df.fractal_dimension_mn>=idx_domain[1]+0.01]  
        title_n='Fractal dimension'
        
    lower_fns=lower_df.fn_stem.sample(n=10)
    upper_fns=upper_df.fn_stem.sample(n=10)        

    lower_upper_fns=lower_fns.append(upper_fns)
    lower_upper_fns=[os.path.join(imgs_root,i+'.jpg') for i in lower_upper_fns]

    font = {
            # 'family' : 'normal',
            # 'weight' : 'bold',
            'size'   : 26}
    matplotlib.rc('font', **font) 
    
    nrows_ncols=(2,10)
    fig=plt.figure(figsize=(30, 7.))
    grid=ImageGrid(fig, 111,  # similar to subplot(111)
                   nrows_ncols=nrows_ncols,  # creates 2x2 grid of axes
                   axes_pad=0.0,  # pad between axes in inch.
                     )      
    i=0
    rows=['({},{}]'.format(idx_domain[0],idx_domain[1]),'({},{}]'.format(idx_domain[1],idx_domain[2])]
    for ax,im_fn in zip(grid,lower_upper_fns):
        # print(ax)
        ax.axes.xaxis.set_ticklabels([])
        ax.axes.yaxis.set_ticklabels([])
        ax.set_frame_on(False)
        ax.imshow(Image.open(im_fn),cmap='Greys',  interpolation='nearest')  
        if i==1:ax.set_title(title_n)   
        if i%10==0:ax.set_ylabel(rows[i//10], )
        i+=1
        
    # plt.title(title_n)      
    fig.tight_layout()    
    # plt.show()        
    plt.savefig(os.path.join(save_path,'{}.png'.format(title_n)),dpi=300)        

if __name__=="__main__":
    from database import postSQL2gpd,gpd2postSQL,cfg_load_yaml      
    import os    
    cfg=cfg_load_yaml('config.yml')   

    #C.不同数量级的天际线形状指数的极坐标形式示例
    UN=cfg["postgreSQL"]["myusername"]
    PW=cfg["postgreSQL"]["mypassword"]
    DB=cfg["postgreSQL"]["mydatabase"] 
    GC='geometry'  
    metrics_skyline_shape_gdf=postSQL2gpd(table_name='metrics_skyline_shape',geom_col=GC,myusername=UN,mypassword=PW,mydatabase=DB)
    skyline_metrics_domain=cfg['imgs_arranging']['skyline_metrics_domain']
    polar_seg_root=cfg['equi2polar']['region']['polar_sky_root'] 
    skyline_metrics_imgs_save_path=cfg['imgs_arranging']['skyline_metrics_imgs_save_path']
    for idx in skyline_metrics_domain.keys():
        skyline_metrics_imgs_arranging(metrics_skyline_shape_gdf,polar_seg_root,skyline_metrics_imgs_save_path,skyline_metrics_domain,idx=idx)
```

__Fig. 不同数量级的天际线形状指数的极坐标形式示例__ 

<a href=""><img src="./imgs/3_2_1_09.png" height="auto" width="auto" title="caDesign"></a>

<a href=""><img src="./imgs/3_2_1_10.png" height="auto" width="auto" title="caDesign"></a>

<a href=""><img src="./imgs/3_2_1_11.png" height="auto" width="auto" title="caDesign"></a>

##### B.2.3.3 街道空间的色彩

色彩属性表征城市街道空间的类型和视觉感受。计算区域尺度全景图主题色，通过主题色分布邻近像素聚类，计算获取每一全景图对应街道空间位置的主题色分布信息熵及均衡度。在衡量均衡度分布时，将其划分为(0,50], (50,65], (65,75]和(75,100]等4个区间，可以描述为单调，正常，较丰富，丰富，其频数百分比为分别为0.621，24.380，59.870，15.128。一半以上的街道空间为较丰富，分布于分析区域各处；而大于75%的丰富区域通常位于具有生活性的街巷空间。

###### 1) 指数计算



### B.3 讨论与结论

#### B.参考文献


## B. 研究代码更新与发布




