> Created on Wed Apr 28 14:46:58 2021 @author: Richie Bao-caDesign设计(cadesign.cn)__+updated on Tue Jan 18 20:45:54 2022 by Richie Bao 

# 3.1.1 城市街道空间指数计算与对空间特征分布的贡献度

## A. 建立研究代码项目

1. 本地仓库与GitHub仓库

2. 建立数据库

使用[pgAdmin](https://www.pgadmin.org/)创建本地关系数据库`PAPER_Urban_Street_Space_Metrics`，并在`Query Editor`中执行`CREATE EXTENSION postgis;`，使能够存储具有坐标系统的地理几何对象。随书写研究代码进展读写数据库。

3. 建立配置文件

使用[YAML](https://en.wikipedia.org/wiki/YAML)文件格式，书写配置文件。随书写研究代码进展完善配置内容。


## B. 专项研究与代码实现

### B.1 背景


### B.2 研究方法与结果

#### B.2.1 研究区域

选取西安市（34° 15'N，108°56'E）碑林区、莲湖区、雁塔区、新城区、未央区和灞桥区等6个行政区域为区域尺度研究对象。选取荐福寺路、朱雀大街北段、友谊西路、长安北路、南大街、西大街、回民路、西华门大街等8段部分道路，及南门盘道和钟楼环道连续的部分区段作为街道尺度的研究对象。

> 在数据选择上，实际不需要划分为区域及连续街道两种形式，可以直接下载每8m(百度地图应用限制)为一个采样点的全城全景图数据。百度街道全景图及Google街道全景图下载需要支付数据费用，因此在资金支付和研究内容上做了平衡。

#### B.2.2 数据

| 序号  | 数据名称  | 数据来源  | 说明  |大小|数据类型|
|---|---|---|---|---|---|
| 1  | 道路  | 来源于中国专业IT社区CSDN (Chinese Software Developer Network)的开放数据  | 由道路提取采样点，用于全景图检索下载  |/ |.shp，.kml|
| 2  |  行政区域 | CSDN  | 用于数据裁切至研究区域  |/ |.shp|
| 3  |  全景静态图 | 百度地图应用  | 用于像素级图像语义分割，计算城市街道空间指数  |区域：13,359张； 街道：599张|.jpg|
|  4 |  POI | 百度地图应用  | 计算业态分布指数  |街道：13,732个 |.csv或.json|

##### B.2.2.1 数据获取及预处理

* 原数据转换为GeoDataFrame数据格式，并写入数据库，用于后续分析，及QGIS地图的建立

处理数据包括：道路（.shp格式和.kml格式两种）、行政区划（.shp格式）

`database.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 10:45:39 2021
updated on Wed Jan 19 09:25:11 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def gpd2postSQL(gdf,table_name,**kwargs):  
    '''
    function - 将GeoDataFrame格式数据写入PostgreSQL数据库
    
    Paras:
        gdf - GeoDataFrame格式数据，含geometry字段（几何对象，点、线和面，数据值对应定义的坐标系统）
        table_name - 写入数据库中的表名
        **kwargs - 连接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）
    '''    
    from sqlalchemy import create_engine
    
    engine=create_engine("postgres://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    gdf.to_postgis(table_name, con=engine, if_exists='replace', index=False,)  
    print("_"*50)
    print('The GeoDataFrame has been written to the PostgreSQL database.The table name is {}.'.format(table_name))

def postSQL2gpd(table_name,geom_col='geometry',**kwargs):    
    '''
    function - 读取PostgreSQL数据库中的表为GeoDataFrame格式数据
    
    Paras:
        table_name - 待读取数据库中的表名
        geom_col='geometry' - 几何对象，常规默认字段为'geometry'
        **kwargs - 连接数据库相关信息，包括myusername（数据库的用户名），mypassword（用户密钥），mydatabase（数据库名）
    '''
    from sqlalchemy import create_engine
    import geopandas as gpd   
    
    engine=create_engine("postgres://{myusername}:{mypassword}@localhost:5432/{mydatabase}".format(myusername=kwargs['myusername'],mypassword=kwargs['mypassword'],mydatabase=kwargs['mydatabase']))  
    gdf=gpd.read_postgis(table_name, con=engine,geom_col=geom_col)
    print("_"*50)
    print('The data has been read from PostgreSQL database. The table name is {}.'.format(table_name))    
    return gdf  

def shp2gdf(fn,epsg=None,boundary=None,encoding='utf-8'):    
    '''
    function - 转换.shp地理信息数据为GeoDataFrame(geopandas)数据格式，可以配置投影
    
    Paras:
        fn - .shp文件路径
        epsg - 配置投影，默认为None
        boundary - 配置裁切边界，默认为None
        encoding - 配置编码，默认为'utf-8'
    '''
    import geopandas as gpd
    
    shp_gdf=gpd.read_file(fn,encoding=encoding)
    print('original data info:{}'.format(shp_gdf.shape))
    shp_gdf.dropna(how='all',axis=1,inplace=True)
    print('dropna-how=all,result:{}'.format(shp_gdf.shape))
    shp_gdf.dropna(inplace=True)
    print('dropna-several rows,result:{}'.format(shp_gdf.shape))
    # print(shp_gdf)
    if epsg is not None:
        shp_gdf_proj=shp_gdf.to_crs(epsg=epsg)
    if boundary:
        shp_gdf_proj['mask']=shp_gdf_proj.geometry.apply(lambda row:row.within(boundary))
        shp_gdf_proj.query('mask',inplace=True)        
    
    return shp_gdf_proj

def kml2gdf_folder(fn,epsg=None,boundary=None): 
    '''
    转换.kml（Google Eath）为GeoDataFrame格式

    Parameters
    ----------
    fn : .kml
        在Google Earth中绘制的格式.
    epsg : epsg编号, optional
        地理投影信息.
    boundary : GeoDataFrame, optional
        裁切边界. The default is None.

    Returns
    -------
    kml_gdf_proj : GeoDataFrame
        转换.kml为GeoDataFrame.

    '''
    import pandas as pd
    import geopandas as gpd
    import fiona,io
    from tqdm import tqdm

    # Enable fiona driver
    gpd.io.file.fiona.drvsupport.supported_drivers['KML'] = 'rw'
    kml_gdf=gpd.GeoDataFrame()
    for layer in tqdm(fiona.listlayers(fn)):
        # print("_"*50)
        # print(layer)
        src=fiona.open(fn, layer=layer)
        meta = src.meta
        meta['driver'] = 'KML'        
        with io.BytesIO() as buffer:
            with fiona.open(buffer, 'w', **meta) as dst:            
                for i, feature in enumerate(src):
                    # print(feature)
                    # print("_"*50)
                    # print(feature['geometry']['coordinates'])
                    if len(feature['geometry']['coordinates'][0]) > 1:
                        # print(feature['geometry']['coordinates'])
                        
                        dst.write(feature)
                        # break
            buffer.seek(0)
            one_layer=gpd.read_file(buffer,driver='KML')
            # print(one_layer)
            one_layer['group']=layer
            kml_gdf=kml_gdf.append(one_layer,ignore_index=True)

    if epsg is not None:
        kml_gdf_proj=kml_gdf.to_crs(epsg=epsg)

    if boundary:
        kml_gdf_proj['mask']=kml_gdf_proj.geometry.apply(lambda row:row.within(boundary))
        kml_gdf_proj.query('mask',inplace=True)        

    return kml_gdf_proj    


def cfg_load_yaml(ymlf_fp):
    '''
    读取 yaml 格式的配置文件

    Parameters
    ----------
    ymlf_fp : string
        配置文件路径.

    Returns
    -------
    cfg : yaml-dict
        读取到python中的配置信息.
    '''
    import yaml
    with open (ymlf_fp,'r') as ymlfile:
        cfg=yaml.safe_load(ymlfile)   
    return cfg

if __name__=="__main__":
    cfg=cfg_load_yaml('config.yml')
    print(cfg["data_path"]) 
    #help(cfg_load_yaml)
    
    #1.转换.shp格式的行政区划region_merge（合并的）为GeoDataFrame格式，并写入数据库
    region_merge=shp2gdf(cfg['data_path']['region_merge'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8')
    #region_merge.plot() 
    gpd2postSQL(region_merge,
                table_name='region_merge',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #2.配置行政区划的英文名称（拆分的），并写入数据库
    region=shp2gdf(cfg['data_path']['region'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8') 
    #region.plot()
    region_name_mapping={'bqq':'Baoqiao District','wyq':'Weiyang District','lhq':'Lianhu District','ytq':'Yanta District','xcq':'Xincheng District','blq':'Beilin District'}    
    region['name_en']=region['PYNAME'].map(region_name_mapping)
    gpd2postSQL(region,
                table_name='region',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #3.提取研究区域内的道路，并写入数据库
    road=shp2gdf(cfg["data_path"]['road'],epsg=cfg['xian_epsg'],boundary=region_merge.geometry[0],encoding='GBK')
    road.plot()
    gpd2postSQL(road,
                table_name='road',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      
    
    #4.转换.kml街道路径(合并的)为GeoDataFrame格式，并写入数据库
    tour_line=kml2gdf_folder(cfg['data_path']['tour_line'],epsg=cfg['xian_epsg'],boundary=None) 
    tour_line.plot()
    gpd2postSQL(tour_line,
                table_name='tour_line',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      
    
    #5.转换.kml街道路径（拆分的）为GeoDataFrame格式，并写入数据库
    tour_line_seg=shp2gdf(cfg['data_path']['tour_line_seg'],epsg=cfg['xian_epsg'],boundary=None,encoding='utf8')
    # tour_line_seg.plot()
    gpd2postSQL(tour_line_seg,
                table_name='tour_line_seg',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])      

```

* 全景静态图检索下载

基本流程：根据道路线，给定距离获取采样点；->给定采样点从百度地图应用中检索全景图下载；->验证下载图像的有效性，并复制有效的图像至新建的文件夹下。

`baidu_streetview_crawler.py`
```python
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 14:46:58 2021
updated on Wed Jan 19 16:00:24 2022

@author: Richie Bao-caDesign设计(cadesign.cn)
"""

def roads_pts4bsv(roads_gdf,distance=10):
    '''
    给定GeoDataFrame的道路中心线，和采样距离，返回采样点

    Parameters
    ----------
    roads_gdf : GeoDataFrame
        GeoDataFrame的道路中心线.
    distance : numerical value, optional
        采样距离. The default is 10.

    Returns
    -------
    GeoDataFrame
        采样点.

    '''
    from tqdm import tqdm
    import numpy as np
    from shapely.geometry import MultiPoint
    import pyproj
    from shapely.ops import transform
    import geopandas as gpd
    
    tqdm.pandas()    
    def line_pts(line):
        dists=np.arange(0,line.length,distance)
        pts=MultiPoint([line.interpolate(d,normalized=False) for d in dists])
        return pts      
        
    roads_gdf['pts']=roads_gdf.geometry.progress_apply(line_pts)
    
    wgs84=pyproj.CRS('EPSG:4326')
    utm=roads_gdf.crs #pyproj.CRS(roads_gpd.crs.srs)
    project=pyproj.Transformer.from_crs(utm, wgs84, always_xy=True).transform
    roads_gdf['pts_wgs84']=roads_gdf.pts.progress_apply(lambda row:transform(project,row))    
    
    pts_gdf=gpd.GeoDataFrame(roads_gdf[['Name','Uid']],geometry=roads_gdf.pts_wgs84.to_list(),crs=wgs84) #roads_gdf.drop(['geometry'],axis=1)    
    return pts_gdf

   
def baidu_steetview_crawler(pts_gdf,save_path,ak,save_path_BSV_retrival_info):
    '''
    从百度地图应用中，根据采样点检索下载全景图
    
    Parameters
    ----------
    pts_gdf : GeoDataFrame
        采样点.
    save_path : string
        全景图的保存路径.
    ak : string
        访问应用的AK值，在百度应用中注册申请.
    save_path_BSV_retrival_info : dict
        pickle方式保存下载信息，包括pt_fns-以路径为键，全景图下载地址列表为值；coords-以路径为键，采样点坐标列表为值；
                                 downloadError_idx-错误索引列表.

    Returns
    -------
    coords : dict
        以路径为键，值为采样点坐标列表.
    pts_num : int
        下载全景图的数量.
        
    '''
    import urllib,os
    from tqdm import tqdm
    import pickle
    
    downloadError_idx=[]
    coords={}
    pts_num={}    
    pt_fns={}
    for idx,row in pts_gdf.iterrows():
        pt_coords=[(pt.x,pt.y) for pt in row.geometry]
        coords[row.Name]=pt_coords
        pts_num[row.Name]=len(pt_coords)
    print("\npts_num={}".format(sum(pts_num.values())))
    
    urlRoot=r"http://api.map.baidu.com/panorama/v2?"
    query_dic={
        'width':'1024',
        'height':'512', 
        'fov':'360',
        'heading':'0',
        'pitch':'0',
        'coordtype':'wgs84ll',
        'ak':ak,
    }   
    # tt=0
    for k,v in tqdm(coords.items()):
        pt_fn=[]
        for i,coord in enumerate(v):
            pic_fn=os.path.join(save_path,"{}_{}.jpg".format(k,i))                        
            if not os.path.exists(pic_fn):
                #update query arguments
                query_dic.update({
                                  'location':str(coord[0])+','+str(coord[1]),
                                 })         
                url=urlRoot+urllib.parse.urlencode(query_dic)
                try:
                    data=urllib.request.urlopen(url)
                    pt_fn.append(pic_fn)
                    with open(pic_fn,'wb') as fp:
                        fp.write(data.read())           
                except:
                    downloadError_idx.append((k,i))
                    print('download_error:{},{}'.format(k,i))
            else:
                print("file existed.")
                
        pt_fns[k]=pt_fn
        # if tt==2:break
        # tt+=1
        
    with open(save_path_BSV_retrival_info["pt_fns"],'wb') as f:
        pickle.dump(pt_fns,f)
    with open(save_path_BSV_retrival_info["coords"],'wb') as f:
        pickle.dump(coords,f)       
    with open(save_path_BSV_retrival_info["downloadError_idx"],'wb') as f:
        pickle.dump(downloadError_idx,f)      
            
    return coords,pts_num

def img_valid(img_fns,save_path_img_valid):
    '''
    验证图像是否有效，即是否可以被打开

    Parameters
    ----------
    img_fns : dict
        图像路径字典.
    save_path_img_valid : dict
        保存路径字典.

    Returns
    -------
    img_val : dict
        返回有效图像字典.

    '''
    from tqdm import tqdm
    import pickle
    from PIL import Image
    
    img_val={}
    img_inval=[]
    for k,v in tqdm(img_fns.items()):
        fns=[]
        for fn in v:
            try:
                im=Image.open(fn)
                fns.append(fn)
            except:
                img_inval.append(fn)        
        img_val[k]=fns
            
    with open(save_path_img_valid["img_val"],'wb') as f:
        pickle.dump(img_val,f)        
    with open(save_path_img_valid["img_inval"],'wb') as f:
        pickle.dump(img_inval,f)                 
    return img_val

def img_valid_copy_folder(imgs_root,panoramic_imgs_valid_root):
    '''
    功能基本同img_valid(img_fns,save_path_img_valid)函数。除了验证图像是否有效，同时将其复制到新建的文件夹下

    Parameters
    ----------
    imgs_root : string
        图像根目录.
    panoramic_imgs_valid_root : string
        新建文件夹，复制有效图像至该文件夹.

    Returns
    -------
    None.

    '''
    from tqdm import tqdm
    import pickle
    import glob,os 
    from PIL import Image
    import shutil
    
    img_fns=glob.glob(os.path.join(imgs_root,'*.jpg'))
    # print(img_fns)  
    img_val=[]
    img_inval=[]
    for fn in tqdm(img_fns):
        try:
            im=Image.open(fn)
            img_val.append(fn)
        except:
            img_inval.append(fn)    
    # print(img_val)
    for fn in tqdm(img_val):
        shutil.copy(fn,panoramic_imgs_valid_root)   
        
def roads_pts4bsv_tourLine(roads_gdf,distance=10):
    '''
    由道路GeoDataFrame数据，提取给定距离的采样点

    Parameters
    ----------
    roads_gdf : GeoDataFrame
        道路线.
    distance : numericle value, optional
        指定采样距离. The default is 10.

    Returns
    -------
    GeoDataFrame
        采样点.

    '''
    from tqdm import tqdm
    import numpy as np
    from shapely.geometry import MultiPoint
    import pyproj
    from shapely.ops import transform
    import geopandas as gpd
    
    tqdm.pandas()    
    def line_pts(line):
        dists=np.arange(0,line.length,distance)
        pts=MultiPoint([line.interpolate(d,normalized=False) for d in dists])
        return pts      
        
    roads_gdf['pts']=roads_gdf.geometry.progress_apply(line_pts)
    
    wgs84=pyproj.CRS('EPSG:4326')
    utm=roads_gdf.crs #pyproj.CRS(roads_gpd.crs.srs)
    project=pyproj.Transformer.from_crs(utm, wgs84, always_xy=True).transform
    roads_gdf['pts_wgs84']=roads_gdf.pts.progress_apply(lambda row:transform(project,row))    
    
    pts_gdf=gpd.GeoDataFrame(roads_gdf[['Name','group']],geometry=roads_gdf.pts_wgs84.to_list(),crs=wgs84) #roads_gdf.drop(['geometry'],axis=1)    
    return pts_gdf

def pts_number_check(pts):
    '''
    查看采样点，打印数量

    Parameters
    ----------
    pts : GeoDataFrame
        输入点数据.

    Returns
    -------
    None.

    '''
    
    downloadError_idx=[]
    coords={}
    pts_num={}    
    pt_fns={}
    for idx,row in pts.iterrows():
        pt_coords=[(pt.x,pt.y) for pt in row.geometry]
        coords[row.Name]=pt_coords
        pts_num[row.Name]=len(pt_coords)
    # print(coords)
    print("\npts_num={}".format(sum(pts_num.values())))

if __name__=="__main__":
    from database import postSQL2gpd,gpd2postSQL,cfg_load_yaml   
    import pickle
    
    cfg=cfg_load_yaml('config.yml')
    
    #1.读取道路，提取采样点后写入数据库
    roads=postSQL2gpd(table_name='road',
                geom_col=cfg["postgreSQL"]["geom_col"],
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])     
    pts_gdf=roads_pts4bsv(roads,cfg['streetview']['distance_region'])
    gpd2postSQL(pts_gdf,
                table_name='pts_region',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"])  
    
    #2.从百度地图应用中下载全景静态图
    coords,pts_num=baidu_steetview_crawler(pts_gdf,
                                           cfg["streetview"]["save_path_BSV_region"],
                                           cfg["streetview"]["ak"],
                                           cfg["streetview"]["save_path_BSV_retrival_info"])
    #3.验证下载的全景图是否有效，并将有效全景图复制到新建文件夹中
    with open(cfg["streetview"]["save_path_BSV_retrival_info"]["pt_fns"],'rb') as f:
        pt_fns=pickle.load(f)    
    img_val=img_valid(pt_fns,cfg["streetview"]["save_path_img_valid"])  #14973 /13359  14973-13359=1614
 
    img_valid_copy_folder(cfg["streetview"]["save_path_BSV_region"],cfg["streetview"]["panoramic_imgs_valid_root"])
    
    #4. 过去街道采样点，从百度地图应用检索街道全景图下载，并验证有效性，将有效图像保存到新建文件夹下。代码同上（区域检索）
    tour_line=postSQL2gpd(table_name='tour_line',
                geom_col=cfg["postgreSQL"]["geom_col"],
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
    pts_tourLine_gdf=roads_pts4bsv_tourLine(tour_line,cfg['streetview']['distance_street']) 
    pts_number_check(pts_tourLine_gdf)
    gpd2postSQL(pts_tourLine_gdf,
                table_name='pts_tourline',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
    coords_street,pts_num_street=baidu_steetview_crawler(pts_tourLine_gdf,
                                                        cfg["streetview"]["save_path_BSV_street"],
                                                        cfg["streetview"]["ak"],
                                                        cfg["streetview"]["save_path_BSV_retrival_info_street"])     
    img_valid_copy_folder(cfg["streetview"]["save_path_BSV_street"],cfg["streetview"]["panoramic_imgs_valid_root_street"])

```

* 全景图像素级语义分割（Pixel-wise semantic segmentation）

应用[PASS（ERF-PSPNet）深度学习模型](https://github.com/elnino9ykl/PASS)实现全景图像素级语义分割。可以从给定的链接处下载计算。

* 百度POI数据检索下载，转换为GeoDataFrame后保存到数据库

POI数据检索方法可以参考‘数据POI与描述性统计和正态分布’章节部分。新定义的转换方法追加到`database.py`中。

`database.py`（追加）
```python

def filePath_extraction(dirpath,fileType):  
    '''
    funciton  -以所在文件夹路径为键，值为包含该文件夹下所有文件名的列表。文件类型可以自行定义 
    
    Paras:
        dirpath - 根目录，存储所有待读取的文件
        fileType - 待读取文件的类型
    '''
    import os
    filePath_Info={}
    i=0
    for dirpath,dirNames,fileNames in os.walk(dirpath): #os.walk()遍历目录，使用help(os.walk)查看返回值解释
       i+=1
       if fileNames: #仅当文件夹中有文件时才提取
           tempList=[f for f in fileNames if f.split('.')[-1] in fileType]
           if tempList: #剔除文件名列表为空的情况，即文件夹下存在不为指定文件类型的文件时，上一步列表会返回空列表[]
               filePath_Info.setdefault(dirpath,tempList)
    return filePath_Info

def csv2df(poi_fn_csv):
    '''
    转换.csv格式的POI数据为pandas的DataFrame

    Parameters
    ----------
    poi_fn_csv : string
        单个.csv文件路径.

    Returns
    -------
    poi_df : DataFrame
        POI点数据.

    '''
    import pandas as pd
    from benedict import benedict #benedict库是dict的子类，支持键列表（keylist）/键路径（keypath），应用该库的flatten方法展平嵌套的字典，准备用于DataFrame数据结构
    import csv

    n=0
    with open(poi_fn_csv, newline='',encoding='utf-8') as csvfile:
        poi_reader=csv.reader(csvfile)
        poi_dict={}    
        poiExceptions_dict={}
        for row in poi_reader:    
            if row:
                try:
                    row_benedict=benedict(eval(row[0])) #用eval方法，将字符串字典"{}"转换为字典{}
                    flatten_dict=row_benedict.flatten(separator='_') #展平嵌套字典
                    poi_dict[n]=flatten_dict
                except:                    
                    print("incorrect format of data_row number:%s"%n)                    
                    poiExceptions_dict[n]=row
            n+=1
            #if n==5:break #因为循环次数比较多，在调试代码时，可以设置停止的条件，节省时间与方便数据查看
    poi_df=pd.concat([pd.DataFrame(poi_dict[d_k].values(),index=poi_dict[d_k].keys(),columns=[d_k]).T for d_k in poi_dict.keys()], sort=True,axis=0)
    # print("_"*50)
    for col in poi_df.columns:
        try:
            poi_df[col]=pd.to_numeric(poi_df[col])
        except:
            pass
            #print("%s data type is not converted..."%(col))
    print("_"*50)
    print(".csv to DataFrame is completed!")
    #print(poi_df.head()) #查看最终DataFrame格式下POI数据
    #print(poi_df.dtypes) #查看数据类型
    return poi_df

def poi_csv2GeoDF_batch(poi_paths,fields_extraction,save_path):
    '''
    .csv格式POI数据批量转换为GeoDataFrame，需要调用转换.csv格式的POI数据为pandas的DataFrame函数csv2df(poi_fn_csv)'

    Parameters
    ----------
    poi_paths : dict
        poi路径字典.
    fields_extraction : list
        待提取的字段列表.
    save_path : dict
        GeoJSON、Shapefile和pickle三种数据格式各自的保存路径.

    Returns
    -------
    poiAll_gpd : GeoDataFrame
        poi的GeoDataFrame数据格式.

    '''
    import os,pathlib
    import pandas as pd
    import geopandas as gpd
    from shapely.geometry import Point
    #循环读取与转换poi的.csv文件为pandas的DataFrame数据格式
    poi_df_dic={}
    i=0
    for key in poi_paths:
        for val in poi_paths[key]:
            poi_csvPath=os.path.join(key,val)
            poi_df=csv2df(poi_csvPath) #注释掉了了csv2df()函数内部的print("%s data type is not converted..."%(col))语句，以pass替代，减少提示内容，避免干扰
            print(val)
            poi_df_path=pathlib.Path(val)
            poi_df_dic[poi_df_path.stem]=poi_df
            
            #if i==2:break
            i+=1
    poi_df_concat=pd.concat(poi_df_dic.values(),keys=poi_df_dic.keys(),sort=True)
    #print(poi_df_concat.loc[['poi_0_delicacy'],:]) #提取index为 'poi_0_delicacy'的行，验证结果
    poi_fieldsExtraction=poi_df_concat.loc[:,fields_extraction]
    poi_geoDF=poi_fieldsExtraction.copy(deep=True)
    poi_geoDF['geometry']=poi_geoDF.apply(lambda row:Point(row.location_lng,row.location_lat),axis=1) 
    # crs_4326=CRS('epsg:4326') #配置坐标系统，参考：https://spatialreference.org/     
    crs_4326='epsg:4326'
    poiAll_gpd=gpd.GeoDataFrame(poi_geoDF,crs=crs_4326)     
    
    poiAll_gpd.to_pickle(save_path['pkl'])
    # poiAll_gpd.to_file(save_path['geojson'],driver='GeoJSON')
    
    poiAll_gpd2shp=poiAll_gpd.reset_index() #不指定level参数，例如Level=0，会把多重索引中的所有索引转换为列
    poiAll_gpd2shp.rename(columns={
        'location_lat':'lat', 'location_lng':'lng',
        'detail_info_tag':'tag','detail_info_overall_rating':'rating', 'detail_info_price':'price'},inplace=True)
    poiAll_gpd2shp.to_file(save_path['shp'],encoding='utf-8')
        
    return poiAll_gpd

if __name__=="__main__":
    #6.转换POI(.csv,.json)为GeoDataFrame格式，并写入数据库
    fileType=["csv"]
    poi_paths=filePath_extraction(cfg["POI"]["poi_path"],fileType)
    #分别存储为GeoJSON、Shapefile和pickle三种数据格式
    poi_gpd=poi_csv2GeoDF_batch(poi_paths,cfg["POI"]["fields_extraction"],cfg["POI"]["save_path_POI"])
    gpd2postSQL(poi_gpd,
                table_name='poi',
                myusername=cfg["postgreSQL"]["myusername"],
                mypassword=cfg["postgreSQL"]["mypassword"],
                mydatabase=cfg["postgreSQL"]["mydatabase"]) 
```

至此数据获取及预处理部分基本完成。后续的分析可以直接从本地关系数据库`PAPER_Urban_Street_Space_Metrics`中读取数据，以及写入分析过程中新产生的数据。

##### B.2.2.2 QGIS建立地图

除了在python中从数据库中读入数据，打印查看外，最终出图推荐用QGIS通过`PostGIS`配置连接到数据库，读取和查看数据。可以用`Project->New print layout`建立布局，打印输出。

__Fig. 区域尺度全景图采样点__  

<a href=""><img src="./imgs/3_2_1_01.png" height="auto" width="auto" title="caDesign"></a>

__Fig. 街道尺度区段与POI数据__  

<a href=""><img src="./imgs/3_2_1_02.png" height="auto" width=800 title="caDesign"></a>

##### B.2.2.3 全景图与语义分割图预处理




#### B.2.3 分析与结果




#### B.参考文献



### B.3 讨论与结论


## B. 研究代码更新与发布




